





# 701 Insert into a Binary Search Tree

<img src="701-800.assets/image-20210513161909224.png" alt="image-20210513161909224" style="zoom:50%;" />

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
	if root == nil{
		root = new(TreeNode)
		root.Val = val
		return root
	}
	
	if root.Val < val{
		root.Right = insertIntoBST(root.Right, val)
		return root
	}else{
		root.Left = insertIntoBST(root.Left, val)
		return root
	}
	
}
```





# 703 Kth largest Element  in a Stream





```java
//pq 的解法
PriorityQueue<Integer> queue;
    int k;
    public KthLargest(int k, int[] nums) {
        this.k = k;
        queue = new PriorityQueue<>((o1, o2) -> (o1 - o2));
        for(int num : nums) {
            if(queue.size() == k){
                if(queue.peek() > num)
                    continue;
                else {
                    queue.poll();
                    queue.add(num);
                }
            }else{
                queue.add(num);
            }
        }
    }

    public int add(int val) {
        if(queue.size() == k){
            if(queue.peek() <= val){
                queue.poll();
                queue.add(val);
            }
        }else{
            queue.add(val);
        }

        return queue.peek();
    }
```





<img src="701-800.assets/image-20210530142500560.png" alt="image-20210530142500560" style="zoom:50%;" />

```java
class KthLargest {
   List<Integer> res;
    int k;
    public KthLargest(int k, int[] nums) {
        res = new ArrayList<>();
        for(int num : nums)
            res.add(num);

        Collections.sort(res, (o1, o2) -> o2 - o1);
        this.k = k;
    }

    public int add(int val) {
        for(int i = 0; i <= res.size(); i++){
            if(i == res.size()){
              res.add(val);
              break;
            } else if(val >= res.get(i)) {
                res.add(i, val);
                break;
            }
        }

        return res.get(k - 1);
    }
}
```









# 716 Max Stack



<img src="701-800.assets/image-20210529210358497.png" alt="image-20210529210358497" style="zoom:50%;" />

```java
public class MaxStack {
    DoubleLinkedList dll;
    TreeMap<Integer, List<Node>> map;
    /** initialize your data structure here. */
    public MaxStack() {
        dll = new DoubleLinkedList();
        map = new TreeMap<>();
    }

    public void push(int x) {
        Node newNode = new Node(x);
        dll.add(newNode);
        map.putIfAbsent(x, new ArrayList<>());

        map.get(x).add(newNode);
    }

    public int pop() {
        int val = top();
        List<Node> nodes = map.get(val);
        nodes.remove(nodes.size() - 1);
        dll.delete();
        
        if(map.get(val).size() == 0)
            map.remove(val);
        
        return val;
    }

    public int top() {
        return dll.tail.prev.val;
    }

    public int peekMax() {
        return map.lastKey();
    }

    public int popMax() {
        int maxVal = peekMax();
        List<Node> nodes = map.get(maxVal);
        Node node = nodes.get(nodes.size() - 1);
        nodes.remove(nodes.size() - 1);
        if(nodes.size() == 0)
            map.remove(maxVal);
        
        dll.delete(node);

        return maxVal;
    }
}

class DoubleLinkedList{
    Node head;
    Node tail;

    public DoubleLinkedList(){
        head = new Node(0);
        tail = new Node(0);

        head.next = tail;
        tail.prev = head;
    }

    public void add(Node node){
        node.next = tail;
        node.prev = tail.prev;

        tail.prev.next = node;
        tail.prev = node;
    }

    public void delete(){
        tail.prev.prev.next = tail;
        tail.prev = tail.prev.prev;
    }
    
    public void delete(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}

class Node{
    public int val;
    public Node next;
    public Node prev;

    public Node(int val){
        this.val = val;
    }
}
```









# 717 1-bit and 2-bit Characters

<img src="701-800.assets/image-20210520112517783.png" alt="image-20210520112517783" style="zoom:50%;" />

```go
func isOneBitCharacter(bits []int) bool {
	index := 0

	for ;index < len(bits);{
		if bits[index] == 0{
			index++
		}else {
			if index + 2 == len(bits){
				return false
			}
			index += 2
		}
	}

	return true
}
```





# 718 Maximum Length of Repeated Subarray



```go
//使用 DP 优化
//时间复 O(N*M)
func findLength(nums1 []int, nums2 []int) int {
    res := 0
    dp := make([][]int, len(nums1))
    for i := len(nums1) - 1; i >= 0; i--{
        dp[i] = make([]int, len(nums2))
        for j := len(nums2) - 1; j >= 0; j--{
            if nums1[i] == nums2[j]{
                if i == len(nums1) - 1 || j == len(nums2) - 1{
                    dp[i][j] = 1
                }else{
                    dp[i][j] = 1 + dp[i + 1][j + 1]
                }

                if dp[i][j] > res{
                    res = dp[i][j]
                }
            }
        }
    }

    return res
}
```





<img src="701-800.assets/image-20210519141624947.png" alt="image-20210519141624947" style="zoom:50%;" />

```go
//超时
func findLength(nums1 []int, nums2 []int) int {
	res := 0
	for i := 0; i < len(nums1); i++{
		for j := 0; j < len(nums2); j++{
			for k := 0; i + k < len(nums1) && j + k < len(nums2);k++{
				if nums1[i + k] == nums2[j + k]{
					if res < k + 1{
						res = k + 1
					}
				}else{
					break
				}
			}
		}	
	}
	
	return res
}

```





# 735 Asteroid Coollisioon



<img src="701-800.assets/image-20210605144956246.png" alt="image-20210605144956246" style="zoom:50%;" />

```java
    public int[] asteroidCollision(int[] asteroids) {
        List<Integer> ans = new ArrayList<>();
        
        for(int i = 0; i < asteroids.length; i++){
            if(ans.size() == 0 || ans.get(ans.size() - 1) < 0 || asteroids[i] > 0){
                ans.add(asteroids[i]);
            }else{
                int flag = 0;
                while(ans.size() > 0 && ans.get(ans.size() - 1) > 0){
                    if(ans.get(ans.size() - 1) == -1 * asteroids[i]){
                        ans.remove(ans.size() - 1);
                        flag = 1;
                        break;
                    }else if(ans.get(ans.size() - 1) > -1 * asteroids[i]){
                        flag = 1;
                        break;
                    }else{
                        ans.remove(ans.size() - 1);
                    }
                }

                if(flag == 0)
                    ans.add(asteroids[i]);
            }
        }
        
        int[] res = new int[ans.size()];
        for(int i = 0; i < ans.size(); i++)
            res[i] = ans.get(i);
        return res;
    }
```





<img src="701-800.assets/image-20210601092733940.png" alt="image-20210601092733940" style="zoom:50%;" />

```java
    public int[] asteroidCollision(int[] asteroids) {
        List<Integer> res= new ArrayList<>();

        int left = 0;
        for(int i = 0; i < asteroids.length; i++){
            if(res.size() == 0) {
                res.add(asteroids[i]);
            }else if(res.get(res.size() - 1) * asteroids[i] > 0 || (res.get(res.size() - 1) < 0 && asteroids[i] > 0)){
                res.add(asteroids[i]);

            }else{
                int attacker = asteroids[i];
                boolean settled = false;
                while(res.size() != 0 && res.get(res.size() - 1) > 0 && attacker < 0){
                    int defend = res.get(res.size() - 1);
                    if(Math.abs(defend) >= Math.abs(attacker)){
                        if(Math.abs(defend) == Math.abs(attacker))
                            res.remove(res.size() - 1);
                        settled = true;
                        break;
                    }else{
                         res.remove(res.size() - 1);
                    }
                }

                if(!settled)
                    res.add(attacker);

            }
        }

        int[] ans = new int[res.size()];
        for(int i = 0; i < res.size(); i++)
            ans[i] = res.get(i);
        return ans;
    }

```









# 763 Partition Labels

<img src="701-800.assets/image-20210508144006309.png" alt="image-20210508144006309" style="zoom:50%;" />

<img src="701-800.assets/image-20210508151233683.png" alt="image-20210508151233683" style="zoom:50%;" />

```java
    public List<Integer> partitionLabels(String S) {
        List<Integer> res = new ArrayList<>();
        int len = S.length();

        int[] alpha = new int[26];
        int[] record = new int[S.length()];
        Arrays.fill(alpha, -1);

        for(int i = len- 1; i >= 0; i--){
            int pos = S.charAt(i) - 'a';
            if(alpha[pos] != -1){
                record[i] = alpha[pos];
            }else{
                record[i] = -1;
            }

            alpha[pos] = i;
        }


        int left = 0, right = 0;
        while(right < len){
            int index = left;
            while(index < len){
                char ch = S.charAt(right);
                right = Math.max(record[index], right);

                if(index == right)
                    break;

                index++;
            }

            res.add(right - left + 1);

            right++;
            left = right ;
        }

        return res;
    }
```







# 777 Swap Adjacent in LR Strign



```java
//39 / 94 超时
public class Solution {
    /**
     * The Algorithm is kind of like backtrack
     * where I try for every possible way
     * then to add into our result set
     * @param start
     * @param end
     * @return
     */
    
    int counter = 0;
    public boolean canTransform(String start, String end) {
        backtrack(start.toCharArray(), end.toCharArray());
        return counter != 0;
    }

    private void backtrack(char[] start, char[] end) {
        if(counter >= 2){
            return;
        }
        
        if(Arrays.equals(start, end)){
            counter++;
            return; 
        }
        
        if(noExchange(start)){
            return;
        }
        
        for(int i = 0; i < start.length - 1; i++){
            if(start[i] == 'X' && start[i + 1] == 'L'){
                start[i] = 'L';
                start[i + 1] = 'X';
                
                backtrack(start, end);
                
                start[i] = 'X';
                start[i + 1] = 'L';
            }
                
            if(counter >= 2)
                return;
            
            if(start[i] == 'R' && start[i + 1] == 'X'){
                start[i] = 'X';
                start[i + 1] = 'R';
                
                backtrack(start, end);;
                
                start[i] = 'R';
                start[i + 1] = 'X';
            }
        }
    }

    private boolean noExchange(char[] starts) {
        for(int i = 0; i < starts.length - 1; i++){
            if(starts[i] == 'X' && starts[i + 1] == 'L')
                return false;
            if(starts[i] == 'R' && starts[i + 1] == 'X')
                return false;
        }
        
        return true;
    }
}
```



```java
//BFS 超时 56 / 94
public boolean canTransform(String start, String end) {
        if(start.equals(end))
            return true;

        Set<String> visited = new HashSet<>();
        Deque<String> queue = new ArrayDeque<>();
        queue.add(start);
        visited.add(start);

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i =0; i < size; i++){
                String cur = queue.removeFirst();

                if(cur.equals(end))
                    return true;

                char[] curs = cur.toCharArray();
                for(int k = 0; k < curs.length - 1; k++){
                    if(curs[k] == 'X' && curs[k + 1] == 'L'){
                        curs[k] = 'L';
                        curs[k + 1] = 'X';

                        String str = toStr(curs);
                        if(!visited.contains(str)){
                            queue.addLast(str);
                            visited.add(str);
                        }

                        curs[k] = 'X';
                        curs[k + 1] = 'L';
                    }

                    if(curs[k] == 'R' && curs[k + 1] == 'X'){
                        curs[k] = 'X';
                        curs[k + 1] = 'R';

                        String str = toStr(curs);
                        if(!visited.contains(str)){
                            queue.addLast(str);
                            visited.add(str);
                        }

                        curs[k] = 'R';
                        curs[k + 1] = 'X';
                    }
                }
            }
        }

        return false;
    }

    private String toStr(char[] curs) {
        StringBuilder sb = new StringBuilder();
        for(char ch : curs)
            sb.append(ch);
        
        return sb.toString();
    }
```





```java
    public boolean canTransform(String start, String end) {
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        int len1 = start.length();
        int len2 = end.length();

        for(int i = 0; i < start.length(); i++){
            char ch = start.charAt(i);
            if(ch != 'X')
                sb1.append(ch);
        }

        for(int i = 0; i < end.length(); i++){
            char ch = end.charAt(i);
            if(ch != 'X')
                sb2.append(ch);
        }

        if(!sb1.toString().equals(sb2.toString()))
            return false;

        int up = 0, down = 0;


        while(up < len1 && down < len2){
            while(up < len1 && start.charAt(up) != 'L')
                up++;
            while(down < len2 && end.charAt(down) != 'L')
                down++;

            if(up == len1 || down == len2){
                if(noSymbol(start, up + 1, 'L', true) && noSymbol(end, down + 1, 'L', true))
                    break;
                else
                    return false;
            }

            if(up < down)
                return false;
            up++;
            down++;
        }

        up = len1 - 1;
        down = len2 -1;

        while(up >= 0 && down >= 0){
            while(up >= 0 && start.charAt(up) != 'R')
                up--;
            while(down >= 0 && end.charAt(down) != 'R')
                down--;

            if(up == 0 || down == 0){
                if(noSymbol(start, up - 1, 'R', false) && noSymbol(end, down - 1, 'R', false))
                    break;
                else
                    return false;
            }

            if(up > down)
                return false;
            up--;
            down--;
        }

        return true;
    }

    private boolean noSymbol(String str, int index, char ch, boolean l2r) {
        if(l2r){
            for(int i = index; i < str.length(); i++){
                if(str.charAt(i) == ch)
                    return false;
            }

            return true;
        }else{
            for(int i = index; i >= 0; i--){
                if(str.charAt(i) == ch)
                    return false;
            }

            return true;
        }

    }

```





# 780 Reaching Points



```java
class Solution {
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        while(sx < tx && sy < ty){
            if(tx < ty)
                ty %= tx;
            else
                tx %= ty;
        }

        if(sx == tx && sy <= ty)
            return (ty - sy) % sx == 0;
        else
            return sy == ty && sx <= tx && (tx - sx) % sy == 0;
    }
}
```



```java
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        Deque<Point> queue = new ArrayDeque<>();
        Point root = new Point(sx, sy);
        Point end  = new Point(tx, ty);
        Set<Point> visited = new HashSet<>();
        queue.addLast(root);


        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                Point cur = queue.removeFirst();
                visited.add(cur);
                System.out.println(cur);
                if(cur.equals(end))
                    return true;

                if(cur.x + cur.y > tx + ty || cur.x + cur.y < 0)
                    continue;

                Point left = new Point(cur.x + cur.y, cur.y);
                Point right = new Point(cur.x, cur.x + cur.y);

                if(!visited.contains(left)){
                    queue.addLast(left);
                }

                if(!visited.contains(right)){
                    queue.addLast(right);
                }
            }
        }

        return false;
    }

```







# 783 Minimum Distance Between BST Nodes

<img src="701-800.assets/image-20210212173900740.png" alt="image-20210212173900740" style="zoom:50%;" />

```java
    TreeNode pre = null;
    long res = Integer.MAX_VALUE;
    public int minDiffInBST(TreeNode root) {
        inorder(root);

        return (int)res;
    }

    public void inorder(TreeNode root){
        if(root == null)    
            return;
        
        inorder(root.left);

        if(pre != null)
            res = Math.min(res, Math.abs((long)(root.val) - (long)(pre.val)));
        
        pre = root;

        inorder(root.right);
    }
```







# 787 Cheapest Flights Within K Stops



```java
//超时， 通过 27 / 49 个案例
class Solution {
   Map<Integer, List<String>> map = new HashMap<>();
    int res = Integer.MAX_VALUE;
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        for(int[] flight : flights){
            map.putIfAbsent(flight[0], new ArrayList<>());
            map.get(flight[0]).add(flight[1] +  "@" +flight[2]);
        }

        dfs(dst, k, src, 0, 0, new boolean[n]);

        return res == Integer.MAX_VALUE ? -1 : res;
    }

    private void dfs(int dst, int k, int cur, int step, int price, boolean[] visited) {
        if(cur == dst && k + 1 >= step){
            res = Math.min(res, price);
            return;
        }

        visited[cur] = true;
        
        List<String> strings = map.get(cur);
        if(strings == null || strings.size() == 0){
            return;
        }

        for(String str : strings){
            String[] split = str.split("@");
            if(visited[Integer.parseInt(split[0])])
                continue;
            
            visited[Integer.parseInt(split[0])] = true;
            dfs(dst, k, Integer.parseInt(split[0]), step + 1, price + Integer.parseInt(split[1]), visited);
            visited[Integer.parseInt(split[0])] = false;
        }

    }
}
```







# 791 Custom Sort String



```java
    public String customSortString(String order, String str) {
        Map<Character, Integer> map = new HashMap<>();

        for(char ch : str.toCharArray())
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        
        StringBuilder res = new StringBuilder();
        for(int i =0; i < order.length(); i++){
            char ch = order.charAt(i);
            if(!map.containsKey(ch))
                continue;
            
            for(int j = 0; j < map.get(ch); j++)
                res.append(ch);
            
            map.remove(ch);
        }

        for(char ch : map.keySet()){
            for(int i = 0; i < map.get(ch); i++)
                res.append(ch);
        }

        return res.toString();
    }
```









# 797 All Paths From Source to Target



<img src="701-800.assets/image-20210512091732388.png" alt="image-20210512091732388" style="zoom:50%;" />

```java
//典型 DFS
	List<List<Integer>> res = new ArrayList<>();
    int n;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        n = graph.length;
        List<Set<Integer>> bags = new ArrayList<>();
        for(int i = 0; i <= n - 1; i++)
            bags.add(new HashSet<>());

        for(int i = 0; i < graph.length; i++){
            int[] edges = graph[i];
            for(int num : edges)
                bags.get(i).add(num);
        }
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(bags, new HashSet<>(), path, 0);
        return res;
    }

    private void dfs(List<Set<Integer>> bags, HashSet<Integer> visited, List<Integer> path, int bagNum) {
        if(bagNum == n - 1){
            res.add(new ArrayList<>(path));
        }

        Set<Integer> bag = bags.get(bagNum);

        for(Integer nextBag : bag){
            if(visited.contains(nextBag))
                continue;

            visited.add(nextBag);
            path.add(nextBag);
            dfs(bags, visited, path, nextBag);
            visited.remove(nextBag);
            path.remove(path.size() - 1);
        }

    }
```

