

# 777 Swap Adjacent in LR Strign



```java
//39 / 94 超时
public class Solution {
    /**
     * The Algorithm is kind of like backtrack
     * where I try for every possible way
     * then to add into our result set
     * @param start
     * @param end
     * @return
     */
    
    int counter = 0;
    public boolean canTransform(String start, String end) {
        backtrack(start.toCharArray(), end.toCharArray());
        return counter != 0;
    }

    private void backtrack(char[] start, char[] end) {
        if(counter >= 2){
            return;
        }
        
        if(Arrays.equals(start, end)){
            counter++;
            return; 
        }
        
        if(noExchange(start)){
            return;
        }
        
        for(int i = 0; i < start.length - 1; i++){
            if(start[i] == 'X' && start[i + 1] == 'L'){
                start[i] = 'L';
                start[i + 1] = 'X';
                
                backtrack(start, end);
                
                start[i] = 'X';
                start[i + 1] = 'L';
            }
                
            if(counter >= 2)
                return;
            
            if(start[i] == 'R' && start[i + 1] == 'X'){
                start[i] = 'X';
                start[i + 1] = 'R';
                
                backtrack(start, end);;
                
                start[i] = 'R';
                start[i + 1] = 'X';
            }
        }
    }

    private boolean noExchange(char[] starts) {
        for(int i = 0; i < starts.length - 1; i++){
            if(starts[i] == 'X' && starts[i + 1] == 'L')
                return false;
            if(starts[i] == 'R' && starts[i + 1] == 'X')
                return false;
        }
        
        return true;
    }
}
```



```java
//BFS 超时 56 / 94
public boolean canTransform(String start, String end) {
        if(start.equals(end))
            return true;

        Set<String> visited = new HashSet<>();
        Deque<String> queue = new ArrayDeque<>();
        queue.add(start);
        visited.add(start);

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i =0; i < size; i++){
                String cur = queue.removeFirst();

                if(cur.equals(end))
                    return true;

                char[] curs = cur.toCharArray();
                for(int k = 0; k < curs.length - 1; k++){
                    if(curs[k] == 'X' && curs[k + 1] == 'L'){
                        curs[k] = 'L';
                        curs[k + 1] = 'X';

                        String str = toStr(curs);
                        if(!visited.contains(str)){
                            queue.addLast(str);
                            visited.add(str);
                        }

                        curs[k] = 'X';
                        curs[k + 1] = 'L';
                    }

                    if(curs[k] == 'R' && curs[k + 1] == 'X'){
                        curs[k] = 'X';
                        curs[k + 1] = 'R';

                        String str = toStr(curs);
                        if(!visited.contains(str)){
                            queue.addLast(str);
                            visited.add(str);
                        }

                        curs[k] = 'R';
                        curs[k + 1] = 'X';
                    }
                }
            }
        }

        return false;
    }

    private String toStr(char[] curs) {
        StringBuilder sb = new StringBuilder();
        for(char ch : curs)
            sb.append(ch);
        
        return sb.toString();
    }
```





```java
    public boolean canTransform(String start, String end) {
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        int len1 = start.length();
        int len2 = end.length();

        for(int i = 0; i < start.length(); i++){
            char ch = start.charAt(i);
            if(ch != 'X')
                sb1.append(ch);
        }

        for(int i = 0; i < end.length(); i++){
            char ch = end.charAt(i);
            if(ch != 'X')
                sb2.append(ch);
        }

        if(!sb1.toString().equals(sb2.toString()))
            return false;

        int up = 0, down = 0;


        while(up < len1 && down < len2){
            while(up < len1 && start.charAt(up) != 'L')
                up++;
            while(down < len2 && end.charAt(down) != 'L')
                down++;

            if(up == len1 || down == len2){
                if(noSymbol(start, up + 1, 'L', true) && noSymbol(end, down + 1, 'L', true))
                    break;
                else
                    return false;
            }

            if(up < down)
                return false;
            up++;
            down++;
        }

        up = len1 - 1;
        down = len2 -1;

        while(up >= 0 && down >= 0){
            while(up >= 0 && start.charAt(up) != 'R')
                up--;
            while(down >= 0 && end.charAt(down) != 'R')
                down--;

            if(up == 0 || down == 0){
                if(noSymbol(start, up - 1, 'R', false) && noSymbol(end, down - 1, 'R', false))
                    break;
                else
                    return false;
            }

            if(up > down)
                return false;
            up--;
            down--;
        }

        return true;
    }

    private boolean noSymbol(String str, int index, char ch, boolean l2r) {
        if(l2r){
            for(int i = index; i < str.length(); i++){
                if(str.charAt(i) == ch)
                    return false;
            }

            return true;
        }else{
            for(int i = index; i >= 0; i--){
                if(str.charAt(i) == ch)
                    return false;
            }

            return true;
        }

    }

```









# 783 Minimum Distance Between BST Nodes

<img src="701-800.assets/image-20210212173900740.png" alt="image-20210212173900740" style="zoom:50%;" />

```java
    TreeNode pre = null;
    long res = Integer.MAX_VALUE;
    public int minDiffInBST(TreeNode root) {
        inorder(root);

        return (int)res;
    }

    public void inorder(TreeNode root){
        if(root == null)    
            return;
        
        inorder(root.left);

        if(pre != null)
            res = Math.min(res, Math.abs((long)(root.val) - (long)(pre.val)));
        
        pre = root;

        inorder(root.right);
    }
```

