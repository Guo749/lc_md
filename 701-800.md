





# 701 Insert into a Binary Search Tree

<img src="701-800.assets/image-20210513161909224.png" alt="image-20210513161909224" style="zoom:50%;" />

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
	if root == nil{
		root = new(TreeNode)
		root.Val = val
		return root
	}
	
	if root.Val < val{
		root.Right = insertIntoBST(root.Right, val)
		return root
	}else{
		root.Left = insertIntoBST(root.Left, val)
		return root
	}
	
}
```





# 703 Kth largest Element  in a Stream





```java
//pq 的解法
PriorityQueue<Integer> queue;
    int k;
    public KthLargest(int k, int[] nums) {
        this.k = k;
        queue = new PriorityQueue<>((o1, o2) -> (o1 - o2));
        for(int num : nums) {
            if(queue.size() == k){
                if(queue.peek() > num)
                    continue;
                else {
                    queue.poll();
                    queue.add(num);
                }
            }else{
                queue.add(num);
            }
        }
    }

    public int add(int val) {
        if(queue.size() == k){
            if(queue.peek() <= val){
                queue.poll();
                queue.add(val);
            }
        }else{
            queue.add(val);
        }

        return queue.peek();
    }
```





<img src="701-800.assets/image-20210530142500560.png" alt="image-20210530142500560" style="zoom:50%;" />

```java
class KthLargest {
   List<Integer> res;
    int k;
    public KthLargest(int k, int[] nums) {
        res = new ArrayList<>();
        for(int num : nums)
            res.add(num);

        Collections.sort(res, (o1, o2) -> o2 - o1);
        this.k = k;
    }

    public int add(int val) {
        for(int i = 0; i <= res.size(); i++){
            if(i == res.size()){
              res.add(val);
              break;
            } else if(val >= res.get(i)) {
                res.add(i, val);
                break;
            }
        }

        return res.get(k - 1);
    }
}
```







# 704 Binary Search

<img src="701-800.assets/image-20210708084326487.png" alt="image-20210708084326487" style="zoom:50%;" />

```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while(left <= right){
            int mid = (left + right) / 2;

            if(nums[mid] == target){
                return mid;
            }else if(nums[mid] > target){
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        return -1;
    }
};
```



# 705 Design HashSet



```cpp
class MyHashSet {
public:
    vector<list<int>> data;
    static const int base = 1007;
    static int hash(int key){
        return key % base;
    }

    /** Initialize your data structure here. */
    MyHashSet() :data(base){

    }
    
    void add(int key) {
        int pos = hash(key);
        for(auto it = data[pos].begin(); it != data[pos].end(); it++){
            if((*it) == key)
                return;
        }

        data[pos].push_back(key);
    }
    
    void remove(int key) {
        int pos = hash(key);
        for(auto it = data[pos].begin(); it != data[pos].end(); it++){
            if((*it) == key){
                data[pos].erase(it);
                return;
            }
            
        }
    }
    
    /** Returns true if this set contains the specified element */
    bool contains(int key) {
        int pos = hash(key);
        for(auto it = data[pos].begin(); it != data[pos].end(); it++){
            if((*it) == key)
                return true;
        }

        return false;
    }
};

/**
 * Your MyHashSet object will be instantiated and called as such:
 * MyHashSet* obj = new MyHashSet();
 * obj->add(key);
 * obj->remove(key);
 * bool param_3 = obj->contains(key);
 */
```















# 706 Design HashMap

<img src="701-800.assets/image-20210728203002227.png" alt="image-20210728203002227" style="zoom:50%;" />



```cpp
class MyHashMap {
public:
    vector<list<pair<int, int>>> nodes;
    static const int BUCKETNUM = 1007;
    static int hash(int key){
        return key % BUCKETNUM;
    }
    /** Initialize your data structure here. */
    MyHashMap() : nodes(BUCKETNUM){ }
    
    /** value will always be non-negative. */
    void put(int key, int value) {
        int pos = hash(key);
        for(auto it = nodes[pos].begin(); it != nodes[pos].end(); it++){
            if((*it).first == key){
                (*it).second = value;
                return;
            }
        }

        nodes[pos].push_back({key, value});
    }
    
    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */
    int get(int key) {
        int pos = hash(key);
         for(auto it = nodes[pos].begin(); it != nodes[pos].end(); it++){
            if((*it).first == key){
                return (*it).second;
            }
        }       

        return -1;
    }
    
    /** Removes the mapping of the specified value key if this map contains a mapping for the key */
    void remove(int key) {
         int pos = hash(key);
         for(auto it = nodes[pos].begin(); it != nodes[pos].end(); it++){
            if((*it).first == key){
                nodes[pos].erase(it);
                return;
            }
        }       
       
    }
};

```





# 707 Design Linked List

<img src="701-800.assets/image-20211103144045178.png" alt="image-20211103144045178" style="zoom:50%;" />

```cpp
class Node{
public:
    int val;
    Node* next;
    Node* prev;

    Node(int v): val(v), next(nullptr), prev(nullptr){}
};

class MyLinkedList {
public:
    Node* head;
    Node* tail;
    int size;
    MyLinkedList() : head(new Node(0)), tail(new Node(0)), size(0){
        head->next = tail;
        tail->prev = head;
        size = 0;
    }

    int get(int index) {
        if(index >= size)
            return -1;
        Node* cur = head;
        for(int i = 0; i < index; i++){
            cur = cur->next;
        }

        return cur->next->val;
    }
    
    void addAtHead(int val) {
        Node* newNode = new Node(val);
        newNode->next = head->next;
        newNode->prev = head;

        head->next->prev = newNode;
        head->next       = newNode;
        size++;
    }
    
    void addAtTail(int val) {
        Node* newNode = new Node(val);
        newNode->next = tail;
        newNode->prev = tail->prev;

        tail->prev->next = newNode;
        tail->prev       = newNode;
        size++;
    }
    
    void addAtIndex(int index, int val) {
        if(index == size){
            addAtTail(val);
        }else if(index > size){
            return;
        }else{
            Node* cur = head;
            for(int i = 0; i < index; i++){
                cur = cur->next;
            }

            Node* newNode = new Node(val);
            newNode->next = cur->next;
            newNode->prev = cur;

            cur->next->prev = newNode;
            cur->next       = newNode;
            size++;
        }
    }
    
    void deleteAtIndex(int index) {
        if(index > size - 1){
            return;
        }
        Node* cur = head;

        for(int i = 0; i < index; i++){
            cur = cur->next;
        }

        cur->next = cur->next->next;
        cur->next->prev = cur;
        size--;
    }
};

```











# 708 Insert Into a Sorted Circular Linked List



```cpp
/*
		优化了下思路，找到最大的 node ， 然后根据它的值进行插入
*/

class Solution {
public:
    Node* insert(Node* head, int insertVal) {
        if(head == nullptr){
            head = new Node(insertVal);
            head->next = head;
            return head;
        }

        if(head->next == head){
            Node* node = new Node(insertVal);
            node->next = head;
            head->next = node;

            return head;
        }

        Node* cur = head;
        Node* maxNode = head;

        do{
            if(cur->val >= maxNode->val)
                maxNode = cur;
            cur = cur->next;
        }while(cur != head);

        if(insertVal > maxNode->val || insertVal < maxNode->next->val){
            Node* newNode = new Node(insertVal);
            newNode->next = maxNode->next;
            maxNode->next = newNode;
            return head;
        }

        cur = maxNode->next;
        while(cur != maxNode){
            if(cur->val <= insertVal && cur->next->val >= insertVal){
                Node* newNode = new Node(insertVal);
                newNode->next = cur->next;
                cur->next = newNode;
                return head;
            }

            cur = cur->next;
        }

        return head;
    }
};
```





<img src="701-800.assets/image-20210919121416181.png" alt="image-20210919121416181" style="zoom:50%;" />

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* next;

    Node() {}

    Node(int _val) {
        val = _val;
        next = NULL;
    }

    Node(int _val, Node* _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
public:
    Node* insert(Node* head, int insertVal) {
        // 0 nodes
        if(head == nullptr){
            head = new Node(insertVal);
            head->next = head;
            return head;
        }
        // 1 nodes
        if(head->next == head){
            Node* newNode = new Node(insertVal);
            newNode->next = head;
            head->next = newNode;
            return head;
        }
      
        Node* tail = nullptr;
        Node* cur = head;

        while(cur->next != head)
            cur = cur->next;
        tail = cur;

        Node* newNode = new Node(insertVal);
        if(head->val == tail->val){ // in case they are all the same
            newNode->next = head->next;
            head->next = newNode;

            return head;
        }

        Node* minNode = head;
        cur = head;
        do{
            if(cur->val < minNode->val)
                minNode = cur;
            cur = cur->next;
        }while(cur != head);

        if(minNode->val >= insertVal){
            cur = minNode;
            while(cur->next != minNode)
                cur = cur->next;
            
            newNode->next = cur->next;
            cur->next = newNode;
            cout << minNode->val << minNode->next->val << endl;
            return head;
        }else{
            cur = minNode;
            while(true){
                if(cur->val <= insertVal && cur->next->val >= insertVal){
                    newNode->next = cur->next;
                    cur->next = newNode;
                    return head;
                }else if(cur->val > cur->next->val){
                    newNode->next = cur->next;
                    cur->next = newNode;
                    return head;
                }

                cur = cur->next;
            }
        }
    }
};
```











# 712 Minimum ASCII Delete Sum for Two Strings

<img src="701-800.assets/image-20211104083332719.png" alt="image-20211104083332719" style="zoom:50%;" />

```cpp
class Solution {
public:
    int minimumDeleteSum(string s1, string s2) {
        int size1 = s1.size();
        int size2 = s2.size();

        vector<int> prefix1 = vector<int>(size1);
        vector<int> prefix2 = vector<int>(size2);

        //to memorize the result of prefix to cut leaves
        for(int i = 0; i < size1; i++){
            prefix1[i] = s1[i] + (i == 0 ? 0 : prefix1[i - 1]);
        }

        for(int i = 0; i < size2; i++){
            prefix2[i] = s2[i] + (i == 0 ? 0 : prefix2[i - 1]);
        }

        vector<vector<int>> dp(size1 + 1, vector<int>(size2 + 1, INT_MAX));
        for(int i = 0; i <= size1; i++){
            for(int j = 0; j <= size2; j++){
                if(i == 0 && j == 0)
                    dp[i][j] = 0;
                else if(i == 0)
                    dp[i][j] = prefix2[j - 1];
                else if(j == 0)
                    dp[i][j] = prefix1[i - 1];
                else{
                    if(s1[i - 1] == s2[j - 1]){
                        dp[i][j] = dp[i - 1][j - 1];
                    }else{
                        dp[i][j] = min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]);
                    }
                }
            }
        }

        return dp[size1][size2];
    }
};
```





```cpp
//暴力回溯，超时了
class Solution {
public:
    vector<int> prefix1;
    vector<int> prefix2;
    int minimumDeleteSum(string s1, string s2) {
        int size1 = s1.size();
        int sum = 0;
        prefix1 = vector<int>(size1);

        //to memorize the result of prefix to cut leaves
        for(int i = 0; i < size1; i++){
            prefix1[i] = s1[i] + (i == 0 ? 0 : prefix1[i - 1]);
        }

        int size2 = s2.size();
        sum = 0;
        prefix2 = vector<int>(size2);
        for(int i = 0; i < size2; i++){
            prefix2[i] = s2[i] + (i == 0 ? 0 : prefix2[i - 1]);
        }

        return backtrack(s1, s2, size1 - 1, size2 - 1);
    }

    //what is the least money I will spend on this situation?
    int backtrack(string& s1, string& s2, int index1, int index2){
        if(index1 < 0 && index2 < 0){
            return 0;
        }else if(index1 < 0){
            int val = prefix2[index2];
            return val;
        }else if(index2 < 0){
            int val = prefix1[index1];
            return val;
        }

        if(s1[index1] == s2[index2]){
            return backtrack(s1, s2, index1 - 1, index2 - 1);
        }else{
            return min(backtrack(s1, s2, index1 - 1, index2) + s1[index1],
                       backtrack(s1, s2, index1, index2 - 1) + s2[index2]);
        }
    }
};
```

















# 713 Subarry Product Less Than K

<img src="701-800.assets/image-20210615090808917.png" alt="image-20210615090808917" style="zoom:50%;" />

```java
    public int numSubarrayProductLessThanK(int[] nums, int k) {
        int res = 0;

        int left = 0, right = 0;
        int product = 1;
        while(right < nums.length){
            while(right < nums.length){
                product *= nums[right];
                if(product >= k)
                    break;

                res += right - left + 1;
                right++;
            }

            if(right == nums.length)
                break;
            
            while(left < right && product >= k){
                product /= nums[left];
                left++;
            }

            if(product < k)
                res += right - left + 1;
            right++;
        }

        return res;
    }
```









# 716 Max Stack



<img src="701-800.assets/image-20210529210358497.png" alt="image-20210529210358497" style="zoom:50%;" />

```java
public class MaxStack {
    DoubleLinkedList dll;
    TreeMap<Integer, List<Node>> map;
    /** initialize your data structure here. */
    public MaxStack() {
        dll = new DoubleLinkedList();
        map = new TreeMap<>();
    }

    public void push(int x) {
        Node newNode = new Node(x);
        dll.add(newNode);
        map.putIfAbsent(x, new ArrayList<>());

        map.get(x).add(newNode);
    }

    public int pop() {
        int val = top();
        List<Node> nodes = map.get(val);
        nodes.remove(nodes.size() - 1);
        dll.delete();
        
        if(map.get(val).size() == 0)
            map.remove(val);
        
        return val;
    }

    public int top() {
        return dll.tail.prev.val;
    }

    public int peekMax() {
        return map.lastKey();
    }

    public int popMax() {
        int maxVal = peekMax();
        List<Node> nodes = map.get(maxVal);
        Node node = nodes.get(nodes.size() - 1);
        nodes.remove(nodes.size() - 1);
        if(nodes.size() == 0)
            map.remove(maxVal);
        
        dll.delete(node);

        return maxVal;
    }
}

class DoubleLinkedList{
    Node head;
    Node tail;

    public DoubleLinkedList(){
        head = new Node(0);
        tail = new Node(0);

        head.next = tail;
        tail.prev = head;
    }

    public void add(Node node){
        node.next = tail;
        node.prev = tail.prev;

        tail.prev.next = node;
        tail.prev = node;
    }

    public void delete(){
        tail.prev.prev.next = tail;
        tail.prev = tail.prev.prev;
    }
    
    public void delete(Node node){
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
}

class Node{
    public int val;
    public Node next;
    public Node prev;

    public Node(int val){
        this.val = val;
    }
}
```









# 717 1-bit and 2-bit Characters

<img src="701-800.assets/image-20210520112517783.png" alt="image-20210520112517783" style="zoom:50%;" />

```go
func isOneBitCharacter(bits []int) bool {
	index := 0

	for ;index < len(bits);{
		if bits[index] == 0{
			index++
		}else {
			if index + 2 == len(bits){
				return false
			}
			index += 2
		}
	}

	return true
}
```





# 718 Maximum Length of Repeated Subarray



```go
//使用 DP 优化
//时间复 O(N*M)
func findLength(nums1 []int, nums2 []int) int {
    res := 0
    dp := make([][]int, len(nums1))
    for i := len(nums1) - 1; i >= 0; i--{
        dp[i] = make([]int, len(nums2))
        for j := len(nums2) - 1; j >= 0; j--{
            if nums1[i] == nums2[j]{
                if i == len(nums1) - 1 || j == len(nums2) - 1{
                    dp[i][j] = 1
                }else{
                    dp[i][j] = 1 + dp[i + 1][j + 1]
                }

                if dp[i][j] > res{
                    res = dp[i][j]
                }
            }
        }
    }

    return res
}
```





<img src="701-800.assets/image-20210519141624947.png" alt="image-20210519141624947" style="zoom:50%;" />

```go
//超时
func findLength(nums1 []int, nums2 []int) int {
	res := 0
	for i := 0; i < len(nums1); i++{
		for j := 0; j < len(nums2); j++{
			for k := 0; i + k < len(nums1) && j + k < len(nums2);k++{
				if nums1[i + k] == nums2[j + k]{
					if res < k + 1{
						res = k + 1
					}
				}else{
					break
				}
			}
		}	
	}
	
	return res
}

```





# 720 Longest Word In Dictionary



<img src="701-800.assets/image-20210723220710873.png" alt="image-20210723220710873" style="zoom:50%;" />

```cpp
class Solution {
public:
    string longestWord(vector<string>& words) {
        if(words.size() == 1 && words[0].size() == 1)
            return words[0];

        sort(words.begin(), words.end());
        unordered_map<string, int> map;
        for(int i = 0; i < words.size(); i++){
            map.insert({words[i], i});
        }

        string res = "";
        vector<bool> dp(words.size(), false);
        for(int i = 0; i < words.size(); i++){
            if(words[i].size() == 1)
                dp[i] = true;
            string frac = words[i].substr(0, words[i].size() - 1);
            if(map.count(frac) != 0 && dp[map[frac]])
                dp[i] = true;

            if(dp[i]){
                if(res.size() < words[i].size())
                    res = words[i];
                else if(res.size() == words[i].size() && res > words[i])
                    res=  words[i];

            }
        }



        return res;
    }
};
```





# 721 Merge Account

<img src="701-800.assets/image-20210921141601344.png" alt="image-20210921141601344" style="zoom:50%;" />

```cpp
class WeightedUnionFind{
public:
    vector<int> id;
    vector<int> sz;
    
    WeightedUnionFind(int N): id(vector<int>(N, 0)), sz(vector<int>(N, 1)){
        for(int i = 0; i < N; i++)
            id[i] = i;
    }
    
    bool isConnected(int p, int q){
        return find(p) == find(q);
    }
    
    void uni(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);
        
        if(pRoot == qRoot)
            return;
        
        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }
    }
    

    int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        
        return p;
    }
};



/*
		典型并查集思路，因为看到了连通性问题
		
		
		思路分为三步走
		
		1. 对于 accounts 里面的每一个 string 我都要分配一个 id
			如果 发现碰到了之前的字符串， 那么我们就进行 connect / 连通操作
			
			
		2. 之后 重新遍历每一个字符串， 找到每个字符串的 parent 将他们 加入到 unordered——set 中
		
		3. 然后 加入 vector 进行sort
		最后返回结果
*/
class Solution {
public:
    vector<vector<string>> accountsMerge(vector<vector<string>>& accounts) {

        int size = accounts.size();
        WeightedUnionFind wuf(size + 1);
        unordered_map<string, int> map;
        
        //step1 : make the string that appear twice or more to find the common parent
        for(int i = 0; i < size; i++){
            auto& temp = accounts[i];
            
            for(int j = 1; j < temp.size(); j++){
                if(map.count(temp[j]) != 0){
                    wuf.uni(i, map[temp[j]]);
                }else{
                    map[temp[j]] = i;
                }
            }
        }
        
        //step2 : for all the same parent, we collect all the string
        unordered_map<int, unordered_set<string>> map2;
        for(int i = 0; i < size; i++){
            auto& temp = accounts[i];
            for(int j = 1; j < temp.size(); j++){
                int parentId = wuf.find(map[temp[j]]); // -> parent Id
                map2[parentId].insert(temp[j]);
            }
        }
        
        //step3: to collect data;
        vector<vector<string>> res;
        for(auto it = map2.begin(); it != map2.end(); ++it){
            auto set = it->second;
            vector<string> temp;
            for(const auto& str : set)
                temp.push_back(str);
          sort(temp.begin(), temp.end());
            temp.insert(temp.begin(), accounts[it->first][0]);
            res.push_back(temp);
        }
        
        return res;
    }
};

```









# 724 Find Pivot Index

<img src="701-800.assets/image-20211105104607151.png" alt="image-20211105104607151" style="zoom:50%;" />

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum = 0;
        for(int num : nums)
            sum += num;
        
        int prefixSum = 0;

        //i is the pivot index
        for(int i = 0; i < nums.size(); i++){
            int curLeft = prefixSum;
            int curRight = sum - prefixSum - nums[i];

            if(curLeft == curRight)
                return i;
            
            prefixSum += nums[i];
        }

        return -1;
    }
};
```







# 725 Split Linked List in Parts



```cpp
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        vector<ListNode*> res;
        if(head == nullptr){
            for(int i = 0; i < k; i++){
                res.push_back(nullptr);
            }
            return res;
        }
        ListNode* cur = head;
        int size = 0;
        while(cur != nullptr){
            size++;
            cur = cur->next;
        }

        ListNode* newHead = new ListNode(0);
        newHead->next = head;
        if(size < k){// one node a time
            for(int i = 0; i < k; i++){
                if(i >= size){
                    res.push_back(nullptr);
                    continue;
                }
                ListNode* temp = head->next;
                head->next = nullptr;
                res.push_back(head);
                head = temp;

            }
        }else{
            int numInEachSet = size / k;
            int extraNodes = size - numInEachSet * k;
//            cout << numInEachSet << " " << extraNodes << endl;
            for(int i = 0; i < k; i++){
                ListNode* temp;
                int count = numInEachSet - 1;
                ListNode* cur = head;
                while(count != 0){
                    cur = cur->next;
                    count--;
                }

                if(extraNodes != 0){
                    extraNodes--;
                    cur = cur->next;
                }

                temp = cur->next;
                cur->next = nullptr;
                res.push_back(head);
                head = temp;
            }
        }

        return res;
    }
};
```







# 726 Number of Atoms

<img src="701-800.assets/image-20211122145312229.png" alt="image-20211122145312229" style="zoom:50%;" />

```cpp
class Solution {
public:
    string countOfAtoms(string formula) {
        int size = formula.size();
        //the element and the count
        auto m = splitAndCount(formula);
        string res;
        for(auto it = m.begin(); it != m.end(); it++){
            if(it->first.size() == 0)
                continue;
            res += it->first;
            if(it->second != 1)
                res += to_string(it->second);
        }

        return res;
    }

    map<string, int> splitAndCount(string formula){
//        cout << formula << endl;
        int size = formula.size();
        map<string, int> m;
        if(size == 0)
            return m;
        int left = 0, right = 0;
        while(right < size){
            if(formula[right] == '('){
                int Parentheses = 1;
                int rightParenthese = right + 1;
                while(rightParenthese < size){
                    if(formula[rightParenthese] == '(')
                        Parentheses++;
                    else if(formula[rightParenthese] == ')')
                        Parentheses--;

                    rightParenthese++;
                    if(Parentheses == 0)
                        break;
                }

                auto subMap = splitAndCount(formula.substr(right + 1, rightParenthese - right - 2));
                int temp = rightParenthese;
                //num = 1;
                if(rightParenthese == size || !isdigit(formula[rightParenthese])){
                    addMap(m, subMap, 1);
                }else{
                    while(rightParenthese < size && isdigit(formula[rightParenthese])){
                        rightParenthese++;
                    }
                    int times = stoi(formula.substr(temp, rightParenthese));
                    addMap(m, subMap, times);
                }

                left = rightParenthese;
                right = rightParenthese;
                continue;
            }//end of parentheses

            right++;
            while(right < size && (islower(formula[right]))){
                right++;
            }

            string name = formula.substr(left, right - left);
            if(right == size || !isdigit(formula[right])){
                m[name]++;
                left = right;
            }else{
                left = right;
                while(left < size && isdigit(formula[left]))
                    left++;
                int repeatTimes = stoi(formula.substr(right, left - right));
                right = left;
                m[name] += repeatTimes;
            }
        }

        return m;
    }

    void addMap(map<string,int>& m1, map<string, int>& m2, int times){
        for(auto it = m2.begin(); it != m2.end(); it++){
            string cur = it->first;
            int val = it->second;
            m1[cur] += val * times;
        }
    }
};//"((N42)24(OB40Li30CHe3O48LiNN26)33 (C12Li48N30H13HBe31)21 (BHN30Li26BCBe47N40)15 (H5)16)14"

```











# 728 Self Dividing Numbers

<img src="701-800.assets/image-20211106214834468.png" alt="image-20211106214834468" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> selfDividingNumbers(int left, int right) {
        vector<int> res;
        for(int i = left; i <= right; i++){
            string str = to_string(i);
            bool notFound = false;
            for(char ch : str){
                int num = ch - '0';
                if(num == 0){
                    notFound = true;
                    break;
                }
                if((i % num) != 0){
                    notFound = true;
                    break;
                }
            }

            if(!notFound)
                res.push_back(i);
        }

        return res;
    }
};
```





# 729 My Calendat I



```cpp
//ref -> https://github.com/wisdompeak/LeetCode/blob/master/Heap/729.My-Calendar-I/729.My-Calendar-I.cpp
/*
		对这个题目可以这么理解
			给定一个 start, end
		[   ]
		s   e 
		
		if iterator->first > start, 那么只需要确保
			it-> second < end
			
		As a result, it->prev->first <= start
			那么只需要确保
			
				it->second > start
*/
class MyCalendar {
public:
    map<int, int> m;
    MyCalendar() {}
    
    bool book(int start, int end) {
        auto it = m.upper_bound(start);
        
        //find the first one that is bigger than start
        if(it != m.end()){
            if(it->first < end)
                return false;
        }
        
        if(it != m.begin()){
            auto it2 = prev(it, 1);
            if(it2->second > start)
                return false;
        }
        
        m[start] = end;
        return true;
    }
};

/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */
```







# 733 Flood Fill

![image-20210711123333563](701-800.assets/image-20210711123333563.png)

```cpp
struct pair_hash
{
    template <class T1, class T2>
    size_t operator () (pair<T1, T2> const &pair) const
    {
        size_t h1 = hash<T1>()(pair.first); //用默认的 hash 处理 pair 中的第一个数据 X1
        size_t h2 = hash<T2>()(pair.second);//用默认的 hash 处理 pair 中的第二个数据 X2
        return h1 ^ h2;
    }
};


class Solution {

public:
    vector<vector<int>> floodFill(vector<vector<int>>& image, int sr, int sc, int newColor) {
        queue<pair<int, int>> myQueue;
        unordered_set<pair<int, int>, pair_hash> set;
        int row = image.size();
        int col = image[0].size();
        auto isInRange = [&](int x, int y){return x >= 0 && y >= 0 && x < row && y < col;};

        vector<vector<int>> dir = {{1, 0}, {-1, 0}, {0, -1}, {0, 1}};
        myQueue.push({sr, sc});
        set.insert({sr, sc});
        int standard = image[sr][sc];

        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                auto coor = myQueue.front();
                set.insert({coor.first, coor.second});
                myQueue.pop();

                image[coor.first][coor.second] = newColor;

                for(int k = 0; k < 4; k++){
                    int newX = coor.first + dir[k][0];
                    int newY = coor.second + dir[k][1];

                    if(set.count({newX, newY}) == 0){
                        if(isInRange(newX, newY) && image[newX][newY] == standard){
                            myQueue.push({newX, newY});
                            set.insert({coor.first, coor.second});
                        }
                    }
                }
            }
        }

        return image;
    }
};
```











# 735 Asteroid Coollisioon



<img src="701-800.assets/image-20210605144956246.png" alt="image-20210605144956246" style="zoom:50%;" />

```java
    public int[] asteroidCollision(int[] asteroids) {
        List<Integer> ans = new ArrayList<>();
        
        for(int i = 0; i < asteroids.length; i++){
            if(ans.size() == 0 || ans.get(ans.size() - 1) < 0 || asteroids[i] > 0){
                ans.add(asteroids[i]);
            }else{
                int flag = 0;
                while(ans.size() > 0 && ans.get(ans.size() - 1) > 0){
                    if(ans.get(ans.size() - 1) == -1 * asteroids[i]){
                        ans.remove(ans.size() - 1);
                        flag = 1;
                        break;
                    }else if(ans.get(ans.size() - 1) > -1 * asteroids[i]){
                        flag = 1;
                        break;
                    }else{
                        ans.remove(ans.size() - 1);
                    }
                }

                if(flag == 0)
                    ans.add(asteroids[i]);
            }
        }
        
        int[] res = new int[ans.size()];
        for(int i = 0; i < ans.size(); i++)
            res[i] = ans.get(i);
        return res;
    }
```





<img src="701-800.assets/image-20210601092733940.png" alt="image-20210601092733940" style="zoom:50%;" />

```java
    public int[] asteroidCollision(int[] asteroids) {
        List<Integer> res= new ArrayList<>();

        int left = 0;
        for(int i = 0; i < asteroids.length; i++){
            if(res.size() == 0) {
                res.add(asteroids[i]);
            }else if(res.get(res.size() - 1) * asteroids[i] > 0 || (res.get(res.size() - 1) < 0 && asteroids[i] > 0)){
                res.add(asteroids[i]);

            }else{
                int attacker = asteroids[i];
                boolean settled = false;
                while(res.size() != 0 && res.get(res.size() - 1) > 0 && attacker < 0){
                    int defend = res.get(res.size() - 1);
                    if(Math.abs(defend) >= Math.abs(attacker)){
                        if(Math.abs(defend) == Math.abs(attacker))
                            res.remove(res.size() - 1);
                        settled = true;
                        break;
                    }else{
                         res.remove(res.size() - 1);
                    }
                }

                if(!settled)
                    res.add(attacker);

            }
        }

        int[] ans = new int[res.size()];
        for(int i = 0; i < res.size(); i++)
            ans[i] = res.get(i);
        return ans;
    }

```





# 738 Monotone Increasing Digits 典型贪心

<img src="701-800.assets/image-20211113193626473.png" alt="image-20211113193626473" style="zoom:50%;" />

```cpp
class Solution {
public:
    int monotoneIncreasingDigits(int n) {
        /*

        */
        string num = to_string(n);
        int max = 0;
        int maxId = 0;
        int size = num.size();
        vector<int> res(size, 0);
        for(int i = 0; i <= num.size() - 1; i++){
            int curDig = num[i] - '0';
            if(i == num.size() - 1){
                res[i] = curDig;
                break;
            }
            if(curDig > max){
                maxId = i;
                max = curDig;
            }

            if(num[i] > num[i + 1]){
                for(int j = maxId; j < num.size(); j++){
                    res[j] = maxId == j ? (num[maxId] - '0' - 1) : 9;
                }
                break;
            }else{
                res[i] = curDig;
            }
        }

        int ans = 0;
        for(int num : res){
            ans *= 10;
            ans += num;
        }

        return ans;
    }
};


```











# 739 Daily Temperatures

<img src="701-800.assets/image-20210804184449056.png" alt="image-20210804184449056" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        stack<int> monoStack;

        int size = temperatures.size();
        vector<int> ans(size, 0);
        for(int i = size - 1; i >= 0; i--){
             if(i == size - 1){
                ans[i] = 0;
                monoStack.push(i);
             }
            else{
                while(!monoStack.empty() && temperatures[i] >= temperatures[monoStack.top()])
                    monoStack.pop();

                if(monoStack.empty())
                    ans[i] = 0;
                else
                    ans[i] = monoStack.top() - i;

                monoStack.push(i);
            }
        }

        return ans;
    }
};
// 0  1  2   3  4  5  6  7
//[73,74,75,71,69,72,76,73]
```









# 740 Delete an Earn

<img src="701-800.assets/image-20211111150946015.png" alt="image-20211111150946015" style="zoom:50%;" />

```cpp
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        map<int, int> m;
        for(int num : nums)
            m[num]++;
        
        vector<int> vec;
        for(auto it = m.begin(); it != m.end(); it++){
            vec.push_back(it->first);
        }

        int size = vec.size();
        auto dp = vector<int>(size, 0);
        int res = 0;
        for(int i = 0; i < dp.size(); i++){
            if(i == 0){
                dp[i] = vec[i] * m[vec[i]];
            }else if(i == 1){
                if(vec[i] == vec[i - 1] + 1)
                    dp[i] = max(vec[i] * m[vec[i]], vec[i - 1] * m[vec[i - 1]]);
                else
                    dp[i] = vec[i] * m[vec[i]] + vec[i - 1] * m[vec[i - 1]];
            }else{
                if(vec[i] == vec[i - 1] + 1){
                    dp[i] = max(dp[i - 1], dp[i - 2] + vec[i] * m[vec[i]]);
                }else{
                    dp[i] = dp[i - 1]+ vec[i] * m[vec[i]];
                }
            }

                res = max(res, dp[i]);

        }

        return res;
    }
};
```







```cpp
这个方法超出时间限制					//   0，   size - 1
int dfs(vector<int>& vec, int left, int right){
        if(left  > right)
            return 0;
        Node* node = new Node(left, right);
        if(memo.count(node) != 0)
            return memo[node];

        int res = 0;
        //if we use that
        for(int i = left; i <= right; i++){
            int leftSideVal = 0;
            int rightSideVal = 0;
            if(i != 0 && vec[i - 1] + 1 == vec[i]){
                leftSideVal = dfs(vec, left, i - 2);
            }else{
                leftSideVal = dfs(vec, left, i  -1);
            }

            if(i != vec.size() - 1 && vec[i + 1] - 1 == vec[i]){
                rightSideVal = dfs(vec, i + 2, right);
            }else{
                rightSideVal = dfs(vec, i + 1, right);
            }

            res = max(res, m[vec[i]] * vec[i] + leftSideVal + rightSideVal);
        }

        memo[node] = res;
        return res;
    }
```





# 724 Closest Left in a Binary Tree

<img src="701-800.assets/image-20211118103109185.png" alt="image-20211118103109185" style="zoom:50%;" />

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public: 
    //              node,    the parent of the node
    unordered_map<TreeNode*, TreeNode*> map;
    TreeNode* targetNode = nullptr;
    int findClosestLeaf(TreeNode* root, int k) {
        map[root] = nullptr;
        preorder(root, k);

        queue<TreeNode*> myQueue;
        myQueue.push(targetNode);
        unordered_set<TreeNode*> set;
        set.insert(targetNode);

        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                TreeNode* curNode = myQueue.front();
                myQueue.pop();

                if(curNode->left == nullptr && curNode->right == nullptr) 
                    return curNode->val;
                
                if(curNode->left  != nullptr && set.count(curNode->left) == 0){
                    set.insert(curNode->left);
                    myQueue.push(curNode->left);
                }

                if(curNode->right != nullptr && set.count(curNode->right) == 0){
                    set.insert(curNode->right);
                    myQueue.push(curNode->right);
                }

                if(map[curNode] != nullptr && set.count(map[curNode]) == 0){
                    set.insert(map[curNode]);
                    myQueue.push(map[curNode]);
                }
            }
        }

        return -1;
    }

    void preorder(TreeNode* root, int k){
        if(root == nullptr)
            return;
        
        if(root->left != nullptr){
            map[root->left] = root;
        }

        if(root->right != nullptr){
            map[root->right] = root;
        }
        if(root->val == k){
            targetNode = root;
        }

        preorder(root->left , k);
        preorder(root->right, k);
    }
};
```









# 744 Find Smallest Letter Greater Than target

<img src="701-800.assets/image-20211123193913079.png" alt="image-20211123193913079" style="zoom:50%;" />



```cpp
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int size = letters.size();
        int left = 0, right = size  -1;
        int ans = -1;
        while(left <= right){
            int mid = (left + right) / 2;
            if(letters[mid] > target){
                ans = mid;
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }

        return ans == -1 ? letters[0] : letters[ans];
    }
};
```









# 747 Largest Number At Least Twice of Others

<img src="701-800.assets/image-20210620161738922.png" alt="image-20210620161738922" style="zoom:50%;" />

```java
class Solution {
    public int dominantIndex(int[] nums) {
        int max = nums[0];
        int index = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] > max){
                max = nums[i];
                index = i;
            }
        }

        for(int i = 0; i < nums.length; i++){
            if(nums[i] != max){
                if(nums[i] * 2 > max)
                    return -1;
            }
        }

        return index;
    }
}
```





# 748 Shortest Completing Word

<img src="701-800.assets/image-20210820194711982.png" alt="image-20210820194711982" style="zoom:50%;" />

```cpp
class Solution {
public:
    string shortestCompletingWord(string licensePlate, vector<string>& words) {
        string res = "";
        auto alpha = vector<int>(26, 0);
        for(char ch : licensePlate){
            if(ch >= 'a' && ch <= 'z')
                alpha[ch - 'a']++;
            else if(ch >= 'A' && ch <= 'Z')
                alpha[ch - 'A']++;
        }
//        cout << alpha['s' - 'a'] << endl;

        for(string& str : words){
            vector<int> strAlpha = vector<int>(26, 0);
            for(char ch : str)
                strAlpha[ch - 'a']++;
            
            bool found = true;
            for(int i = 0; i < 26; i++){
                if(strAlpha[i] < alpha[i]){
                    found = false;
                    break;
                }
            }

            if(found && (res == "" || res.size() > str.size()))
                res = str;
        }

        return res;
    }
};
```











# 754 Reach a Number



<img src="701-800.assets/image-20211112163421705.png" alt="image-20211112163421705" style="zoom:50%;" />



```cpp
/*
		脑经急转弯
		相当于给数字加上正负号
		
		1,2,3,4......i
		s = (1 + i) * i / 2;
		正数和为 p
		负数绝对值和为 n
		p + n = s
		p - n = target
		
		s - target = 2n
		说明
		T = (1 + i) * i / 2 - target = 2n
		
		1. T 必须是偶数
		2. >= 00
		
		因此就是找到第一个数字， 符合这个要求
*/
class Solution {
public:
    int reachNumber(int target) {
        target = abs(target);

        long i = 1;
        long ans = INT_MAX;

        while(true){
            long tmp = (i + 1) * i / 2 - target;
            if(tmp >= 0 && tmp % 2 == 0)
                return i;
            i++;
        }

    }
};
```





# 758 Bold Words In Strings

![image-20211116115939809](701-800.assets/image-20211116115939809.png)

```cpp
class Solution {
public:
    string boldWords(vector<string>& words, string s) {
        vector<pair<int, int>> vec;
        int pos = 0;
        for(string& word : words){
            pos = s.find(word, pos);
            if(pos == string::npos){
                pos = 0;
                continue;
            }
            while(true){
                vec.push_back({pos, pos + word.size()});
                pos++;
                pos = s.find(word, pos);
                if(pos == string::npos)
                    break;
            }
            pos = 0;
        }

//        cout << 1 << endl;
        sort(vec.begin(), vec.end(), [&](auto& p1, auto& p2){
            return p1.first < p2.first;
        });
//        cout << 2 << endl;
        if(vec.size() == 0)
            return s;

        int left = 0, right = 0;
        int leftBound = vec[left].first;
        int rightBound = vec[left].second;
        vector<pair<int, int>> res;
  //      cout << 4 << endl;
        while(right < vec.size()){
            while(right < vec.size() && vec[right].first <= rightBound){
                rightBound = max(rightBound, vec[right].second);
                right++;
            }

            res.push_back({leftBound, rightBound});
            if(right == vec.size())
                break;
            left = right;
            leftBound  = vec[right].first;
            rightBound = vec[right].second;
        }
//        cout << 3 << endl;


        string ans = "";
        int index = 0;
        left = 1;
        // cout << res.size() << endl;
        // cout << res[0].first << " " << res[0].second << endl;
        for(int i = 0; i < s.size(); i++){
            if(index == res.size()){
                ans.push_back(s[i]);
            }else if(i == res[index].first){
                ans += "<b>";
                ans.push_back(s[i]);
            }else if(i == res[index].second){
                ans += "</b>";
                ans.push_back(s[i]);
                index++;
            }else {
                ans.push_back(s[i]);
            }
        }

        if(index != res.size() && res[index].second == s.size()){
            ans += "</b>";
        }

        return ans;
    }
};
```



# 760 Find Anagram Mappings



<img src="701-800.assets/image-20211115220301629.png" alt="image-20211115220301629" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> anagramMappings(vector<int>& nums1, vector<int>& nums2) {
        unordered_map<int, vector<int>> map;

        for(int i = 0; i < nums2.size(); i++){
            map[nums2[i]].push_back(i);
        }

        vector<int> res;
        for(int i = 0; i < nums1.size(); i++){
            int target = nums1[i];
            int index = map[target][map[target].size() - 1];
            (map[target]).pop_back();

            res.push_back(index);
        }

        return res;
    }
};
```





# 762 Prime Number of Set Bits in Binary Represention

<img src="701-800.assets/image-20211117194834614.png" alt="image-20211117194834614" style="zoom:50%;" />

```c
class Solution {
public:
    int countPrimeSetBits(int left, int right) {
        unordered_set<int> prime = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31};
        int res = 0;
        for(int i = left; i <= right; i++){
            int num = getBinary(i);
            if(prime.count(num) != 0)
                res++;
        }

        return res;
    }

    int getBinary(int i){
        int res = 0;
        while(i != 0){
            res += (i & 1);
            i >>= 1;
        }

        return res;
    }
};
```











# 775 Global and Local Inversion

<img src="701-800.assets/image-20210703080936512.png" alt="image-20210703080936512" style="zoom:50%;" />



```cpp
class Solution {
public:
    bool isIdealPermutation(vector<int>& nums) {
        int currentMax = nums[0];
        
        for(int i = 0; i < nums.size(); i++){
            currentMax = currentMax > nums[i] ? currentMax : nums[i];

            if(i + 2 < nums.size()){
                if(nums[i + 2] < currentMax)
                    return false;
            }
        }

        return true;
    }
};
```









```cpp
class Solution {
public:
    long globalInversion = 0;
    vector<int> aux;
    bool isIdealPermutation(vector<int>& nums) {
        long localInversion = 0;
        int n = nums.size();
        aux = vector<int>(n);

        for(int i = 0; i < n - 1; i++){
            if(nums[i] > nums[i + 1])
                localInversion++;
        }

        mergeSort(nums, 0, n - 1);

        return globalInversion == localInversion;
    }

    void mergeSort(vector<int>& nums, int left, int right){
        if(left == right)
            return;

        int mid = (left + right) / 2;
        mergeSort(nums, left, mid);
        mergeSort(nums, mid + 1, right);

        int index1 = left;
        int index2 = mid + 1;

        for(int i = left; i <= right; i++)
            aux[i] = nums[i];

        int index = left;
        while(index1 <= mid || index2 <= right){
            if(index1 > mid){
                nums[index++] = aux[index2++];
            }else if(index2 > right){
                nums[index++] = aux[index1++];
            }else if(aux[index1] <= aux[index2]){
                nums[index++] = aux[index1++];
            }else{
                globalInversion += mid - index1 + 1;
                nums[index++] = aux[index2++];
            }
        }

    }
};
```









# 763 Partition Labels

<img src="701-800.assets/image-20210508144006309.png" alt="image-20210508144006309" style="zoom:50%;" />

<img src="701-800.assets/image-20210508151233683.png" alt="image-20210508151233683" style="zoom:50%;" />

```java
    public List<Integer> partitionLabels(String S) {
        List<Integer> res = new ArrayList<>();
        int len = S.length();

        int[] alpha = new int[26];
        int[] record = new int[S.length()];
        Arrays.fill(alpha, -1);

        for(int i = len- 1; i >= 0; i--){
            int pos = S.charAt(i) - 'a';
            if(alpha[pos] != -1){
                record[i] = alpha[pos];
            }else{
                record[i] = -1;
            }

            alpha[pos] = i;
        }


        int left = 0, right = 0;
        while(right < len){
            int index = left;
            while(index < len){
                char ch = S.charAt(right);
                right = Math.max(record[index], right);

                if(index == right)
                    break;

                index++;
            }

            res.add(right - left + 1);

            right++;
            left = right ;
        }

        return res;
    }
```





# 767 Reorganize String



```cpp
//358 变种
class Solution {
public:
    string reorganizeString(string s) {
        int size = s.size();
        vector<int> alpha(26, 0);
        for(char ch : s)
            alpha[ch - 'a']++;

        auto cmp = [&](pair<int, int>& p1, pair<int, int>& p2){return p1.second == p2.second ? p1.first > p2.first : p1.second < p2.second;};
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);
        string res = "";
        for(int i = 0; i < 26; i++){
            if(alpha[i] != 0)
                pq.push({i, alpha[i]});
        }

        deque<char> myQueue;
        while(!pq.empty()){
            pair<int, int> curPair = pq.top(); pq.pop();
            char ch = (char)(curPair.first + 'a');
            alpha[ch - 'a']--;
            myQueue.push_back(ch);
            res += string(1, ch);

            if(myQueue.size() == 2){
                char curChar = myQueue.front(); myQueue.pop_front();
                if(alpha[curChar - 'a'] != 0){
                    pq.push({curChar - 'a', alpha[curChar - 'a']});
                }
            }
        }

        return res.size() == s.size() ? res : "";
    }
};
```







# 771 Jewels and Stones

<img src="701-800.assets/image-20210708084125865.png" alt="image-20210708084125865" style="zoom:50%;" />

```cpp
class Solution {
public:
    int numJewelsInStones(string jewels, string stones) {
        vector<int> jew(256, 0);
        for(char ch : jewels){
            jew[ch]++;
        }

        int count = 0;
        for(char ch : stones){
            if(jew[ch] != 0)
                count++;
        }

        return count;
    }
};
```



# 772 Basic Calcutor

<img src="701-800.assets/image-20210801165018469.png" alt="image-20210801165018469" style="zoom:50%;" />



```cpp
/*
	RPE规则：
		1. 碰到 ( 直接入 stack
		2 碰到 数字 直接进入 vector
		3 碰到 ) 就一直pop 直到 (
		4 碰到 ops 优先级小于自己的，一直 push
			碰到 大于等于的，直接 pop给 vector
*/
class Solution {
public:
    int calculate(string s) {
        vector<string> vec = getRPN(s);
        int res = evl(vec);

        return res;
    }

    vector<string> getRPN(string& s){
        vector<string> res;
        stack<string> myStack;
        int num = -1;

        for(int i = 0; i < s.size(); i++){
            if(s[i] == ' ')
                continue;

            if(s[i] >= '0' && s[i] <= '9'){
                if(num == -1)
                    num = s[i] - '0';
                else{
                    num *= 10;
                    num += s[i] - '0';
                }
            }else{
                if(num != -1){
                    res.push_back(to_string(num));
                    num = -1;
                }

                if(s[i] == '(')
                    myStack.push("(");
                else if(s[i] == ')'){
                    while(!myStack.empty()){
                        if(myStack.top() == "("){
                            myStack.pop();
                            break;
                        }

                        res.push_back(myStack.top());       myStack.pop();
                    }
                }else{
                    while(!myStack.empty()){
                        if(myStack.top() == "("){
                            break;
                        }

                        if(getPriority(myStack.top()[0]) <= getPriority(s[i])){
                            res.push_back(myStack.top());       myStack.pop();
                        }else{
                            break;
                        }
                    }

                    myStack.push(string(1, s[i]));
                }

            }
        }

        if(num != -1)
            myStack.push(to_string(num));
        while(!myStack.empty()){
            res.push_back(myStack.top()); myStack.pop();
        }

        return res;
    }



    int getPriority(char ch){
        if(ch == '+' || ch == '-')
            return 1;
        else
            return 0;
    }

    int evl(vector<string>& vec) {
        stack<int> myStack;
        int res = 0;
        for(string& str : vec){
            if(str[0] >= '0' && str[0] <= '9'){ //number
                myStack.push(parseInt(str));
            }else{  //ops
                int op1 = myStack.top();    myStack.pop();
                int op2 = myStack.top();    myStack.pop();

                int temp = 0;
                if(str == "+")
                    temp =  op1 + op2;
                else if(str == "-")
                    temp =  op2 - op1;
                else if(str == "*")
                    temp =  op1 * op2;
                else
                    temp =  op2 / op1;

                myStack.push(temp);
            }
        }

        return myStack.top();
    }

    int parseInt(string s){
        int res = 0;
        for(int i = 0; i < s.size(); i++){
            if(res > INT_MAX / 10 || (res == INT_MAX / 10 && s[i] - '0' > INT_MAX % 10))
                return INT_MAX;

            res *= 10;
            res += s[i] - '0';
        }

        return res;
    }
};
```





# 773 Sliding Puzzle

<img src="701-800.assets/image-20210731110534662.png" alt="image-20210731110534662" style="zoom:50%;" />

<img src="701-800.assets/image-20210731144257849.png" alt="image-20210731144257849" style="zoom:50%;" />

```cpp

class Solution {
public:
    int row, col;
    vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    const string FINAL = "123450";
    int slidingPuzzle(vector<vector<int>>& board) {
        row = board.size();
        col = board[0].size();

        auto isInRange = [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};

        unordered_set<string> set;
        string start = getState(board);
        if(start == FINAL)
            return 0;

        set.insert(start);

        queue<string> myQueue;
        myQueue.push(start);

        int round = 0;
        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                string curBoard = myQueue.front(); myQueue.pop();
                //cout <<" 当前" << curBoard << endl;
                int pos = curBoard.find('0');
                int posX = pos / 3;
                int posY = pos % 3;

                for(int k = 0; k < 4; k++){
                    int newX = posX + dir[k][0];
                    int newY = posY + dir[k][1];
                    int newPos = newX * col + newY;

                    string nextState = curBoard;

                    if(isInRange(newX, newY)){
                        swap(nextState[pos], nextState[newPos]);

                        if(nextState == FINAL)
                            return round + 1;
                        if(set.count(nextState) == 0){
                            myQueue.push(nextState);
                            set.insert(nextState);
                        }

                    }
                }

            }

            round++;
//            cout << "---" << endl;
        }

        return -1;
    }

    string getState(vector<vector<int>>& board){
        string res;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                res += to_string(board[i][j]);
            }
        }

        return res;
    }
};
```





```cpp
class Solution {
public:
    int row, col;
    vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    const string FINAL = "123@450";
    int slidingPuzzle(vector<vector<int>>& board) {
        row = board.size();
        col = board[0].size();

        auto isInRange = [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};

        unordered_set<string> set;
        string start = getState(board);
        if(start == FINAL)
            return 0;

        set.insert(start);

        queue<string> myQueue;
        myQueue.push(start);

        int round = 0;
        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                string curBoard = myQueue.front(); myQueue.pop();
                vector<vector<int>> newBord = getBoard(curBoard);

                pair<int, int> zeroPos = getZero(newBord);
                for(int k = 0; k < 4; k++){
                    int newX = zeroPos.first + dir[k][0];
                    int newY = zeroPos.second + dir[k][1];

                    if(isInRange(newX, newY)){
                        newBord[zeroPos.first][zeroPos.second] = newBord[newX][newY];
                        newBord[newX][newY] = 0;

                        string nextState = getState(newBord);
                        if(nextState == FINAL)
                            return round + 1;
                        if(set.count(nextState) == 0){
                            myQueue.push(nextState);
                            set.insert(nextState);
                        }

                        newBord[newX][newY] =  newBord[zeroPos.first][zeroPos.second];
                        newBord[zeroPos.first][zeroPos.second] = 0;
                    }
                }

            }

            round++;
        }

        return -1;
    }

    pair<int, int> getZero(vector<vector<int>>& board){
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(board[i][j] == 0)
                    return {i, j};
            }
        }

        return {-1, -1};
    }

    vector<vector<int>> getBoard(string& curBoard){
        vector<vector<int>> res(row, vector<int>(col, 0));
        for(int i = 0; i < 3; i++){
            res[0][i] = curBoard[i] - '0';
        }


        for(int i = 4; i < 7; i++){
            res[1][i - 4] = curBoard[i] - '0';
        }

        return res;
    }

    string getState(vector<vector<int>>& board){
        string res = "";
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                res += to_string(board[i][j]);
            }

            if(i != row - 1)
                res += "@";
        }

        return res;
    }
};

```







# 777 Swap Adjacent in LR Strign



```java
//39 / 94 超时
public class Solution {
    /**
     * The Algorithm is kind of like backtrack
     * where I try for every possible way
     * then to add into our result set
     * @param start
     * @param end
     * @return
     */
    
    int counter = 0;
    public boolean canTransform(String start, String end) {
        backtrack(start.toCharArray(), end.toCharArray());
        return counter != 0;
    }

    private void backtrack(char[] start, char[] end) {
        if(counter >= 2){
            return;
        }
        
        if(Arrays.equals(start, end)){
            counter++;
            return; 
        }
        
        if(noExchange(start)){
            return;
        }
        
        for(int i = 0; i < start.length - 1; i++){
            if(start[i] == 'X' && start[i + 1] == 'L'){
                start[i] = 'L';
                start[i + 1] = 'X';
                
                backtrack(start, end);
                
                start[i] = 'X';
                start[i + 1] = 'L';
            }
                
            if(counter >= 2)
                return;
            
            if(start[i] == 'R' && start[i + 1] == 'X'){
                start[i] = 'X';
                start[i + 1] = 'R';
                
                backtrack(start, end);;
                
                start[i] = 'R';
                start[i + 1] = 'X';
            }
        }
    }

    private boolean noExchange(char[] starts) {
        for(int i = 0; i < starts.length - 1; i++){
            if(starts[i] == 'X' && starts[i + 1] == 'L')
                return false;
            if(starts[i] == 'R' && starts[i + 1] == 'X')
                return false;
        }
        
        return true;
    }
}
```



```java
//BFS 超时 56 / 94
public boolean canTransform(String start, String end) {
        if(start.equals(end))
            return true;

        Set<String> visited = new HashSet<>();
        Deque<String> queue = new ArrayDeque<>();
        queue.add(start);
        visited.add(start);

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i =0; i < size; i++){
                String cur = queue.removeFirst();

                if(cur.equals(end))
                    return true;

                char[] curs = cur.toCharArray();
                for(int k = 0; k < curs.length - 1; k++){
                    if(curs[k] == 'X' && curs[k + 1] == 'L'){
                        curs[k] = 'L';
                        curs[k + 1] = 'X';

                        String str = toStr(curs);
                        if(!visited.contains(str)){
                            queue.addLast(str);
                            visited.add(str);
                        }

                        curs[k] = 'X';
                        curs[k + 1] = 'L';
                    }

                    if(curs[k] == 'R' && curs[k + 1] == 'X'){
                        curs[k] = 'X';
                        curs[k + 1] = 'R';

                        String str = toStr(curs);
                        if(!visited.contains(str)){
                            queue.addLast(str);
                            visited.add(str);
                        }

                        curs[k] = 'R';
                        curs[k + 1] = 'X';
                    }
                }
            }
        }

        return false;
    }

    private String toStr(char[] curs) {
        StringBuilder sb = new StringBuilder();
        for(char ch : curs)
            sb.append(ch);
        
        return sb.toString();
    }
```





```java
    public boolean canTransform(String start, String end) {
        StringBuilder sb1 = new StringBuilder();
        StringBuilder sb2 = new StringBuilder();
        int len1 = start.length();
        int len2 = end.length();

        for(int i = 0; i < start.length(); i++){
            char ch = start.charAt(i);
            if(ch != 'X')
                sb1.append(ch);
        }

        for(int i = 0; i < end.length(); i++){
            char ch = end.charAt(i);
            if(ch != 'X')
                sb2.append(ch);
        }

        if(!sb1.toString().equals(sb2.toString()))
            return false;

        int up = 0, down = 0;


        while(up < len1 && down < len2){
            while(up < len1 && start.charAt(up) != 'L')
                up++;
            while(down < len2 && end.charAt(down) != 'L')
                down++;

            if(up == len1 || down == len2){
                if(noSymbol(start, up + 1, 'L', true) && noSymbol(end, down + 1, 'L', true))
                    break;
                else
                    return false;
            }

            if(up < down)
                return false;
            up++;
            down++;
        }

        up = len1 - 1;
        down = len2 -1;

        while(up >= 0 && down >= 0){
            while(up >= 0 && start.charAt(up) != 'R')
                up--;
            while(down >= 0 && end.charAt(down) != 'R')
                down--;

            if(up == 0 || down == 0){
                if(noSymbol(start, up - 1, 'R', false) && noSymbol(end, down - 1, 'R', false))
                    break;
                else
                    return false;
            }

            if(up > down)
                return false;
            up--;
            down--;
        }

        return true;
    }

    private boolean noSymbol(String str, int index, char ch, boolean l2r) {
        if(l2r){
            for(int i = index; i < str.length(); i++){
                if(str.charAt(i) == ch)
                    return false;
            }

            return true;
        }else{
            for(int i = index; i >= 0; i--){
                if(str.charAt(i) == ch)
                    return false;
            }

            return true;
        }

    }

```





# 780 Reaching Points



```java
class Solution {
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        while(sx < tx && sy < ty){
            if(tx < ty)
                ty %= tx;
            else
                tx %= ty;
        }

        if(sx == tx && sy <= ty)
            return (ty - sy) % sx == 0;
        else
            return sy == ty && sx <= tx && (tx - sx) % sy == 0;
    }
}
```



```java
    public boolean reachingPoints(int sx, int sy, int tx, int ty) {
        Deque<Point> queue = new ArrayDeque<>();
        Point root = new Point(sx, sy);
        Point end  = new Point(tx, ty);
        Set<Point> visited = new HashSet<>();
        queue.addLast(root);


        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                Point cur = queue.removeFirst();
                visited.add(cur);
                System.out.println(cur);
                if(cur.equals(end))
                    return true;

                if(cur.x + cur.y > tx + ty || cur.x + cur.y < 0)
                    continue;

                Point left = new Point(cur.x + cur.y, cur.y);
                Point right = new Point(cur.x, cur.x + cur.y);

                if(!visited.contains(left)){
                    queue.addLast(left);
                }

                if(!visited.contains(right)){
                    queue.addLast(right);
                }
            }
        }

        return false;
    }

```





# 781 Rabbits in Forest

<img src="701-800.assets/image-20211120090449161.png" alt="image-20211120090449161" style="zoom:50%;" />

```cpp
class Solution {
public:
    int numRabbits(vector<int>& answers) {
        sort(answers.begin(), answers.end());

        int left = 0, right = 0;
        int size = answers.size();
        int res = 0;
        while(right < size){
            while(right < size && answers[left] == answers[right]){
                right++;
            }

            int num = right - left;
            int val = answers[left];
            int set = num / (val + 1);
            int remains = num % (val + 1);
             res += set * (val + 1) +  (remains  == 0 ? 0 : (val + 1));
            left = right;
            /*
                let's say num =9, val = 3
                we have 3 values that have 3

                how many rabbits in one set?
            */
        }

        return res;
    }
};

```





# 783 Minimum Distance Between BST Nodes

<img src="701-800.assets/image-20210212173900740.png" alt="image-20210212173900740" style="zoom:50%;" />

```java
    TreeNode pre = null;
    long res = Integer.MAX_VALUE;
    public int minDiffInBST(TreeNode root) {
        inorder(root);

        return (int)res;
    }

    public void inorder(TreeNode root){
        if(root == null)    
            return;
        
        inorder(root.left);

        if(pre != null)
            res = Math.min(res, Math.abs((long)(root.val) - (long)(pre.val)));
        
        pre = root;

        inorder(root.right);
    }
```



# 783 Minimum Distance Between BST Nodes

<img src="../git_leetcode/701-800.assets/image-20210212173900740.png" alt="image-20210212173900740" style="zoom:50%;" />

```java
    TreeNode pre = null;
    long res = Integer.MAX_VALUE;
    public int minDiffInBST(TreeNode root) {
        inorder(root);

        return (int)res;
    }

    public void inorder(TreeNode root){
        if(root == null)    
            return;
        
        inorder(root.left);

        if(pre != null)
            res = Math.min(res, Math.abs((long)(root.val) - (long)(pre.val)));
        
        pre = root;

        inorder(root.right);
    }
```







# 784 Letter Case Permutation

<img src="701-800.assets/image-20211114115727184.png" alt="image-20211114115727184" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<string> res;
    vector<string> letterCasePermutation(string s) {
        backtrack(s, 0, "");
        return res;
    }

    void backtrack(string& s, int index, string path){
        if(index == s.size()){
            res.push_back(path);
            return;
        }

        if(s[index] >= '0' && s[index] <= '9'){
            path.push_back(s[index]);
            backtrack(s, index + 1, path);
        }else{
            if(s[index] >= 'a' && s[index] <= 'z'){
                string temp = path;
                temp.push_back((char)(s[index] - 32));
                path.push_back((char)(s[index]));
                backtrack(s, index + 1, temp);
                backtrack(s, index + 1, path);
            }else{
                string temp = path;
                temp.push_back((char)(s[index] + 32));
                path.push_back((char)s[index]);
                backtrack(s, index + 1, temp);
                backtrack(s, index + 1, path);
            }
        }
    }
};


```







# 787 Cheapest Flights Within K Stops



```java
//超时， 通过 27 / 49 个案例
class Solution {
   Map<Integer, List<String>> map = new HashMap<>();
    int res = Integer.MAX_VALUE;
    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {
        for(int[] flight : flights){
            map.putIfAbsent(flight[0], new ArrayList<>());
            map.get(flight[0]).add(flight[1] +  "@" +flight[2]);
        }

        dfs(dst, k, src, 0, 0, new boolean[n]);

        return res == Integer.MAX_VALUE ? -1 : res;
    }

    private void dfs(int dst, int k, int cur, int step, int price, boolean[] visited) {
        if(cur == dst && k + 1 >= step){
            res = Math.min(res, price);
            return;
        }

        visited[cur] = true;
        
        List<String> strings = map.get(cur);
        if(strings == null || strings.size() == 0){
            return;
        }

        for(String str : strings){
            String[] split = str.split("@");
            if(visited[Integer.parseInt(split[0])])
                continue;
            
            visited[Integer.parseInt(split[0])] = true;
            dfs(dst, k, Integer.parseInt(split[0]), step + 1, price + Integer.parseInt(split[1]), visited);
            visited[Integer.parseInt(split[0])] = false;
        }

    }
}
```







# 788 Rotated Digits

<img src="701-800.assets/image-20211110141807213.png" alt="image-20211110141807213" style="zoom:50%;" />

```cpp
class Solution {
public:
    int rotatedDigits(int n) {
        int counter = 0;
        for(int i = 1; i <= n; i++){
            string num = to_string(i);
            int reverseNum = 0;
            int canAdd = 1;
            for(char ch : num){
                reverseNum *= 10;

                int digit = ch - '0';
                if(ch == '0' || ch == '1' || ch == '8'){
                }else if(ch == '2' || ch == '5'){
                    digit = ch == '2' ? 5 : 2;
                }else if(ch == '6' || ch == '9'){
                    digit = ch == '6' ? 9 : 6;
                }else{
                    canAdd = 0;
                    break;
                }
               
                reverseNum += digit;
            }

            if(canAdd == 1 && reverseNum != i){
//                cout << i << " " << reverseNum << endl;
                counter++;
            }
        }

        return counter;
    }
};
```







# 791 Custom Sort String



```java
    public String customSortString(String order, String str) {
        Map<Character, Integer> map = new HashMap<>();

        for(char ch : str.toCharArray())
            map.put(ch, map.getOrDefault(ch, 0) + 1);
        
        StringBuilder res = new StringBuilder();
        for(int i =0; i < order.length(); i++){
            char ch = order.charAt(i);
            if(!map.containsKey(ch))
                continue;
            
            for(int j = 0; j < map.get(ch); j++)
                res.append(ch);
            
            map.remove(ch);
        }

        for(char ch : map.keySet()){
            for(int i = 0; i < map.get(ch); i++)
                res.append(ch);
        }

        return res.toString();
    }
```





# 792 Number of Matching Subsequence

<img src="701-800.assets/image-20210926212204456.png" alt="image-20210926212204456" style="zoom:50%;" />

```cpp
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
        int size = words.size();
        int count = 0;
        unordered_set<string> set;
        unordered_set<string> set1;
        for(string& word : words){
            if(set.count(word) != 0){
                count++;
                continue;
            }
            
            if(set1.count(word) != 0){
                continue;
            }
            
            if(isSubsequence(s, word)){
                set.insert(word);
                count++;
            }else{
                set1.insert(word);
            }
        }
        
        return count;
    }
    
    bool isSubsequence(string& s1, string& s2){
        int size1 = s1.size();
        int size2 = s2.size();
        
        int index1 = 0;
        int index2 = 0;
        
        while(index1 < size1 && index2 < size2){
            if(s1[index1] == s2[index2]){
                index1++;
                index2++;
            }else{
                index1++;
            }
        }
        
        return index2 == size2;
    }
};
```





# 795 Number of Subarrays With Bounder Maximum

<img src="701-800.assets/image-20211108205918728.png" alt="image-20211108205918728" style="zoom:50%;" />

```cpp
class Solution {
public:
    int numSubarrayBoundedMax(vector<int>& nums, int left, int right) {
        nums.insert(nums.begin(), right + 1);
        nums.push_back(right + 1);

        vector<int> split;
        for(int i = 0; i < nums.size(); i++){
            if(nums[i] > right)
                split.push_back(i);
        }

        if(split.size() == 2){
            long size = nums.size() - 2;
            return (1 + size) * size / 2;
        }
        long res = 0;
        for(int i = 0; i < split.size() - 1; i++){
            long len = split[i + 1] - split[i] - 1;
            res += (1 + len) * len / 2;

            int begin = split[i] + 1;
            int end;
            while(begin < split[i + 1] && end < split[i + 1]){
                while(begin < split[i + 1] && nums[begin] >= left && nums[begin] <= right)
                    begin++;
                
                end = begin;
                while(end < split[i + 1] && (nums[end] < left || nums[end] > right)){
                    end++;
                }
                long len2 = end - begin;
                res -= (1 + len2) * len2 / 2;

                end++;
                begin = end;
            }
        }

        return res;
    }
};
```





# 796 Rotate String

<img src="701-800.assets/image-20211119071848625.png" alt="image-20211119071848625" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool rotateString(string s, string goal) {
        int len = s.size();
        int len2 = goal.size();

        if(len != len2)
            return false;
        
        s += s;
        if(s.find(goal) != string::npos)
            return true;
        return false;
    }
};
```



# 797 All Paths From Source to Target



<img src="701-800.assets/image-20210512091732388.png" alt="image-20210512091732388" style="zoom:50%;" />

```java
//典型 DFS
	List<List<Integer>> res = new ArrayList<>();
    int n;
    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {
        n = graph.length;
        List<Set<Integer>> bags = new ArrayList<>();
        for(int i = 0; i <= n - 1; i++)
            bags.add(new HashSet<>());

        for(int i = 0; i < graph.length; i++){
            int[] edges = graph[i];
            for(int num : edges)
                bags.get(i).add(num);
        }
        List<Integer> path = new ArrayList<>();
        path.add(0);
        dfs(bags, new HashSet<>(), path, 0);
        return res;
    }

    private void dfs(List<Set<Integer>> bags, HashSet<Integer> visited, List<Integer> path, int bagNum) {
        if(bagNum == n - 1){
            res.add(new ArrayList<>(path));
        }

        Set<Integer> bag = bags.get(bagNum);

        for(Integer nextBag : bag){
            if(visited.contains(nextBag))
                continue;

            visited.add(nextBag);
            path.add(nextBag);
            dfs(bags, visited, path, nextBag);
            visited.remove(nextBag);
            path.remove(path.size() - 1);
        }

    }
```







# 799 Champange Tower

<img src="701-800.assets/image-20211124191904828.png" alt="image-20211124191904828" style="zoom:67%;" />

```cpp
class Solution {
public:
    double champagneTower(int poured, int query_row, int query_glass) {
        if(poured == 0) {
            return 0;
        }else if(poured == 1) {
            if (query_row == 0 && query_glass == 0)
                return 1;
            return 0;
        }else if(query_row == 0){
            return 1;
        }

        vector<double> prev = {(poured) * 1.0};
        vector<double> cur;
        for(int i = 1; i <= query_row ; i++){
            // for(double num : prev)
            //     cout << num << " ";
            // cout << endl;
            int size = prev.size();
            cur = vector<double>(size + 1);
            for(int j = 0; j < size; j++){
                cur[j]     += (prev[j] - 1 <= 0) ? 0 : ((prev[j] - 1) / 2.0);
                cur[j + 1] += (prev[j] - 1 <= 0) ? 0 : ((prev[j] - 1) / 2.0);
            }

            prev = cur;
            cur.clear();
        }


        return prev[query_glass] >= 1 ? 1 : prev[query_glass];
    }
};

```









