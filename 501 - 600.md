# 501 - 600







# 501Find Mode in Binary Search Tree

<img src="501 - 600.assets/image-20210208083505544.png" alt="image-20210208083505544" style="zoom:50%;" />

```java
/*
		简单易懂的暴力方法
*/    
HashMap<Integer, Integer> map = new HashMap<>();
    int maxFreq = 0;
    public int[] findMode(TreeNode root) {
        inorder(root);
        List<Integer> list = new ArrayList<>();
        for(Integer num : map.keySet()){
            if(map.get(num) == maxFreq)
                list.add(num);
        }

        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }

        return res;
    }

    public void inorder(TreeNode root){
        if(root == null) return;

        inorder(root.left);
        map.put(root.val, map.getOrDefault(root.val, 0) + 1);
        maxFreq = Math.max(map.get(root.val), maxFreq);
        inorder(root.right);
    }
```





```java
/*
		对中序遍历进行改造
*/
		int maxFreq = 0;
    int count = 0;
    List<Integer> list = new ArrayList<>();
    TreeNode pre = null;
    public int[] findMode(TreeNode root) {
        inorder(root);

        int[] res = new int[list.size()];
        for(int i = 0; i < list.size(); i++){
            res[i] = list.get(i);
        }

        return res;
    }

    public void inorder(TreeNode root){
        if(root == null) return;

        inorder(root.left);

        if(pre == null || pre.val == root.val){
            count++;
        }else{
            count = 1;
        }

        pre = root;
        
        if(count > maxFreq){
            list.clear();
            maxFreq = count;
            list.add(root.val);
        }else if(count == maxFreq){
            list.add(root.val);
        }

        inorder(root.right);
    }


```





# 502 IPO



<img src="501 - 600.assets/image-20210208100123220.png" alt="image-20210208100123220" style="zoom:50%;" />



```cpp
/*
	source : https://www.youtube.com/watch?v=VFXfhB8vS94&t=570s
	
	写的真好，思路是：
	使用两个优先队列，第一个存储我们的pair 键值对， Profit + Capital
  第二个是我们的consideration set
  	它用来，贪心，做出当前最优选择
  	
  整体循环 K 次， 拿到每次的结果
  
  同时注意。 Capital 只是一个threashold， 并不会扣除我们的 profit
  profit 是我们的净利润
*/

typedef pair<int, int> ii;
class cmp{
public:
  bool operator()(ii a, ii b){
    return a.first > b.first;
  }
};

class Solution{
  public:
  	int findMaximizedCapital(int k, int W, vector<int>& Profits, vector<int>& Capital){
      int n = Profits.size();
      vector<ii> projects;
      
      for(int i = 0; i < n; i++)
        projects.push_back({Capital[i], Profits[i]});
      
      priority_queue<ii, vector<ii>, cmp> projects_pq{cmp{}, projects};
      priority_queue<int> feasible;
      
      while(k--){
        while(not projects_pq.empty() and projects_pq.top().first <= W){
          feasible.push(projects_pq.top().second);
          projects_pq.pop();
        }
        
        if(feasible.empty())
          return W;
        
        W += feasible.top();
        feasible.pop();
      }
      
      return W;
    }
};
```





```java
/*
		Java 版本
		
*/
class Solution {
    public int findMaximizedCapital(int k, int W, int[] Profits, int[] Capital) {
        //  cap, prof, small heap
        PriorityQueue<Node>    pq       = new PriorityQueue<>((x, y) -> x.key - y.key);

        //max heap
        PriorityQueue<Integer> considerationSet = new PriorityQueue<>((x, y) -> (y - x));

        for (int i = 0; i < Profits.length; i++) {
            pq.add(new Node(Capital[i], Profits[i]));
        }

        while(k > 0){
            while(!pq.isEmpty() && pq.peek().key <= W){
                Node node = pq.poll();
                considerationSet.add(node.val);
            }

            if(considerationSet.isEmpty())
                return W;
            W += considerationSet.poll();
            k--;
        }

        return W;
    }


}

class Node{
    public int key;
    public int val;

    public Node(int key, int val) {
        this.key = key;
        this.val = val;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Node node = (Node) o;
        return key == node.key && val == node.val;
    }

    @Override
    public int hashCode() {
        return toString().hashCode();
    }

    @Override
    public String toString() {
        return key + "@" + val;
    }
}



```











# 504 Base 7 

<img src="501 - 600.assets/image-20210208192446020.png" alt="image-20210208192446020" style="zoom:50%;" />

```java
    public String convertToBase7(int num) {
        if(num == 0)        return "0";
        StringBuilder sb = new StringBuilder();
        int sign = num < 0 ? -1 : 1;
        num = num < 0 ? -num : num;
        while(num > 0){
            int quo       = num / 7;
            int remainder = num % 7;
            sb.append(remainder);
            num /= 7;
        }

        sb.reverse();
        if(sign == -1)
            sb.insert(0, '-');

        return sb.toString();
    }
```









# 506 Relative Rank



<img src="501 - 600.assets/image-20210209064905076.png" alt="image-20210209064905076" style="zoom:50%;" />

```java

    public String[] findRelativeRanks(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();

        int[] newNums = Arrays.copyOf(nums, nums.length);
        Arrays.sort(newNums);

        for(int i = 0; i < newNums.length; i++){
            map.put(newNums[i], newNums.length - i);
        }

        String[] res = new String[nums.length];
        for(int i = 0; i < res.length; i++){
            if(newNums.length >= 1 && nums[i] == newNums[newNums.length - 1])
                res[i] = "Gold Medal";
            else if(newNums.length >= 2 && nums[i] == newNums[newNums.length - 2])
                res[i] = "Silver Medal";
            else if(newNums.length >= 3 && nums[i] == newNums[newNums.length - 3])
                res[i] = "Bronze Medal";
            else
                res[i] = map.get(nums[i]) + "";
        }

        return res;
    }
```





# 507 Perfect Number

<img src="501 - 600.assets/image-20210209064957775.png" alt="image-20210209064957775" style="zoom:50%;" />

```java
/*
		brute force， 肯定超时
		66/99
*/
public boolean checkPerfectNumber(int num) {
        int sum = 0;

        for(int i = 1 ;i < num; i++){
            if(num % i == 0)
                sum += i;
        }

        return sum == num;
    }
```



```java
/*
		打表
*/
public boolean checkPerfectNumber(int num) {

        switch(num) {
            case 6: case 28: case 496: case 8_128: case 33_550_336: return true;
            default: return false;
        }

    }
```





```java
/*
	正经解法
*/    
public boolean checkPerfectNumber(int num) {
        /*
            1， 2， 4， 7
        */
        if(num == 1)
            return false;
        int sum = 1;
        for(int i = 2; i <= Math.sqrt(num); i++){
            if(num % i == 0){
                sum += i;
                if(i != num / i)
                    sum += num / i;
            }
        }

        return sum == num;
    }
```





# 508 Most Frequent Subtree

<img src="501 - 600.assets/image-20210209073831190.png" alt="image-20210209073831190" style="zoom:50%;" />



```java
    HashMap<Integer, Integer> map = new HashMap<>();
    int maxFreq = 0;
    public int[] findFrequentTreeSum(TreeNode root) {
        postOrder(root);

        List<Integer> ans = new ArrayList<>();
        for(Integer num : map.keySet()){
            if(map.get(num) == maxFreq)
                ans.add(num);
        }

        int[] res = new int[ans.size()];
        for(int i = 0; i < ans.size(); i++)
            res[i] = ans.get(i);

        return res;
    }

    public int postOrder(TreeNode root){
        if(root == null)
            return 0;

        int leftSum  = postOrder(root.left);
        int rightSum = postOrder(root.right);

        int val = root.val + leftSum + rightSum;
        map.put(val, map.getOrDefault(val, 0) + 1);
        maxFreq = Math.max(maxFreq, map.get(val));
        
        return val;
    }
```









# 509 Fibonacci Number





```go
func fib(n int) int {
	m := make(map[int]int)
	m[0] = 0
	m[1] = 1
	return dfs(n, &m)
}

func dfs(n int, m *map[int]int) int{
	if _, ok := (*m)[n]; ok{
		return (*m)[n]
	}
	
	res := 0
	res += dfs(n - 1, m) + dfs(n - 2, m)

	(*m)[n] = res
	return res
}
```



<img src="501 - 600.assets/image-20210209200546455.png" alt="image-20210209200546455" style="zoom:50%;" />

```java
    public int fib(int n) {
        if(n <= 1)
            return n;

        int a = 0;
        int b = 1;
        /*
            F(2) = a + b = 1;
                a = b  为1;
            F(3) = a + b = 2;
                b = 2; a = 1;
            F(4) = a + b = 3;
                b = 3 a = 2
        */

        for(int i = 2; i <= n; i++){
            int temp = a + b;
            a = b;
            b = temp;
        }
        
        return b;
    }
```







# 510 Inorder Successor In BST II

<img src="501 - 600.assets/image-20210210083516876.png" alt="image-20210210083516876" style="zoom:50%;" />

```java
/*
		暴力解法
*/   
List<Node> list = new ArrayList<>();
    public Node inorderSuccessor(Node node) {
        Node ancestor = node.parent;
        while(ancestor != null &&  ancestor.parent != null)
            ancestor = ancestor.parent;
        
        if(ancestor == null){
            inorder(node);
        }else{
            inorder(ancestor);
        }

        for(int i = 0; i < list.size(); i++)
            if(node.val == list.get(i).val && i < list.size() - 1)
                return list.get(i + 1);
            
        return null;
    }

    public void inorder(Node node){
        if(node == null)
            return;
        
        inorder(node.left);

        list.add(node);

        inorder(node.right);
    }
```





```java
/*
		优化解法
*/ 
public Node inorderSuccessor(Node node) {
        if(node == null)
            return null;
        
        if(node.right == null){
            while(node.parent != null && node.parent.right == node)
                node = node.parent;
            
            return node.parent;
        }else{ // node.right != null
            node = node.right;
            while(node.left != null)
                node = node.left;   
            return node;
        }
    }
```









# 513 Find Bottom Left Tree Value

<img src="501 - 600.assets/image-20210210090912445.png" alt="image-20210210090912445" style="zoom:50%;" />

```java
   public int findBottomLeftValue(TreeNode root) {
        Deque<TreeNode> queue = new ArrayDeque<>();

        queue.add(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            boolean lastLevel = true;
            int target = 0;
            for(int i = 0; i < size; i++){
                TreeNode cur = queue.pollFirst();
                if(i == 0)
                    target = cur.val;
                if(cur.left != null){
                    queue.addLast(cur.left);
                    lastLevel = false;
                }
                if(cur.right != null){
                    queue.addLast(cur.right);
                    lastLevel = false;
                }
            }

            if(lastLevel)
                return target;
        }

        return -1;
    }
```





# 514 Freedom Trail

<img src="501 - 600.assets/image-20210211081104876.png" alt="image-20210211081104876" style="zoom:50%;" />

```java
/*
	source:  https://www.youtube.com/watch?v=1ErNzKfRrX8
	
	算法分为三步
		1 记录下每个char 出现的位置
		
		2 对于每一个cur char， 通过上一个potential candidate  prevPos 的旋转差值
*/   
int findRotateSteps(string ring, string key){
        unordered_map<char, vector<int>> letter2pos;

        for(int i = 0; i < ring.size(); i++)
            letter2pos[ring[i]].push_back(i);

        int n = key.size(), m = ring.size();
  /*
  		 dp[i][j] 代表第 i 轮下 旋转到 该char 下从 j的位置，最小步数
  		
  				i 代表的是第几轮了，以key 为标准
  				j 代表的是对于该轮次下， 该char的对应位置
  		
  */
        vector<vector<int>> dp = vector<vector<int>>(n, vector<int>(m, INT_MAX / 2));

  		
        for(int i = 0; i < n; i++){
            if(i == 0){
                for(int curPos : letter2pos[key[i]])
                  //							或者顺时针，或者逆时针旋转
                    dp[i][curPos] = min(curPos, abs(m - curPos));
            }else{
                for(int curPos : letter2pos[key[i]])
                    for(int prePos : letter2pos[key[i - 1]])
                        dp[i][curPos] = min(dp[i][curPos], dp[i - 1][prePos] + min(abs(curPos - prePos), m - abs(curPos - prePos)));
            }
        }
        
        int res = INT_MAX;
        for(int pos : letter2pos[key[n - 1]])
            res = min(res, dp[n - 1][pos]);
        
        return res + n;
    }
```



```java
    public int findRotateSteps(String ring, String key) {
        Map<Character, List<Integer>> map = new HashMap<>();

        for(int i = 0; i < ring.length(); i++){
            char ch = ring.charAt(i);
            map.putIfAbsent(ch, new ArrayList<>());
            map.get(ch).add(i);
        }
        int m = ring.length();
        int n = key.length();

        int[][] dp = new int[n][m];
        for(int i = 0; i < n; i++)
            Arrays.fill(dp[i], Integer.MAX_VALUE);

        for(int i = 0; i < n; i++){
            if(i == 0){
                for(Integer curPos : map.get(key.charAt(i)))
                    dp[i][curPos] = Math.min(Math.abs(m - curPos), curPos);
            }else{
                for(Integer curPos : map.get(key.charAt(i)))
                    for(Integer prevPos : map.get(key.charAt(i - 1))){
                        dp[i][curPos] = Math.min(dp[i][curPos], dp[i - 1][prevPos] + Math.min(Math.abs(curPos - prevPos), m - Math.abs(curPos - prevPos)));
                    }
            }
        }

        int res = Integer.MAX_VALUE;
        for(Integer pos : map.get(key.charAt(n - 1)))
            res = Math.min(res, dp[n - 1][pos]);
        return res + n;
    }
```









# 515 Find Largest Value in Each Tree Row



<img src="501 - 600.assets/image-20210211072806104.png" alt="image-20210211072806104" style="zoom:50%;" />

```java
class Solution {
    public List<Integer> largestValues(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null)    
            return res;
            
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.add(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            int max = Integer.MIN_VALUE;
            for(int i = 0; i < size; i++){
                TreeNode cur = queue.pollFirst();
                max = Math.max(cur.val, max);

                if(cur.left != null)
                    queue.addLast(cur.left);
                if(cur.right != null)
                    queue.addLast(cur.right);
            }

            res.add(max);
        }

        return res;
    }
}
```





# 516 Longest Palindromic Subsequence 不错的DP题目



<img src="501 - 600.assets/image-20210211134842235.png" alt="image-20210211134842235" style="zoom:50%;" />



```java
/*
		暴力回溯， 时间复杂度 O(2 ^ n)
		
		通过 61 / 83
*/
		int res = 1;
    public int longestPalindromeSubseq(String s) {
        if(s == null || s.length() == 0)
            return 0;

        dfs(s, new StringBuilder(), 0);
        return res;
    }

    public void dfs(String s, StringBuilder sb, int start){
        if(isPalindromic(sb.toString()))
            res = Math.max(res, sb.length());
        if(start == s.length())
            return;
        
   
        dfs(s, new StringBuilder(sb), start + 1);
        sb.append(s.charAt(start));
        dfs(s, new StringBuilder(sb), start + 1);
    }

    public boolean isPalindromic(String sb){
        int left = 0, right = sb.length() - 1;

        while(left <= right){
            if(sb.charAt(left) != sb.charAt(right))
                return false;
            left++;
            right--;
        }

        return true;
    }
```



```java
/*
	 采用 dp 
	 dp 定义： 在子串 s[i...j] 中，最长回文子序列的长度为dp[i][j]
	 
	 状态转移需要归纳思维，如何从已知推出未知
	 从而定义容易归纳，容易发现状态转移方程
*/

    public int longestPalindromeSubseq(String s) {
        int len = s.length();
        /*
            dp[i][j] means 
                s[i...j] 中最长的串子长度
        */
        if(s == null || s.length() == 0)
            return 0;

        int res = 1;
        int[][] dp = new int[len][len];
        for(int i = 0; i < len; i++)
            dp[i][i] = 1;
        for(int i = len - 1; i >= 0; i--){
            for(int j = i + 1; j < len; j++){
                if(s.charAt(i) == s.charAt(j))
                    dp[i][j] = (j - i == 2 ? 3 : dp[i + 1][j - 1] + 2);
                else
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                
                res = Math.max(res, dp[i][j]);
            }
        }
        
        return res;
    }
```



# 517 Super Washing Machines



<img src="501 - 600.assets/image-20210211143944384.png" alt="image-20210211143944384" style="zoom:50%;" />

```cpp
/*
	source: 
		https://www.youtube.com/watch?v=QNAGlcqu0nA&t=4s
		https://leetcode-cn.com/problems/super-washing-machines/solution/csi-lu-by-beny-g/
		
		本质思路类似于水流的流入与流出
		拿到每个点，最大的净输出即可
		
		因此定义两个数组， left / right
		
		有如下关系式
		left[i] + right[i] = machiens[i] - k;
		right[i] = -left[i + 1]

		定义 输出为 负， 输入为正
*/

    public int findMinMoves(int[] machines) {
        int sum = 0;
        int avg = 0;
        int len = machines.length;
        for(int num : machines)
            sum += num;
        if(sum % len != 0)  
            return -1;
        avg = sum / len;

        int[] left = new int[len];
        int[] right = new int[len];

        for(int i = 0; i < len; i++){
            if(i == 0){
                left[i] = 0;
                right[i] = machines[i] - avg;
            }else if(i == len - 1){
                left[i] = machines[i] - avg - right[i];
                right[i] = 0;
            }else{
                left[i] = -right[i - 1];
                right[i] = machines[i] - avg - left[i];
            }
        }

        int res = 0;
        for(int i = 0; i < len; i++){
            int temp = 0;
            if(left[i] > 0)
                temp += left[i];
            if(right[i] > 0)
                temp += right[i];
            res = Math.max(res, temp);
        }

        return res;
    }
```













# 519 Random Flip Matrix 未完成

<img src="501 - 600.assets/image-20210212094724484.png" alt="image-20210212094724484" style="zoom:50%;" />

```java

```





# 520 Detect Capital

<img src="501 - 600.assets/image-20210211141450930.png" alt="image-20210211141450930" style="zoom:50%;" />

```java

    public boolean detectCapitalUse(String word) {
        if(word == null || word.length() == 0)
            return true;

        boolean firstUpper = upperCase(word.charAt(0));

        if(firstUpper){
            if(word.length() >= 2){
                if(upperCase(word.charAt(1))){
                    for(int i = 2; i < word.length(); i++)
                        if(!upperCase(word.charAt(i)))
                            return false;
                    
                    return true;
                }else{
                    for(int i = 2; i < word.length(); i++)
                        if(upperCase(word.charAt(i)))
                            return false;
                    
                    return true;
                }
            }else{
                return true;
            }

        }else{
            for(int i = 1; i < word.length(); i++){
                char ch = word.charAt(i);
                if(upperCase(ch))
                    return false;
            }

            return true;
        }
    }

    public boolean upperCase(char ch){
        return 'A' <= ch && ch <= 'Z';
    }
```





# 521 Longest Uncommon Subsequence I脑经急转弯题目

<img src="501 - 600.assets/image-20210212075205716.png" alt="image-20210212075205716" style="zoom:50%;" />



```java
    public int findLUSlength(String a, String b) {
        if(a.equals(b))
            return -1;
        
        return a.length() > b.length() ? a.length() : b.length();
    }
```







# 522 Longest Uncommon Susbequence II

<img src="501 - 600.assets/image-20210213135452747.png" alt="image-20210213135452747" style="zoom:50%;" />

```java
/*
	ref: https://leetcode.com/problems/longest-uncommon-subsequence-ii/discuss/99443/Java(15ms)-Sort-%2B-check-subsequence
*/   
public int findLUSlength(String[] strs) {
        Arrays.sort(strs, (o1, o2) -> o2.length() - o1.length());
        Set<String> duplicates = getDup(strs);

        for(int i = 0; i < strs.length; i++){
            if(!duplicates.contains(strs[i])){
                if(i == 0)
                    return strs[0].length();
                for(int j = 0; j < i; j++){
                    if(isSubsequence(strs[j], strs[i]))
                        break;
                    if(j == i - 1)
                        return strs[i].length();
                }
            }
        }

        return -1;
    }
/*
		判断 b 是否 是 a的一个子序列，方法不错
*/
    public boolean isSubsequence(String a, String b){
        int i = 0, j = 0;
        while(i < a.length() && j < b.length()){
            if(a.charAt(i) == b.charAt(j))
                j++;
            i++;
        }

        return j == b.length();
    }

    private Set<String> getDup(String[] strs){
        Set<String> set = new HashSet<>();
        Set<String> dup = new HashSet<>();

        for(String s : strs){
            if(set.contains(s))
                dup.add(s);
            set.add(s);
        }

        return dup;
    }
}

```













# 523 Continuous Subarray Sum

<img src="501 - 600.assets/image-20210212080940938.png" alt="image-20210212080940938" style="zoom:50%;" />

```java
    public boolean checkSubarraySum(int[] nums, int k) {

        for(int i = 1; i < nums.length; i++)
            nums[i] += nums[i - 1];
        
        for(int i = 0; i < nums.length - 1; i++){
            for(int j = i + 1; j <= nums.length; j++){
                int target = 0;
                if(j == nums.length)
                    target = nums[j - 1];
                else
                    target = nums[j] - nums[i];

                boolean val = findSuitableKVal(target, k);
                if(val && j - i > 1)
                    return true;
            }
        }

        return false;
    }

    public boolean findSuitableKVal(int target, int k){
        if(k == 0)
            return target == 0;
        
        return target % k == 0;
    }
```



```java
//简化写法
public class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int[] sum = new int[nums.length];
        sum[0] = nums[0];
        for (int i = 1; i < nums.length; i++)
            sum[i] = sum[i - 1] + nums[i];
        for (int start = 0; start < nums.length - 1; start++) {
            for (int end = start + 1; end < nums.length; end++) {
                int summ = sum[end] - sum[start] + nums[start];
                if (summ == k || (k != 0 && summ % k == 0))
                    return true;
            }
        }
        return false;
    }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/continuous-subarray-sum/solution/lian-xu-de-zi-shu-zu-he-by-leetcode/
```









**空间换时间**

```java
/*
	这种方法的思路是 
	 假设 sum[:i]的和为 n * k + 余数
	 假设 sum[;j]的和为 m * k + 余数
	 
	 只要两个的余数是一致的，那么sum[j] - sum[i] 就可以被 k 整除
	 
	 最后记得一个特例[0,0] 0
	 需要map提前处理
*/
public class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
        int sum = 0;
        HashMap<Integer, Integer> map = new HashMap < > ();
        map.put(0, -1);
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            if (k != 0)
                sum = sum % k;
            if (map.containsKey(sum)) {
                if (i - map.get(sum) > 1)
                    return true;
            } else
                map.put(sum, i);
        }
      
        return false;
    }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/continuous-subarray-sum/solution/lian-xu-de-zi-shu-zu-he-by-leetcode/
```







# 524 Longest Word In Dictionary Through Deleting

<img src="501 - 600.assets/image-20210213141855266.png" alt="image-20210213141855266" style="zoom:50%;" />

```java
/*
	思路很简单，就是将其排序，从大到小
	然后判断每一个string 是否是 s的子串，将所有的candidates 加入到List中
	
	最后sort 它们
*/  
	public String findLongestWord(String s, List<String> d) {
        TreeMap<Integer, List<String>> map = new TreeMap<>((o1, o2) -> o2 - o1);
        for(String str : d){
            map.putIfAbsent(str.length(), new ArrayList<>());
            map.get(str.length()).add(str);
        }


        Iterator<Integer> it = map.keySet().iterator();
        List<String> candidate = new ArrayList<>();
        while(it.hasNext()){
            Integer len = it.next();
            List<String> sameLenCollection = map.get(len);
            for(String str : sameLenCollection){
                if(isSubsequence(s, str))
                    candidate.add(str);
            }

            if(candidate.size() >= 1)
                break;
        }

        if(candidate.size() == 0)
            return "";
        Collections.sort(candidate);
        return candidate.get(0);
    }

    /**
     * to justify whether B is a subsequence of A
     * @param a the relatively long string
     * @param b the shorter one
     * @return true or not
     */
    private boolean isSubsequence(String a, String b){
        int i = 0, j = 0;
        while(i < a.length() && j < b.length()){
            if(a.charAt(i) == b.charAt(j))
                j++;
            i++;
        }

        return j == b.length();
    }
```





# 525 Contiguous Array

<img src="501 - 600.assets/image-20210213144249041.png" alt="image-20210213144249041" style="zoom:50%;" />

```java
/*
		暴力解法，时间复杂度 O(N^2)
*/
    public int findMaxLength(int[] nums) {
        /*
            0 1 0 1 0 0 1 1 0 0 1 1
        */
            //  index,   #0 and #1
        HashMap<Integer, String> map = new HashMap<>();
        map.put(-1, 0 + "@" + 0);
        int zero = 0;
        int one  = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0)
                zero++;
            else
                one++;
            
            map.put(i, zero + "@" + one);
        }

        int res = 0;
        for(int i = -1; i < nums.length; i++){
            for(int j = i + 1; j < nums.length; j++){
                if(i == -1){
                    String[] tmp = map.get(j).split("@");
                    int z = Integer.parseInt(tmp[0]);
                    int o = Integer.parseInt(tmp[1]);

                    if(z == o)
                        res = Math.max(res, z + o);
                }else{
                    String[] tmp1 = map.get(i).split("@");
                    String[] tmp2 = map.get(j).split("@");

                    int z = Integer.parseInt(tmp2[0]) - Integer.parseInt(tmp1[0]);
                    int o = Integer.parseInt(tmp2[1]) - Integer.parseInt(tmp1[1]);
                    if(z == o)
                        res = Math.max(res, z + o);
                }
            }
        }

        return res;
    }
```





贼几把类似 523

<img src="501 - 600.assets/image-20210213172434970.png" alt="image-20210213172434970" style="zoom:50%;" />

```java
public class Solution {

    public int findMaxLength(int[] nums) {
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);
        int maxlen = 0, count = 0;
        for (int i = 0; i < nums.length; i++) {
            count = count + (nums[i] == 1 ? 1 : -1);
            if (map.containsKey(count)) {
                maxlen = Math.max(maxlen, i - map.get(count));
            } else {
                map.put(count, i);
            }
        }
        return maxlen;
    }
}


作者：LeetCode
链接：https://leetcode-cn.com/problems/contiguous-array/solution/lian-xu-shu-zu-by-leetcode/
```







# 526 Beautiful Arrangement



<img src="501 - 600.assets/image-20210213172520377.png" alt="image-20210213172520377" style="zoom:50%;" />





```java
    int count = 0;
    public int countArrangement(int n) {
        backtrack(n, 0, new HashSet<>(), new StringBuilder());
        return count;
    }
    

    private void backtrack(int n, int start, HashSet<Integer> visited, StringBuilder path) {
        if(start == n) {
            count++;
            return;
        }

        for(int i = 1; i <= n; i++){
            if(visited.contains(i))
                continue;
            //start + 1;
            boolean flag = false;
            if(i > start + 1){
                if(i % (start + 1) == 0)
                    flag = true;
            }else{
                if((start + 1) % i == 0)
                    flag = true;
            }
            
            if(flag == false)
                continue;
            
            int len = path.length();
//            path.append(i).append();
            visited.add(i);
            backtrack(n, start + 1, visited, path);
            visited.remove(i);
//            path.setLength(len);
        }
    }
```





# 527 Word Abbreviation



<img src="501 - 600.assets/image-20210214173212215.png" alt="image-20210214173212215" style="zoom:50%;" />

```java
/*
		采用全局 lookup 的映射，实现对dict中每个String的更新
*/
HashMap<String, String>  lookup = new HashMap<>();
    public List<String> wordsAbbreviation(List<String> dict) {
        wordsAbbreviation(dict, 0);
        List<String> res = new ArrayList<>();
        for(int i = 0; i < dict.size(); i++){
            res.add(lookup.get(dict.get(i)));
        }
        return res;
    }

    public void wordsAbbreviation(List<String> dict, int start){

      	//  key 为缩写， String 为 value
        HashMap<String, List<String>> group = new HashMap<>();

      /*
      		将他们分组， 
      */
        List<String> counterpart = new ArrayList<>();
        for (int i = 0; i < dict.size(); i++) {
            String s    = dict.get(i);
            String abbr = generateAbbr(s, 0);
            group.putIfAbsent(abbr, new ArrayList<>());
            group.get(abbr).add(s);

            lookup.put(s, abbr);
        }

        for(String str : group.keySet()){
            List<String> strs = group.get(str);
            if(strs.size() == 1)
                continue;

            HashMap<String, List<String>> reused = new HashMap<>();
            for(String string : strs){
                String abbr = generateAbbr(string, start);
                reused.putIfAbsent(abbr, new ArrayList<>());
                reused.get(abbr).add(string);
                lookup.put(string, abbr);
            }
			//如果都没有重复，直接break
            if(reused.size() == strs.size())
                break;
            else{
              //将没有重复的直接去除，只递归有重复的
                for(String toCheck : reused.keySet()){
                    if(reused.get(toCheck).size() != 1)
                        wordsAbbreviation(reused.get(toCheck), start + 1);
                }
            
            }
        }

    }

//负责产生所需要的缩写
    private String generateAbbr(String s, int start) {
        int left = start + 1, right = s.length() - 2;
        int len = right - left + 1;
        if((len + "").length() >= len)
            return s;

        return s.substring(0, left) + len + s.substring(left + len);
    }

/*
	li1e
*/
```







# 528 Random Pick with Weight

<img src="501 - 600.assets/image-20210214174642033.png" alt="image-20210214174642033" style="zoom:50%;" />

```java


```





# 529 Mine Sweeper



```java
    int[][] direction = {{1,0},{0,1},{-1,0},{0,-1}};
    int[][] check = {{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,-1},{-1,1}};
    char[][] board;
    public char[][] updateBoard(char[][] board, int[] click) {
        if(board[click[0]][click[1]] == 'M'){
            board[click[0]][click[1]] = 'X';
            return board;
        }
        this.board = board;
        dfs(click[0], click[1]);
        return board;
    }

    private void dfs(int r, int c){
        if(isInRange(r,c) && board[r][c] == 'E'){
            int numOfMines = numMinesAround(r, c);

            if(numOfMines != 0){
                board[r][c] = ((char)('0' + numOfMines));
                return;
            }else{
                board[r][c] = 'B';
            
            
            for(int k = 0; k < check.length; k++){
                int newX = r + check[k][0];
                int newY = c + check[k][1];

                if(isInRange(newX, newY) && board[newX][newY] == 'E')
                    dfs(newX, newY);
            }
            
        }
    }

    private int numMinesAround(int r,int c){
        int res = 0;
        for(int k = 0; k < check.length; k++){
            int newX = r + check[k][0];
            int newY = c + check[k][1];

            if(isInRange(newX, newY) && board[newX][newY] == 'M')
                res++;
        }

        return res;
    }

    private boolean isInRange(int r, int c){
        return r >= 0 && c >= 0 && r < board.length && c < board[0].length;
    }

```











# 530 Minimum Absolute Difference

<img src="501 - 600.assets/image-20210212173551856.png" alt="image-20210212173551856" style="zoom:50%;" />

```java
    TreeNode pre = null;
    long res = Integer.MAX_VALUE;
    public int getMinimumDifference(TreeNode root) {
        inorder(root);

        return (int)res;
    }

    public void inorder(TreeNode root){
        if(root == null)    
            return;
        
        inorder(root.left);

        if(pre != null)
            res = Math.min(res, Math.abs((long)(root.val) - (long)(pre.val)));
        
        pre = root;

        inorder(root.right);
    }
```







# 531 Lonely Pixel I 



<img src="501 - 600.assets/image-20210214201158517.png" alt="image-20210214201158517" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210214202029264.png" alt="image-20210214202029264" style="zoom:50%;" />

```java
    
    public int findLonelyPixel(char[][] picture) {
        int res = 0;
        int row = picture.length;
        int col = picture[0].length;
        int[] countRow = new int[row];
        int[] countCol = new int[col];

        for(int i = 0; i < row; i++)
            for(int j = 0; j < col; j++){
                if(picture[i][j] == 'B'){
                    countRow[i]++;
                    countCol[j]++;
                }
            }
        
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(picture[i][j] == 'B' && countCol[j] == 1 && countRow[i] == 1)
                    res++;
            }
    }

        return res;
    }
```









# 532 K-diff Pairs in an Array

<img src="501 - 600.assets/image-20210214202220390.png" alt="image-20210214202220390" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210214202648913.png" alt="image-20210214202648913" style="zoom:50%;" />

```java
/*
		O(N2)的时间复杂度
*/
	public int findPairs(int[] nums, int k) {
        HashSet<String> set = new HashSet<>();
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            for(int j = 0; j < nums.length; j++){   
                if(i == j)    
                    continue;
                if(Math.abs(nums[i] - nums[j]) == k){
                    if(nums[i] > nums[j])
                        set.add(nums[i] + "@" + nums[j]);
                    else
                        set.add(nums[j] + "@" + nums[i]);
                }
            }
        }
//        System.out.println(set);

        return set.size();

    }
```



<img src="501 - 600.assets/image-20210214210208392.png" alt="image-20210214210208392" style="zoom:50%;" />

```java
/*
		O(nlogn) 时间复杂度
*/
public int findPairs(int[] nums, int k) {
        int count = 0;
        int left = 0, right = 1;
        Arrays.sort(nums);

        while(right < nums.length){
            if(left == right) {
                right++;
                continue;
            }
            int diff = nums[right] - nums[left];
            if(diff == k){
                count++;
                while(right < nums.length - 1 && nums[right] == nums[right + 1])
                    right++;
                right++;
                while(left < nums.length - 1  && nums[left] == nums[left + 1])
                    left++;
                left++;
            }
            else if(diff < k)
                right++;
            else
                left++;

        }

        return count;
    }

```







# 533 Lonely Pixel II

<img src="501 - 600.assets/image-20210215112648332.png" alt="image-20210215112648332" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210215112241802.png" alt="image-20210215112241802" style="zoom:50%;" />

```java
    public int findBlackPixel(char[][] picture, int N) {
        int row = picture.length;
        int col = row == 0 ? 0 : picture[0].length;
        if(col == 0)
            return 0;

        List<String> rowString = new ArrayList<>();
        int[] numBlackRow = new int[row];
        int[] numBlackCol = new int[col];

        for(int i = 0; i < row; i++){
            StringBuilder sb = new StringBuilder();

            for(int j = 0; j < col; j++){
                if(picture[i][j] == 'B'){
                    numBlackRow[i]++;
                    numBlackCol[j]++;
                }

                sb.append(picture[i][j]);
            }

            rowString.add(sb.toString());
        }

        int count = 0;
        HashSet<Integer> colVisited = new HashSet<>();
        for(int j = 0; j < col; j++){
            if(numBlackCol[j] != N)
                continue;
            for(int i = 0; i < row; i++){
                if(numBlackRow[i] != numBlackCol[j] || colVisited.contains(j))
                    continue;
                
                HashSet<String> visited = new HashSet<>();
                for(int k = 0; k < row; k++){
                    if(picture[k][j] == 'B')
                        visited.add(rowString.get(k));
                }

                if(visited.size() == 1){
                    count += numBlackCol[j];
                    colVisited.add(j);
                }
            }
        }

        return count;
    }
```







# 535 TinyURL



<img src="501 - 600.assets/image-20210215112712549.png" alt="image-20210215112712549" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210216181332447.png" alt="image-20210216181332447" style="zoom:50%;" />

```java
/*
		当然这种方法存在 弊端
		1. 如果被 asked 编码same URL 多次，会产生不同的entries， 这样会浪费空间
		2. 容易被别人猜出来我们用了多少次
		3. 采用 6 位数字只能产生 a million codes 
		   使用 混合6位数字 + alpha可以产生 (10 + 26 * 2)^6  = 56,800,235,584
*/
public class Codec {
    HashMap<Integer, String> map = new HashMap<>();
    int count = 0;
    final String BASE_HOST = "http://tinyurl.com/";
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        String temp = BASE_HOST + count;
        map.put(count, longUrl);
        count++;
        return temp;
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        int pos = shortUrl.indexOf("http://tinyurl.com/");
        int num = Integer.parseInt(shortUrl.substring(19));
        return map.get(num);
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.decode(codec.encode(url));
```



```java
/*
		正经方法
*/    
//      index    longUrl
    HashMap<String, String> index    = new HashMap<>();
    //      longUrl   index
    HashMap<String, String> revIndex = new HashMap<>();
    final String charSet = "abcdefghijklmnopqrstuvwxyz0123456789";
    final String BASE_HOST = "http://tinyurl.com/4e9iAk";
    // Encodes a URL to a shortened URL.
    public String encode(String longUrl) {
        if(revIndex.containsKey(longUrl))
            return BASE_HOST + revIndex.get(longUrl);
        
        StringBuilder sb = new StringBuilder();
        while(true){
            for(int i = 0; i < 6; i++){
                int pos = (int)(Math.random() * charSet.length());
                sb.append(charSet.charAt(pos));
            }

            if(!index.containsKey(sb.toString()))
                break;
        }
        String key = sb.toString();
        index.put(key, longUrl);
        revIndex.put(longUrl, key);
        return BASE_HOST + key;
    }

    // Decodes a shortened URL to its original URL.
    public String decode(String shortUrl) {
        return index.get(shortUrl.substring(shortUrl.indexOf(BASE_HOST) + BASE_HOST.length()));

    }
```











# 536 Construct Binary Tree From String

<img src="501 - 600.assets/image-20210215112738766.png" alt="image-20210215112738766" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210215115707630.png" alt="image-20210215115707630" style="zoom:50%;" />

```java
    public TreeNode str2tree(String s) {
        if(s == null || s.length() == 0)
            return null;

        if(s.charAt(0) == '(' && s.charAt(s.length() - 1) == ')')
            s = s.substring(1, s.length() - 1);

        int leftParenthesis = 0;
        int index = 0;
        TreeNode root = null;

        while(index < s.length()){
            if(s.charAt(index) == '('){
                root = new TreeNode(Integer.parseInt(s.substring(0, index)));
                break;
            }
            index++;
        }

        if(index == s.length()){
            root = new TreeNode(Integer.parseInt(s.substring(0, index)));
            return root;
        }

        int leftBound = index;
        while(index < s.length()){
            if(s.charAt(index) == '(')
                leftParenthesis++;
            else if(s.charAt(index) == ')')
                leftParenthesis--;


            if(leftParenthesis == 0)
                break;
            index++;
        }

        TreeNode leftNode  = str2tree(s.substring(leftBound + 1, index));
        TreeNode rightNode = str2tree(s.substring(index + 1, s.length()));

        root.left  = leftNode;
        root.right =  rightNode;

        return root;
    }
```





# 537 Complex Number Multiplication



<img src="501 - 600.assets/image-20210216180458960.png" alt="image-20210216180458960" style="zoom:50%;" />

```java
    public String complexNumberMultiply(String a, String b) {
        int pos1 = a.indexOf('+');
        int pos2 = b.indexOf('+');

        int af   = Integer.parseInt(a.substring(0, pos1));
        int bf   = Integer.parseInt(b.substring(0, pos2));
        int al   = Integer.parseInt(a.substring(pos1 + 1, a.length() - 1));
        int bl   = Integer.parseInt(b.substring(pos2 + 1, b.length() - 1));

        int resf = af * bf - (al * bl);
        int refl = af * bl + al * bf;
        return resf + "+" + refl + "i";
    }
```







# 538 Convert BST to Greater Tree

<img src="501 - 600.assets/image-20210216195222926.png" alt="image-20210216195222926" style="zoom:50%;" />

```java
 /*
    推荐遍历顺序
    右 根 左
 */
class Solution {
    int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        guoguoOrder(root);
        return root;
    }

    public void guoguoOrder(TreeNode root){
        if(root == null)
            return;

        guoguoOrder(root.right);

        int target = sum;
        sum      += root.val;
        root.val += target;
 

        guoguoOrder(root.left);
    }
}

```





# 539 Minimum Time Difference

<img src="501 - 600.assets/image-20210216205723278.png" alt="image-20210216205723278" style="zoom:50%;" />

```java
class Solution {
    public int findMinDifference(List<String> timePoints) {
        /*
            1.find the suitable way to sort

            2. check it one by one
        */
        Node beginNode = new Node(0,0);
        Node endNode   = new Node(24, 0);
        List<Node> list = new ArrayList<>();
        for(String str : timePoints){
            String[] strs = str.split(":");
            int hour = Integer.parseInt(strs[0]);
            int mins = Integer.parseInt(strs[1]);

            list.add(new Node(hour, mins));
        }

        list.sort(new Comparator<Node>() {
            @Override
            public int compare(Node o1, Node o2) {
                return o1.hour == o2.hour ? (o1.mins - o2.mins) : o1.hour - o2.hour;
            }
        });

        int minDiff = Integer.MAX_VALUE;
        for(int i = 0; i < list.size() - 1; i++){
            int curDiff = getDiff(list.get(i), list.get(i + 1));

            minDiff = Math.min(curDiff, minDiff);
        }

        minDiff = Math.min(minDiff, getDiff(beginNode, list.get(0)) + getDiff(list.get(list.size() - 1), endNode));

        return minDiff;
    }

    //assume first is eariler then end
    private int getDiff(Node first, Node end) {
        int curDiffHour = end.hour - first.hour;
        int curDiffMIn  = 0;
        if(end.mins < first.mins){
            curDiffHour--;
            curDiffMIn = end.mins + 60  - first.mins;
        }else {
            curDiffMIn = end.mins - first.mins;
        }

        return curDiffHour * 60 + curDiffMIn;
    }

    public static void main(String[] args) {
        List<String> list = List.of("23:59", "00:00");

        (new Solution()).findMinDifference(list);
    }
}

class Node{
    public int hour;
    public int mins;

    public Node(int hour, int mins){
        this.hour = hour;
        this.mins = mins;
    }
}

```











# 540 Single Element in a Sortede Array

<img src="501 - 600.assets/image-20210216204325617.png" alt="image-20210216204325617" style="zoom:50%;" />

```java
    public int singleNonDuplicate(int[] nums) {
        int num = nums[0];
        for(int i = 1; i < nums.length; i++)
            num ^= nums[i];
        
        return num;
    }
```













# 541 Reverse String II



<img src="501 - 600.assets/image-20210214165109909.png" alt="image-20210214165109909" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210214165123289.png" alt="image-20210214165123289" style="zoom:50%;" />

```java
    public String reverseStr(String s, int k) {
        char[] chars = s.toCharArray();

        int left = 0, right = 0;

        while(left < s.length()){
            right += k;
            int rightBound = Math.min(right - 1, s.length() - 1);
            reverse(chars, left, rightBound);

            left = right + k;
            right = left;
        }

        StringBuilder sb = new StringBuilder();
        for(char ch : chars)
            sb.append(ch);
        return sb.toString();
    }

    private void reverse(char[] chars, int left, int right){
        if(right < left)
            return;
        while(left < right){
            char ch      = chars[left];
            chars[left]  = chars[right];
            chars[right] = ch;
            left++;
            right--;
        }
    }
}
```



# 542 01 Matrix



<img src="501 - 600.assets/image-20210216211730817.png" alt="image-20210216211730817" style="zoom:50%;" />

```java
/*
		实际上就是多点 BFS
*/
int[][] direction = {{1, 0}, {0, 1}, {-1, 0},{0, -1}};
    int row = 0;
    int col = 0;
    public int[][] updateMatrix(int[][] matrix) {
        this.row = matrix.length;
        this.col = row == 0 ? 0 :matrix[0].length;
        int[][] res = new int[row][col];

        HashSet<String> visited = new HashSet<>();
        Deque<String> queue = new ArrayDeque<>();
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(matrix[i][j] == 0)
                    queue.add(i + "@" + j);
            }
        }

        int count = 0;
        while(!queue.isEmpty() && visited.size() != row * col){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                String curStr = queue.pollFirst();
                if(visited.contains(curStr))
                    continue;

                String[] temp = curStr.split("@");
                int curX      = Integer.parseInt(temp[0]);
                int curY      = Integer.parseInt(temp[1]);
            
                visited.add(curStr);
                res[curX][curY] = count;
                for(int k = 0; k < 4; k++){
                    int newX = curX + direction[k][0];
                    int newY = curY + direction[k][1];
                    String newStr = newX + "@" + newY;
                    if(isInRange(newX, newY) && !visited.contains(newStr)){
                        queue.add(newStr);
                    }
                }
            }

            count++;
        }

        return res;
    }

    private boolean isInRange(int x, int y){
        return x >= 0 && y >= 0 && x < row && y < col;
    }
```









# 543 Diameter of Binary Tree

<img src="501 - 600.assets/image-20210216203915316.png" alt="image-20210216203915316" style="zoom:50%;" />

```java
    int max = 0;
    public int diameterOfBinaryTree(TreeNode root) {
        if(root == null)
            return 0;

        max = Math.max(max, maxDepth(root.left) + maxDepth(root.right));
        diameterOfBinaryTree(root.left);
        diameterOfBinaryTree(root.right);

        return max;
    }

    public int maxDepth(TreeNode root){
        if(root == null)
            return 0;
        
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
```







# 544 Output Contest Matches

<img src="501 - 600.assets/image-20210217092549819.png" alt="image-20210217092549819" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210217094805691.png" alt="image-20210217094805691" style="zoom:50%;" />

```java
    public String findContestMatch(int n) {
        List<String> res = null;
        
        int round = (int)Math.pow(n, 1 / 2) + 1;
        for(int i = 0; ; i++){
            List<String> temp = new ArrayList<>();
            if(i == 0){
               
                for(int j = 1; j <= n / 2; j++){
                    StringBuilder sb = new StringBuilder();
                    sb.append("(").append(j).append(",").append(n - j + 1).append(")");
                    temp.add(sb.toString());
                }

                res = temp;
                if(res.size() == 1)
                    break;
            }else{
                int left = 0, right = res.size() - 1;

                while(left < right){
                    StringBuilder sb = new StringBuilder();
                    sb.append("(").append(res.get(left)).append(",").append(res.get(right)).append(")");
                    left++;
                    right--;
                    temp.add(sb.toString());
                }

                res = temp;
                if(res.size() == 1)  
                    break;
            }
        }

        return res.get(0);
    }
```







# 545 Boundary of Binary Tree

<img src="501 - 600.assets/image-20210221084520953.png" alt="image-20210221084520953" style="zoom:50%;" />

```java
    List<Integer> leftBoundary = new ArrayList<>();
    List<Integer> leaves       = new ArrayList<>();
    List<Integer> rightBoundary = new ArrayList<>();
    public List<Integer> boundaryOfBinaryTree(TreeNode root) {
        if(root == null)
            return new ArrayList<>();
        if(root.left == null && root.right == null){
            List<Integer> res = new ArrayList<>();
            res.add(root.val);
            return res;
        }
        getLeftBoundary(root);
        System.out.println(leftBoundary);
        getRightBoundary(root);
        System.out.println(rightBoundary);
        getLeaves(root);
        System.out.println(leaves);

        List<Integer> res = new ArrayList<>();
        res.add(root.val);
        res.addAll(leftBoundary);
        res.addAll(leaves);
        Collections.reverse(rightBoundary);
        res.addAll(rightBoundary);

        return res;
    }

    private void getLeaves(TreeNode root) {
        if(root == null)
            return;

        if(root.left == null && root.right == null) {
            leaves.add(root.val);
            return;
        }

        getLeaves(root.left);
        getLeaves(root.right);
    }


    private void getRightBoundary(TreeNode root) {
        if(root.right == null)
            return;
        TreeNode head = root;

        while(root != null){
            while(root.right != null){
                if(head != root)
                    rightBoundary.add(root.val);
                root = root.right;
            }


            if(root.left != null){
                if(root != head)
                    rightBoundary.add(root.val);
                root = root.left;
            }else
                break;
        }
    }

    private void getLeftBoundary(TreeNode root) {
        if(root.left == null)
            return;
        TreeNode head = root;

        while(root != null){
            while(root.left != null){

                if(head != root)
                    leftBoundary.add(root.val);
                root = root.left;
            }

            if(root.right != null){
                if(root != head)
                    leftBoundary.add(root.val);
                root = root.right;
            }else
                break;
        }
    }

```









# 546 Remove Boxes

<img src="501 - 600.assets/image-20210217104455025.png" alt="image-20210217104455025" style="zoom:50%;" />

```cpp
/*
	类似 
	312 Burst Ballons
	488 Zuma Game
	
source:	https://www.bilibili.com/video/BV11W411Z7jG?from=search&seid=17616780077873944864

	采用记忆化回溯， 比 dp 稍微好一点
	
	刚开始的思路 可能是 
	dp[i][j] -> max score obtained from array[i..j]
		然后通过取分割点 k    i <= k < j 进行求解
		dp[i][j] = Math.max(dp[i][k] + dp[k + 1][j])
		但是无法计算出这种情况
			比如 A B A
			dp(ABA) = dp(A) + dp(BA) = 3;
							= dp(AB) + dp(A) = 3;
		
		无法考察到 dp(ABA) = dp(AA) + dp(B)
		
	
	因此提升维度， 
	dp[i][j][k] = max score of subarry : arr[i] ~ ar[j] if there are k boxes
	that have the same color as arr[j] following arre[j]
		也就是 k 的作用，记录 j 索引之后，还有几个和j的颜色相同的box
	
	比如
	“ABACA”, dp[0][0][2] = dfs("A|AA")  = 9,  // B C 假设被移除
	
	状态转移方程
	dp[i][j][k] = dp[i][j - 1][0] + (k - 1) ^ 2  // case 1 假设将j 及以后的相同颜色合并消除
							= dp[i][p][k + 1] + dp[p + 1][j - 1][0] // case 2
								//寻找分割点，使得 p 处的颜色 与 j 相同
								//将j 追加到 p 后面，然后分割两个子串
*/
class Solution{
public:
	int removeBoxes(vector<int>& boxes){
    const int n = boxes.size();
    m_ = vector<vector<vector<int>>>(n, vector<vector<int>>(n, vector<int<(n)));
    
    return dfs(boxes, 0, n - 1, 0);
  }
  
private :
  vector<vector<vector<int>>> m_;
  int dfs(const vector<int>& boxes, int l, int r, int k){
    if(l > r)
      	return 0;
    if(m_[l][r][k] > 0)
      	return m_[l][r][k];
    
    m_[l][r][k] = dfs(boxes, l, r - 1, 0) + (k + 1) * (k + 1);
    for(int i = l; i < r; i++)
      	if(boxes[i] == boxes[r])
          	m_[l][r][k] = max(m_[l][r][k], dfs(boxes, l, i, k + 1) + dfs(boxes, i + 1, r - 1, 0));
    
    return m_[l][r][k];
  }
};
```

<img src="501 - 600.assets/image-20210221101202342.png" alt="image-20210221101202342" style="zoom:50%;" />



```java
//    java version
		int[][][] dp;
    public int removeBoxes(int[] boxes) {
        int len = boxes.length;
        dp = new int[len][len][len];
        
        return dfs(boxes, 0, len - 1, 0);
    }
    
    private int dfs(int[] boxes, int l, int r, int k){
        if(l > r)
            return 0;
        if(dp[l][r][k] > 0)
            return dp[l][r][k];
     
        dp[l][r][k]  = dfs(boxes, l, r - 1, 0) + (k + 1) * (k + 1);
        for(int i = l; i < r; i++)
            if(boxes[i] == boxes[r])
                dp[l][r][k] = Math.max(dp[l][r][k], dfs(boxes, l, i, k + 1) + dfs(boxes, i + 1, r - 1, 0));
        
        return dp[l][r][k];
    }s
```





# 547 Number of Provinces  UF classic Q

<img src="501 - 600.assets/image-20210217105657182.png" alt="image-20210217105657182" style="zoom:50%;" />

```java
    public int findCircleNum(int[][] isConnected) {
        WeightedUnionFind wuf = new WeightedUnionFind(isConnected.length);
        
        for(int i = 0; i < isConnected.length; i++){
            for(int j = 0; j < isConnected[i].length; j++){
                if(isConnected[i][j] == 1) {
                    wuf.union(i, j);
                }
            }
        }
        
        return wuf.getCount();
    }
}

class WeightedUnionFind{
    private int[] id;
    private int[] sz;
    private int count;

    public WeightedUnionFind(int count){
        this.id    = new int[count];
        this.sz    = new int[count];
        this.count = count;

        for(int i = 0; i < count; i++){
            this.id[i] = i;
            this.sz[i] = 1;
        }
    }

    public boolean isConnected(int p, int q){
        return find(p) == find(q);
    }

    private int find(int p) {
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }

    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)
            return;

        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }

        count--;
    }

    public int getCount(){
        return count;
    }
}
```





# 548 Split Array With Equal Sum

<img src="501 - 600.assets/image-20210218061157316.png" alt="image-20210218061157316" style="zoom:50%;" />

```java
/*
		source: https://www.youtube.com/watch?v=GeT_IfUbC0s
		
		本质上也是求前缀和
		
*/
public boolean splitArray(int[] nums) {
        int len = nums.length;
        int[] prefix = new int[len];
        for(int i = 0; i < len; i++){
            if(i == 0)
                prefix[i] = nums[i];
            else
                prefix[i] += prefix[i - 1] + nums[i];
        }

  /*
  		对每一个j， 可以并行求解 i 和 k
  		
  		防止出现这种案例
  		  i       j
  		4000000004x
  		
  		这样的话， i的位置会反复横跳
  		
  		时间复杂度是 O(n2)
  */
        for(int j = 3; j <= len - 3;j++){
            HashSet<Integer> set = new HashSet<>();

            for(int i = 1; i < j - 1; i++){
                int sum_l1 = prefix[i - 1];
                int sum_l2 = prefix[j - 1]  - prefix[i];
                if(sum_l1 == sum_l2)
                    set.add(sum_l1);
            }

          	//寻找符合题目条件的点
            for(int k = j + 2; k < len - 1; k++){
                int sum_r1 = prefix[k - 1] - prefix[j];
                int sum_r2 = prefix[len - 1] - prefix[k];
                if(sum_r1 == sum_r2 && set.contains(sum_r1))
                    return true;
            }
        }

        return false;
    }
```





# 549 Binary Tree Longest Consecutive Sequence II

<img src="501 - 600.assets/image-20210218072400431.png" alt="image-20210218072400431" style="zoom:50%;" />

```java
  /*
  	类似题目 128
  */  
		int res = 0;
    public int longestConsecutive(TreeNode root) {
        postorder(root);
        return res;
    }

    //arr[0] 递增 arr[1] 递减 
    private int[] postorder(TreeNode root){
        int[] arr = new int[2];
        if(root == null)
            return arr;
        arr[0] = 1;
        arr[1] = 1;
        
        int[] left = postorder(root.left);
        int[] right = postorder(root.right);

        if(root.left != null){
            if(root.left.val - 1 == root.val)
                arr[1] = left[1] + 1;
            else if(root.left.val + 1 == root.val)
                arr[0] = left[0] + 1;
        }

        if(root.right != null){
            if(root.right.val - 1 == root.val)
                arr[1] = Math.max(arr[1], right[1] + 1);
            if(root.right.val + 1 == root.val)
                arr[0] = Math.max(arr[0], right[0] + 1);
        }

        res = Math.max(res, arr[0] + arr[1] - 1);
        return arr;
    }

作者：mmmmmJCY
链接：https://leetcode-cn.com/problems/binary-tree-longest-consecutive-sequence-ii/solution/java-di-gui-by-zxy0917-12/
```





# 551 Student Attendance Record I

<img src="501 - 600.assets/image-20210217092522404.png" alt="image-20210217092522404" style="zoom:50%;" />

```java
    public boolean checkRecord(String s) {
        int countA = 0;
        int left = 0, right = 0;
        while(right < s.length()){
            while(right < s.length() && s.charAt(right) != 'L'){
                if(s.charAt(right) == 'A')
                    countA++;
                right++;
            }

            if(right == s.length())
                break;
                
            left = right;
            while(right < s.length() && s.charAt(right) == 'L')
                right++;
            
            if(right - left >= 3)
                return false;
            
            left = right;
        }

        return countA <= 1;
    }
```









# 552 Student Attendance Record II



<img src="501 - 600.assets/image-20210218144459639.png" alt="image-20210218144459639" style="zoom:50%;" />

```java
/*
	超时： 通过14 / 68
	时间复杂度 O（3 ^N)
	
	
	解法就是把551的拿过来，用个回溯不断尝试
*/  
long count = 0;
    List<Character> list = new ArrayList<>();
    public int checkRecord(int n) {
        list.add('A');
        list.add('L');
        list.add('P');
        backtrack(new StringBuilder(), n);
        return (int) (count % (1000000000 + 7));
    }

    private void backtrack(StringBuilder path, int n) {
        if(path.length() == n){
            if(checkRecord(path.toString()))
                count++;
            
            return;
        }
      
        for(int i = 0; i < list.size(); i++){
            path.append(list.get(i));
            
            backtrack(path, n);
            
            path.setLength(path.length() - 1);
        }
    }

    public boolean checkRecord(String s) {
        int countA = 0;
        int left = 0, right = 0;
        while(right < s.length()){
            while(right < s.length() && s.charAt(right) != 'L'){
                if(s.charAt(right) == 'A')
                    countA++;
                right++;
            }

            if(right == s.length())
                break;

            left = right;
            while(right < s.length() && s.charAt(right) == 'L')
                right++;

            if(right - left >= 3)
                return false;

            left = right;
        }

        return countA <= 1;
    }

```



```java
/*
		采用O(N) 时间复杂度
		
		source : youtube.com/watch?v=06YtJdBG0rk
		
		定义 dp[i] = total number of rewardable student records with i len
			注意这里的dp 不包含 A
		
		分为几种情况
		首先计算 -> Without A	
			1）end with p， 如果当前i结尾的是P
				那无求所谓
				dp[i] = dp[i - 1]
			2）ends with L 如果当前 i 结尾的是 L
			  dp[i] = dp[i - 1] - dp[i - 4]
			  ...PLLL
		
		然后再计算含有 A的情况
		Assume A 的index是 i
		[....i - 1] A [i + 1.....]
		dp[i - 1] * dp[n - i]
		
		i + 1, N
		n - (i + 1) + 1
*/
public class Solution {
    long M = 1000000007;
    public int checkRecord(int n) {
        long[] f = new long[n <= 5 ? 6 : n + 1];
        f[0] = 1;
        f[1] = 2;
        f[2] = 4;
        f[3] = 7;
        for (int i = 4; i <= n; i++)
            f[i] = ((2 * f[i - 1]) % M + (M - f[i - 4])) % M;
        long sum = f[n];
        for (int i = 1; i <= n; i++) {
            sum += (f[i - 1] * f[n - i]) % M;
        }
        return (int)(sum % M);
    }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/student-attendance-record-ii/solution/xue-sheng-chu-qin-ji-lu-ii-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```









# 553 Optimal Division 很棒的 DP 题目



<img src="501 - 600.assets/image-20210219183039707.png" alt="image-20210219183039707" style="zoom:50%;" />



```java
/*
	O(n) 的时间复杂度，利用的是数学方法
	比如  a / b / c / d
	
	
*/
class Solution {
    public String optimalDivision(int[] nums) {
        if(nums.length == 1)
            return nums[0] + "";
        else if(nums.length == 2){
            return nums[0] + "/" + nums[1];
        }
        StringBuilder res = new StringBuilder();
        res.append(nums[0]).append("/(");

        for(int i = 1; i < nums.length; i++){
            res.append(nums[i]);
            if(i != nums.length - 1)
                res.append("/");
        }

        res.append(")");
        return res.toString();
    }
}
```





```java
    public String optimalDivision(int[] nums) {
        int len = nums.length;

        /*
            0 means max
            1 means min
        */
        double[][][] dp = new double[len][len][2];
        String[][][] res = new String[len][len][2];

        for(int i = 0; i < len; i++){
            dp[i][i][0] = nums[i];
            dp[i][i][1] = nums[i];
            res[i][i][0] = String.valueOf(nums[i]);
            res[i][i][1] = String.valueOf(nums[i]);            
        }

        for(int i = len - 2; i >= 0; i--){
            for(int j = i + 1; j < len; j++){
                StringBuilder maxString = new StringBuilder();
                StringBuilder minString = new StringBuilder();
                double maxNum           = Double.MIN_VALUE;
                double minNum           = Double.MAX_VALUE;

                for(int k = i; k < j; k++){
                    if(dp[i][k][0] / dp[k + 1][j][1] > maxNum){
                        maxString = new StringBuilder();
                        if(k + 1 == j){
                            maxString.append(res[i][k][0]).append("/").append(res[k + 1][j][0]);
                        }else{
                            maxString.append(res[i][k][0]).append("/(").append(res[k + 1][j][1]).append(")");
                        }

                        maxNum = dp[i][k][0] / dp[k + 1][j][1];
                    }

                    if(dp[i][k][1] / dp[k + 1][j][0] < minNum){
                        minString = new StringBuilder();
                        if(k + 1 == j){
                            minString.append(res[i][k][1]).append("/").append(res[k + 1][j][0]);
                        }else{
                            minString.append(res[i][j][1]).append("/(").append(res[k + 1][j][1]).append(")");
                        }

                        minNum = dp[i][k][1] / dp[k + 1][j][0];
                    }
                }

                dp[i][j][0] = maxNum;
                dp[i][j][1] = minNum;
                res[i][j][0] = maxString.toString();
                res[i][j][1] = minString.toString();
            }
        }


        return res[0][len - 1][0];
    }

```









# 554  Brick Wall

<img src="501 - 600.assets/image-20210219181555468.png" alt="image-20210219181555468" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210219182515831.png" alt="image-20210219182515831" style="zoom:50%;" />

```java
    public int leastBricks(List<List<Integer>> wall) {
                //position, number
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum = 0;
        for(int i = 0; i < wall.size(); i++){
            int pos = 0;

            for(int j = 0; j < wall.get(i).size(); j++){
                pos += wall.get(i).get(j);
                map.put(pos, map.getOrDefault(pos, 0) + 1);

                if(i == 0)
                    sum += wall.get(i).get(j);
            }
        }

        int res = Integer.MAX_VALUE;
        int len = wall.size();
        for(Integer pos : map.keySet()){
            if(sum == pos)
                continue;
            res = Math.min(res, len - map.get(pos));
        }

        return res == Integer.MAX_VALUE ? len : res;
    }
```





# 555 Split Concatenated Strings

<img src="501 - 600.assets/image-20210221184048266.png" alt="image-20210221184048266" style="zoom:50%;" />



```java
class Solution {
    public String splitLoopedString(String[] strs) {
        int len = strs.length;
        if(len<1) return "";
        
        //transform to max lexi order
        for(int i =0; i<strs.length; i++){
            String rev = new StringBuilder(strs[i]).reverse().toString();
            if(strs[i].compareTo(rev)<0) 
              strs[i] = rev;
        }
        
        String ans = "";
        char max = 'a';
        //try each str be the cut string, denote i 
        for(int i =0; i<strs.length; i++){
            String rev = new StringBuilder(strs[i]).reverse().toString();
            
            //try normal and reverse order for the target str i
            for(String s : new String[]{strs[i],rev}){
                
                //pick the index of the cut position in this str, denote j
                for(int j = 0 ; j < strs[i].length(); j++){
                    
                    // always start from the max one
                    if(s.charAt(j)<max)
                      continue;
                    else 
                      max = s.charAt(j);
                    
                    StringBuilder trys = new StringBuilder(s.substring(j));
                    for(int k = i+1; k < strs.length;k++){
                        trys.append(strs[k]);
                    }
                    for(int k = 0; k<i; k ++){
                        trys.append(strs[k]);
                    }
                    trys.append(s.substring(0,j));
                    if(trys.toString().compareTo(ans)>0) 
                      ans = trys.toString();
                }
                
            }

        }
        return ans;
    }
}
```













# 556 Next Greater Element III



<img src="501 - 600.assets/image-20210220144756643.png" alt="image-20210220144756643" style="zoom:50%;" />



<img src="501 - 600.assets/image-20210220151116851.png" alt="image-20210220151116851" style="zoom:50%;" />

```java
    public int nextGreaterElement(int n) {
        if((n + "").length() == 1)
            return -1;

        char[] chars = (n + "").toCharArray();

        int len = chars.length;
        int index = len - 1;

        while(index >= 1 && chars[index - 1] >= chars[index])
            index--;
        
        if(index == 0)
            return -1;
        
        int right        = index + 1;
        int exchNumIndex = index;
        while(right < len && chars[right] > chars[index - 1]){
            exchNumIndex = right;
            right++;
        }

        if(index == len - 1){
            exch(chars, index, index - 1);
            return parseInt(chars);
        }else{
            exch(chars, exchNumIndex, index - 1);
            Arrays.sort(chars, index, len);
        }

        int res = parseInt(chars);
        return res;
    }

    private int parseInt(char[] chars){
        int res   = 0;
        int index = 0;
        while(index < chars.length){
            int num = chars[index] - '0';
            if(res > Integer.MAX_VALUE / 10 || (res == Integer.MAX_VALUE / 10 && num > Integer.MAX_VALUE % 10))
                return -1;
            
            res *= 10;
            res += num;
            index++;
        }

        return res;
    }

    private void exch(char[] chars, int i, int j){
        char ch  = chars[i];
        chars[i] = chars[j];
        chars[j] = ch;
    }

    private void reverse(char[] chars){
        int left = 0, right = chars.length - 1;
        while(left < right){
            char temp = chars[left];
            chars[left] = chars[right];
            chars[right] = temp;

            left++;
            right--;
        }
    }
```















# 557  Reverse Words In a String III

<img src="501 - 600.assets/image-20210220131855208.png" alt="image-20210220131855208" style="zoom:50%;" />

```java

public String reverseWords(String s) {
        String[] temp = s.split(" ");

        StringBuilder res = new StringBuilder();
        for(int i = 0; i < temp.length; i++){
            res.append(new StringBuilder(temp[i]).reverse());
            if(i != temp.length - 1)
                res.append(" ");
        }
        
        return res.toString();
    }
```







# 558 Logical OR of Two Binary Grids Represented as Quad-Trees



<img src="501 - 600.assets/image-20210220154123075.png" alt="image-20210220154123075" style="zoom:50%;" />



```java
class Solution {
    public Node intersect(Node quadTree1, Node quadTree2) {
        if(quadTree1 == null || quadTree2 == null)
            return quadTree1 == null ? quadTree2 : quadTree1;
        
        /*
            1. deal with special cases

            2. general cases
        */

        if(quadTree1.isLeaf || quadTree2.isLeaf){
            if((quadTree1.isLeaf && quadTree2.isLeaf) || (quadTree1.isLeaf && quadTree1.val) || (quadTree2.isLeaf && quadTree2.val)  )
            return new Node(quadTree1.val | quadTree2.val, true, null, null, null, null);
        }


        Node res   = new Node();
        res.isLeaf = false;
        res.topLeft     = intersect(quadTree1.topLeft, quadTree2.topLeft);
        res.topRight    = intersect(quadTree1.topRight, quadTree2.topRight);
        res.bottomLeft  = intersect(quadTree1.bottomLeft, quadTree2.bottomLeft);
        res.bottomRight = intersect(quadTree1.bottomRight, quadTree2.bottomRight);

        int isLeaf = sumAll(res.topLeft.isLeaf, res.topRight.isLeaf, res.bottomLeft.isLeaf, res.bottomRight.isLeaf);
        int val    = sumAll(res.topLeft.val, res.topRight.val, res.bottomLeft.val, res.bottomRight.val);

        if(isLeaf == 4 && (val == 4 || val == 0)){
            res.isLeaf = true;
            res.val    = val == 4 ? true : false;
            res.topLeft = res.topRight = res.bottomRight = res.bottomLeft = null;
            return res;
        }

        return res;
    }

    private int sumAll(boolean a, boolean b, boolean c, boolean d){
        int i1 = a ? 1 : 0;
        int i2 = b ? 1 : 0;
        int i3 = c ? 1 : 0;
        int i4 = d ? 1 : 0;

        return i1 + i2 + i3 + i4;
    }
}


作者：jessenpan
链接：https://leetcode-cn.com/problems/logical-or-of-two-binary-grids-represented-as-quad-trees/solution/di-gui-cao-zuo-shuang-100-by-jessenpan/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```











# 559 Maximum Depth of N Ary Tree

<img src="501 - 600.assets/image-20210220163537564.png" alt="image-20210220163537564" style="zoom:50%;" />

```java
    public int maxDepth(Node root) {
        if(root == null)
            return 0;
        
        int maxDepth = 0;
        for(Node node : root.children)
            maxDepth = Math.max(maxDepth, maxDepth(node));
        
        return 1 + maxDepth;
    }
```





# 560 Subarray Sum Equals K

<img src="501 - 600.assets/image-20210221073156567.png" alt="image-20210221073156567" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210221073807394.png" alt="image-20210221073807394" style="zoom:50%;" />

```java
/*
		前缀和的典型应用
*/    
public int subarraySum(int[] nums, int k) {
        int len = nums.length;
        int[] prefixSum = new int[len];

        for(int i = 0; i < len; i++){
            if(i == 0)
                prefixSum[i] = nums[i];
            else
                prefixSum[i] = prefixSum[i - 1] + nums[i];
        }

        int count = 0;
        for(int i = -1; i < len; i++){
            for(int j = i + 1; j < len; j++){
                int subarraySum;

                if(i == -1)
                    subarraySum = prefixSum[j];
                else
                    subarraySum = prefixSum[j] - prefixSum[i];
                
                if(subarraySum == k)
                    count++;
            }
        }

        return count;
    }
```



```java
/*
		精彩解法， 空间换时间
			O(n) 时间复杂度
*/

public int subarraySum(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();

        int sum = 0;
  
  // 边界情况
        map.put(0, 1);
        int count = 0;
        for(int i = 0; i < nums.length; i++){
            sum += nums[i];

            if(map.containsKey(sum - k))    
                count += map.get(sum - k);

            map.put(sum, map.getOrDefault(sum, 0) + 1);
        }

        return count;
    }
```















# 561 Array partition I

<img src="501 - 600.assets/image-20210221065815958.png" alt="image-20210221065815958" style="zoom:50%;" />

```java
  //秒了
public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);

        int sum = 0;
        for(int i = 0; i < nums.length; i += 2)
            sum += nums[i];
        
        return sum;
    }
```





# 562 Longest Line of Consecutive One in Matrix DP 不错的应用

<img src="501 - 600.assets/image-20210221070513573.png" alt="image-20210221070513573" style="zoom:50%;" />

```java
    public int longestLine(int[][] M) {
        int row = M.length;
        int col = row == 0 ? 0 : M[0].length;

        //0 horizontal, 1 vertical, 2 main diagonal, 3 anti-diagonal
        int[][][] dp = new int[row][col][4];

        int res = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(M[i][j] == 0)
                    continue;
                
                for(int k = 0; k < 4; k++)
                    dp[i][j][k] = 1;
                
                //horizontal
                if(j > 0)
                    dp[i][j][0] += dp[i][j - 1][0];
                //vertical
                if(i > 0)
                    dp[i][j][1] += dp[i - 1][j][1];
                //main diagonal
                if(i > 0 && j > 0)
                    dp[i][j][2] += dp[i - 1][j - 1][2];
                //anti-diagonal
                if(i > 0 && j < col - 1)
                    dp[i][j][3] += dp[i - 1][j + 1][3];

                for(int k = 0; k < 4; k++)
                    res = Math.max(res, dp[i][j][k]);
            }
        }

        return res;
    }

作者：jyj407
链接：https://leetcode-cn.com/problems/longest-line-of-consecutive-one-in-matrix/solution/zhong-gui-zhong-ju-dong-tai-gui-hua-jie-tdskl/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







# 563 Binary Tre Tilt

<img src="501 - 600.assets/image-20210221070331996.png" alt="image-20210221070331996" style="zoom:50%;" />

```java
    int res = 0;
    public int findTilt(TreeNode root) {
        postOrder(root);
        return res;
    }

    /* return the sum of the root val*/
    private int postOrder(TreeNode root){
        if(root == null)
            return 0;

        int leftSum  = postOrder(root.left);
        int rightSum = postOrder(root.right);

        int total = leftSum + rightSum + root.val;
        root.val = Math.abs(leftSum - rightSum);
        
        res += root.val;

        return total;
    }
```







# 565 Array Nesting 并查集的典型应用

<img src="501 - 600.assets/image-20210222073406217.png" alt="image-20210222073406217" style="zoom:50%;" />

```java
/*
		通过 853 / 856 个案例
*/    
public int arrayNesting(int[] nums) {
        /*           //index ,       set of index
            HashMap<Integer, HashSet<Integer>> map = 
        */

        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();
        int len = nums.length;
        
        if(len == 0)
            return 0;
        
        int res = 1;
        for(int i = 0; i < len; i++){
            int index = nums[i];
            
            if(index >= len)
                continue;
            
            if(map.containsKey(index)){
                map.put(i, map.get(index));
                
                map.get(i).add(index);
                
                res = Math.max(map.get(i).size(), res);
            }else{
                map.put(i, new HashSet<Integer>());
                
                int j = i;
                HashSet<Integer> visited = new HashSet<>();
                while(j < len && !visited.contains(j)){
                    visited.add(j);
                    map.get(i).add(j);
                    
                    j = nums[j];
                }
            }
        }
        
        return res;
    }
```



```java
class Solution {
    public int arrayNesting(int[] nums) {
        int len = nums.length;
        if(len == 0)
            return 0;

        WeightedUnionFind wuf = new WeightedUnionFind(len);

        for(int i = 0; i < len; i++){
            wuf.union(i, nums[i]);
        }

        int res = 1;
        for(int i = 0; i < nums.length; i++)
            res = Math.max(wuf.sz[i], res);
        
        return res;
    }

}

class WeightedUnionFind{
    public int[] id;
    public  int[] sz;
    private int count;

    public WeightedUnionFind(int N){
        this.count = N;
        this.id    = new int[N];
        this.sz    = new int[count];
        for(int i = 0; i < count; i++){
            this.sz[i] = 1;
            this.id[i] = i;
        }
    }


    public boolean connected(int p, int q){
        return find(p) == find(q);
    }

    public int getCount(){
        return count;
    }

    private int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }

    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)
            return;

        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];

        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }
    }

}

```







# 566 Reshape the Matrix

<img src="501 - 600.assets/image-20210222073235172.png" alt="image-20210222073235172" style="zoom:50%;" />

```java
    public int[][] matrixReshape(int[][] nums, int r, int c) {
        int row= nums.length;
        int col = nums[0].length;
        
        if(row * col != r * c)
            return nums;
        
        int index = 0;
        int[][] res = new int[r][c];
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                res[index / c][index % c] = nums[i][j];
                index++;
            }
        }
        
        return res;
    }
```





# 567 Permutation in String

<img src="501 - 600.assets/image-20210613191527999.png" alt="image-20210613191527999" style="zoom:50%;" />

```java
    public boolean checkInclusion(String s1, String s2) {
        if(s1.length() > s2.length())
            return false;
        Map<Character, Integer> map = new HashMap<>();
        for(char ch : s1.toCharArray())
            map.put(ch, map.getOrDefault(ch, 0) + 1);

        Map<Character, Integer> map2 = new HashMap<>();
        for(int i = 0; i < s1.length(); i++)
            map2.put(s2.charAt(i), map2.getOrDefault(s2.charAt(i), 0) + 1);
        
        int index = s1.length();
        if(map2.equals(map))
            return true;
        
        while(index < s2.length()){
            char oldChar = s2.charAt(index - s1.length());
            char newChar = s2.charAt(index);

            map2.put(oldChar, map2.get(oldChar) - 1);
            if(map2.get(oldChar) == 0)
                map2.remove(oldChar);
            
            map2.put(newChar, map2.getOrDefault(newChar, 0) + 1);

            if(map2.equals(map))
                return true;
            
            index++;
        }

        return false;
    }
```







```java
    public boolean checkInclusion(String s1, String s2) {
        if(s1.length() > s2.length())
            return false;
        HashMap<Character, Integer> mapS1 = new HashMap<>();
        HashMap<Character, Integer> mapS2 = new HashMap<>();
        
        for(char ch : s1.toCharArray())
            mapS1.put(ch, mapS1.getOrDefault(ch, 0) + 1);
        
        
        int index = 0;
        for(int i = 0; i < s1.length(); i++, index++)        
            mapS2.put(s2.charAt(i), mapS2.getOrDefault(s2.charAt(i), 0) + 1) ;

    
        while(index < s2.length()){
            if(mapS1.equals(mapS2))
                return true;
            
            char before = s2.charAt(index - s1.length());
            char after  = s2.charAt(index);
            
            mapS2.put(before, mapS2.get(before) - 1);
            if(mapS2.get(before) == 0)
                mapS2.remove(before);
            mapS2.put(after, mapS2.getOrDefault(after, 0) + 1);
            
            index++;
        }
            
            
        return mapS1.equals(mapS2);
    }
```















# 572 Subtree of Another Tree 回看



<img src="501 - 600.assets/image-20210223155535835.png" alt="image-20210223155535835" style="zoom:50%;" />

```java
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if(t == null)
            return true;
        if(s == null)
            return false;
        
        return isSubtree(s.left, t) || isSubtree(s.right, t) || isSameTree(s, t);
    }
    
    private boolean isSameTree(TreeNode s, TreeNode t){
        if(s == null || t == null){
            if(s == null && t == null)
                return true;
            return false;
        }
        
        if(s.val != t.val)
            return false;
        
        return isSameTree(s.left, t.left) && isSameTree(s.right, t.right);
    }
```







# 573 Squirrel Simulation 不错的题目

<img src="501 - 600.assets/image-20210223165809302.png" alt="image-20210223165809302" style="zoom:50%;" />

```java
    public int minDistance(int height, int width, int[] tree, int[] squirrel, int[][] nuts) {

        int sum = 0;
        for(int[] nut : nuts){
            int diffX = Math.abs(nut[0] - tree[0]);
            int diffY = Math.abs(nut[1] - tree[1]);

            sum += diffX + diffY;
        }
        
        if(squirrel[0] == tree[0] && squirrel[1] == tree[1])
            return sum * 2;
        
        sum *= 2;
        int res = Integer.MAX_VALUE;
        for(int i = 0; i < nuts.length; i++){
            int diffXS2N = Math.abs(squirrel[0] - nuts[i][0]);
            int diffYS2N = Math.abs(squirrel[1] - nuts[i][1]);
            
            int diffXN2T = Math.abs(nuts[i][0] - tree[0]);
            int diffYN2T = Math.abs(nuts[i][1] - tree[1]);
            
            res = Math.min(res, sum + diffXS2N + diffYS2N - diffXN2T - diffYN2T);
        }
        
        return res;
    }
```







# 575 Distribute Candies

<img src="501 - 600.assets/image-20210223203541350.png" alt="image-20210223203541350" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210223204004369.png" alt="image-20210223204004369" style="zoom:50%;" />

```java
    public int distributeCandies(int[] candyType) {
        int count = 0;
        int left = 0, right = 0;
        int len = candyType.length;
        
        Arrays.sort(candyType);
        
        while(right < len){
            
            count++;
            while(right < len && candyType[right] == candyType[left])
                right++;
            
            if(right == len)
                break;
            
            left = right;
        }
        
        return count > len / 2 ? len / 2 : count;
    }
```





```java
//简单优化
public int distributeCandies(int[] candyType) {
        int count = 0;
        int len = candyType.length;
        
        HashSet<Integer> set = new HashSet<>();
        for(int num : candyType){
            set.add(num);
            
            if(set.size() >= len / 2)
                return len / 2;
        }

        
        return set.size() > len / 2 ? len / 2 : set.size();
    }
```







# 576 Out of Boundary Paths



<img src="501 - 600.assets/image-20210227152815225.png" alt="image-20210227152815225" style="zoom:50%;" />



```java
https://www.youtube.com/watch?v=92zh6XvqEgc
类似题目
  62 Unique Paths
  63 Unique Paths II
  688 Knight Probability
  
/*
想要求 从 i, j 到移出边界的步数
实际上，等价于 从边界到 i，j 步数的总和
	dp[N][i][j] means : the number of paths start from out of boundary to (i, j) by moving n steps
	dp[*][x][y] = 1 if(x, y is out of bound)
	dp[s][i][j] = dp[s - 1][i + 1][j]
	+ dp[s - 1][i - 1][j]
	+ dp[s - 1][i][j + 1]
	+ dp[s - 1][i][j - 1]
	
	ANS: dp[N][i][j]
*/
  public int findPaths(int m, int n, int N, int i, int j) {
    if(N == 0)
      return 0;

    int mod = 1000000007;

    int[][] dir = {{1, 0},{0, 1},{-1, 0},{0, -1}};
    int[][][] dp = new int[N + 1][m][n];
  
    for(int s = 1; s <= N; s++){
      for(int y = 0; y < m; y++){
        for(int x = 0; x < n; x++){
          for(int d = 0; d < 4; d++){
            int newX = x + dir[d][0];
            int newY = y + dir[d][1];

            if(newX < 0 || newY < 0 || newX >= n || newY >= m)
              dp[s][y][x] += 1;
            else 
              dp[s][y][x] = (dp[s][y][x] + dp[s - 1][newY][newX]) % mod;
          }
        }
      }
    }

    return dp[N][i][j];
}
```









# 581 Shorest Unsorted Continuous Subarray



<img src="501 - 600.assets/image-20210224090204969.png" alt="image-20210224090204969" style="zoom:50%;" />

```java
  /*
  		brute force
  */  
	public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        int[] newNums = Arrays.copyOf(nums,len);
        Arrays.sort(newNums);

        int left = 0, right = len - 1;

        for(int i = 0;  i < len; i++, left++)
            if(nums[i] != newNums[left])
                break;
        
        
        for(int i = len - 1; i >= 0; i--, right--)
            if(nums[i] != newNums[right])
                break;
        
        if(left >=  right)
            return 0;
        return right - left + 1;
    }
```





```java
/*
	本质上采用两个指针
	source : https://leetcode-cn.com/problems/shortest-unsorted-continuous-subarray/solution/shi-jian-chao-guo-100de-javajie-fa-by-zackqf/
	
	每次更新边界的值
*/   
public int findUnsortedSubarray(int[] nums) {
        int len = nums.length;
        
        int max = nums[0];
        int min = nums[len - 1];
        int l = 0, r = len - 1;
        
        for(int i = 0;  i < len; i++){
            if(max <= nums[i])
                max = nums[i];
            else
                l = i;
        }
        
        for(int j = len - 1; j >= 0; j--){
            if(min >= nums[j])
                min = nums[j];
            else
                r = j;
        }
        
        if(l == 0 && r == len - 1)
            return 0;
        return l - r + 1;
    }
```







# 582 Kill Process

<img src="501 - 600.assets/image-20210224074339028.png" alt="image-20210224074339028" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210224080430025.png" alt="image-20210224080430025" style="zoom:50%;" />

```java
class Solution {
    /*
        1. construct the tree
            1) get the root node

            2) go add them
        2. find the node we want to kill
        and it and its child into the result set
        return
    */

    List<Integer> res;
    public List<Integer> killProcess(List<Integer> pid, List<Integer> ppid, int kill) {

        res = new ArrayList<>();
        
        //quick find
        HashMap<Integer, Node> map = new HashMap<>();
        
        //constructing the tree
        Node root = null;
        for(int i = 0; i < pid.size(); i++){
            Node node = new Node(pid.get(i));
            map.put(pid.get(i), node);
                
            if(ppid.get(i) == 0)
                root = node;
        }
        
        for(int i = 0; i < ppid.size(); i++){
            Node parent = map.get(ppid.get(i));
            if(parent == null)
                continue;
            parent.children.add(map.get(pid.get(i)));
        }
        
        //go find it.
        preorder(root, kill);
        return res;
    }


    /*
     * this funciton is used to find the proceess ID that wants to kill
     * using preorder traversal method
     */
    private boolean preorder(Node root, int kill){
        if(root == null)
            return false;
        if(root.id == kill){
            addId(root);
            res.add(root.id);
            return true;
        }
        
       for(Node n : root.children){
          if(preorder(n, kill) == true)
              return true;
       }
        
        return false;
    }
    
    private void addId(Node root){
        if(root == null)
            return;
        
        for(Node node : root.children){
            addId(node);
            res.add(node.id);
        }
        
    }
}

class Node{
    public int id;
    public List<Node> children;
    
    public Node(int id){
        this.id = id;
        this.children = new ArrayList<>();
    }
}
```









# 583 Delete Operation For Two Strings

<img src="501 - 600.assets/image-20210224065916992.png" alt="image-20210224065916992" style="zoom:50%;" />

```java
    public int minDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();
        
        int[][] dp = new int[len1 + 1][len2 + 1];
        
        for(int i = 1; i < len1 + 1; i++)
            dp[i][0] = dp[i - 1][0] + 1;
        
        for(int j = 1; j < len2 + 1; j++)
            dp[0][j] = dp[0][j - 1] + 1;
        
        for(int i = 1; i < len1 + 1; i++){
            for(int j = 1; j < len2 + 1; j++){
                if(word1.charAt(i - 1) == word2.charAt(j - 1))
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    dp[i][j] = Math.min(dp[i - 1][j - 1] + 2, Math.min(dp[i - 1][j], dp[i][j - 1]) + 1);
            }
            
        }
        
        return dp[len1][len2];
    }
```









# 584 Find Customer Referee

<img src="501 - 600.assets/image-20210224065832883.png" alt="image-20210224065832883" style="zoom:50%;" />

```mysql
# Write your MySQL query statement below
SELECT name 
FROM customer
WHERE referee_id != 2 OR referee_id is NULL;
```





# 586 Customer Placing the Largest Number of Orders



```mysql
SELECT customer_number
FROM orders
GROUP BY customer_number
ORDER BY COUNT(*) DESC
LIMIT 1;

```





# 587 Erect the Rence



<img src="501 - 600.assets/image-20210225142201839.png" alt="image-20210225142201839" style="zoom:50%;" />

```java
/*
		一开始的思路
			比如拿到 leftmost, rightmost, upmost, downmost
			
			then 遍历每一个点，看看是谁谁在外面
*/
```







```java
/*
		source: https://github.com/Nideesh1/Algo/blob/master/leetcode/L_587.java
		
		总结下来四步
			1. 找到最左边的
			
			2. 每次找到 couter-clock-wise 作为下一个添加点
			
			3. 循环遍历，直到拿到答案
*/
class Solution {
    public int[][] outerTrees(int[][] points) {
        int n = points.length;
        
        if(n < 4 || onSmaeLine(points))
            return points;
        int l = 0;
        for(int i = 0; i < n; i++){
            if(points[l][0] > points[i][0])
                l = i;
        }

        List<int[]> list = new ArrayList<>();
        int p = l;

        do{
            list.add(points[p]);

            int q = (p + 1) % n;

            for(int i = 0;  i < n; i++){
                if(i != p && i != q && orientation(points[p],points[q],points[i]) == 1){
                    q = i;
                }
            }

            for(int i = 0; i < n; i++){
                if(i != p && i != q && onSeg(points[p],points[q],points[i]))
                    list.add(points[i]);
            }

            p = q;


        }while(p != l);

        int[][] res = new int[list.size()][2];
        for(int i = 0; i < list.size(); i++){
            res[i][0] = list.get(i)[0];
            res[i][1] = list.get(i)[1];
        }

        return res;
    }


    //is point r on the same segment forming by p and q?
    private boolean onSeg(int[] p, int[] q, int[] r){
        return r[0] >= Math.min(p[0], q[0]) && r[0] <= Math.max(p[0], q[0])
                && r[1] >= Math.min(p[1], q[1]) && r[1] <= Math.max(p[1], q[1])
                && orientation(p, q, r) == 0;
    }
    
    private boolean onSmaeLine(int[][] points){
        for(int i = 0; i < points.length - 2; i++){
            if(orientation(points[i], points[i + 1], points[i + 2]) != 0)
                return false;
        }
        
        return true;
    }

    //clock or couter-clock?
    //on couter-clock, 1
    //on clock 2
    private int orientation(int[] p, int[] q, int[] r) {
        int val = (r[0] - p[0]) * (q[1] - r[1]) - (r[1] - p[1]) * (q[0] - r[0]) ;

        if (val == 0)
            return 0;
        return val > 0 ? 1 : 2;
    }
}

```





# 589 N ary tree preorder traversal

<img src="501 - 600.assets/image-20210224093523213.png" alt="image-20210224093523213" style="zoom:50%;" />

```java
    List<Integer> res = new ArrayList<>();
    public List<Integer> preorder(Node root) {
        myPreorder(root);
        return res;
    }
    
    private void myPreorder(Node root){
        if(root == null)
            return;
        
        res.add(root.val);
        for(Node n : root.children)
            myPreorder(n);
    }
```







# 590 N Ary Tree Postorder Traversal



<img src="501 - 600.assets/image-20210224093629597.png" alt="image-20210224093629597" style="zoom:50%;" />

```java    List<Integer> res = new ArrayList<>();
    public List<Integer> postorder(Node root) {
        myPreorder(root);
        return res;
    }
    
    private void myPreorder(Node root){
        if(root == null)
            return;
        

        for(Node n : root.children)
            myPreorder(n);
        
        res.add(root.val);
    }
```







# 591 Tag Validator

<img src="501 - 600.assets/image-20210227151322102.png" alt="image-20210227151322102" style="zoom:50%;" />

```java

```







# 592 Fraction Addition and Subtraction

<img src="501 - 600.assets/image-20210226150714516.png" alt="image-20210226150714516" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210226155718994.png" alt="image-20210226155718994" style="zoom:50%;" />

```java
/*
    1. split using '+'

    2. for each one, 
    using hashMap to store the denominator

    3. convert with those who can be convert

    4. leave the part that cannot merge,
        for every one ,just take a common and return back
*/
class Solution {
    public String fractionAddition(String expression) {
        /*
            1. split using '+'

            2. for each one,
            using hashMap to store the denominator

            3. convert with those who can be convert

            4. leave the part that cannot merge,
                for every one ,just take a common and return back
        */

        int integerPart = 0;

//       to classify it into differnet category
        HashMap<Integer, Integer> map = getClassifiedString(expression);

        HashSet<String> remains = new HashSet<>();
        String begin = "0/1";

        for(Integer down : map.keySet()){
            int down1 = Integer.parseInt(begin.substring(begin.indexOf('/') + 1));
            int down2 = down;

            int commonDown = down1 * down2;
            int up1   = Integer.parseInt(begin.substring(0, begin.indexOf('/'))) * down2;
            int up2   = map.get(down) * down1;

            begin = (up1 + up2) + "/" + (commonDown);

            int upRes = Integer.parseInt(begin.substring(0, begin.indexOf('/')));
            int downRes = Integer.parseInt(begin.substring(begin.indexOf('/') + 1));


            begin = upRes + "/" + downRes;
        }

        int up   = Integer.parseInt(begin.substring(0, begin.indexOf('/')));
        int down = Integer.parseInt(begin.substring(begin.indexOf('/') + 1));

        while(true){
            boolean reduceable = false;
            for(int i = 2;  i <= 9; i++){
                if(up % i == 0 && down % i == 0){
                    up /= i;
                    down /= i;
                    reduceable = true;
                }
            }
            
            if(reduceable == false)
                break;
        }

        return up + "/" + down;
    }

    //              de      num
    public HashMap<Integer, Integer> getClassifiedString(String expression){
        int left = 0, right = 0;
        int len = expression.length();

        HashMap<Integer, Integer> map = new HashMap<>();
        while(right < len){
            while(right < len && expression.charAt(right) != '/')
                right++;

            int temp = right;
            while(right < len && (expression.charAt(right) != '+' && expression.charAt(right) != '-'))
                right++;

            int down =  Integer.parseInt(expression.substring(temp + 1, right));


            int up = Integer.parseInt(expression.substring(left, temp));
            if(map.containsKey(down)){
                int oldValue = map.get(down);
                oldValue += up;
                map.put(down, oldValue);
            }else
                map.put(down, up);

            left = right;
        }

        return map;
    }
}
```







# 593 Valid Square



<img src="501 - 600.assets/image-20210226142123349.png" alt="image-20210226142123349" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210226145357536.png" alt="image-20210226145357536" style="zoom:50%;" />

```java
    public boolean validSquare(int[] p1, int[] p2, int[] p3, int[] p4) {
        
        HashSet<String> set = new HashSet<>();
        int[][] points = new int[4][2];
        points[0][0] = p1[0];       set.add(p1[0] + "@" + p1[1]);
        points[0][1] = p1[1];
        points[1][0] = p2[0];       set.add(p2[0] + "@" + p2[1]);
        points[1][1] = p2[1];
        points[2][0] = p3[0];       set.add(p3[0] + "@" + p3[1]);
        points[2][1] = p3[1];
        points[3][0] = p4[0];       set.add(p4[0] + "@" + p4[1]);
        points[3][1] = p4[1];
        if(set.size() != 4)
            return false;
        
        for(int i = 0; i < points.length; i++){
            for(int j = 0; j < points.length; j++){
                if(j == i)
                    continue;
                for(int k = 0; k < points.length; k++){
                    if(k == j || k == i)
                        continue;
                    
                    if(isVertical(points[i], points[j], points[k])){
                        for(int m = 0; m < points.length; m++){
                            if(m == i || m == k || m == j)
                                continue;
                            
                            if(isVertical(points[i], points[m], points[k]) &&
                              isVertical(points[m], points[i], points[j]))
                                if(distance(points[i], points[j]) == distance(points[i], points[m]))
                                    return true;
                        }
                    }
                }
            }
        }
        
        return false;
    }
    
    private int distance(int[] p1, int[] p2){

        return (p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1] ) *(p1[1] - p2[1]);
    }
    /*
        to see if line p1p2 and p2p3 can be vertical
    */
    private boolean isVertical(int[] p1, int[] p2, int[] p3){
        return (p2[1] - p1[1]) * (p3[1] - p2[1]) + 
            (p2[0] - p1[0]) * (p3[0] - p2[0]) == 0;
    }
```













# 594 Longest Harmonious Subsequence

<img src="501 - 600.assets/image-20210225165851372.png" alt="image-20210225165851372" style="zoom:50%;" />

<img src="501 - 600.assets/image-20210226140750891.png" alt="image-20210226140750891" style="zoom:50%;" />

```java
    public int findLHS(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        
        for(int num : nums){
            map.put(num, map.getOrDefault(num, 0) + 1);
        }
        
        int res = 0;
        
        for(Integer num : map.keySet()){
            if(map.containsKey(num - 1))
                res = Math.max(res, map.get(num - 1) + map.get(num));
            
            if(map.containsKey(num + 1))
                res = Math.max(res, map.get(num + 1) + map.get(num));
        }
        
        return res;
    }
```







# 595 Big Countries

<img src="501 - 600.assets/image-20210226140235960.png" alt="image-20210226140235960" style="zoom:50%;" />

```java
# Write your MySQL query statement below
SELECT name, population, area
FROM World
WHERE area >= 3000000 OR population >= 25000000;
```





# 597 Friend Requests I

<img src="501 - 600.assets/image-20210227095927474.png" alt="image-20210227095927474" style="zoom:50%;" />

```mysql

```







# 598 Range Addition II

<img src="501 - 600.assets/image-20210223211629459.png" alt="image-20210223211629459" style="zoom:50%;" />

```java
    public int maxCount(int m, int n, int[][] ops) {
        if(ops.length == 0)
            return m * n;
    
        int[] row = new int[m];
        int[] col = new int[n];
        

        for(int[] op : ops){
            for(int i = 0; i < op[0]; i++)
                row[i]++;
            for(int j = 0; j < op[1]; j++)
                col[j]++;
        }
        
        int rowIndex = 0, colIndex = 0;
        while(rowIndex < m && row[rowIndex] == row[0])
            rowIndex++;
        while(colIndex < n && col[colIndex] == col[0])
            colIndex++;
        
        return rowIndex * colIndex;
    
    }
```



# 599



<img src="501 - 600.assets/image-20210223155352392.png" alt="image-20210223155352392" style="zoom:50%;" />

```java
    public String[] findRestaurant(String[] list1, String[] list2) {
        int len1 = list1.length;
        int len2 = list2.length;
        
        //      content, index
        HashMap<String, Integer> mapL2 = new HashMap<>();
        for(int i = 0; i < len2; i++)
            mapL2.put(list2[i], i);
        
        int minIndexSum = len1 + len2;
        
        int index1 = 0;
        HashSet<String> res = new HashSet<>();
        
        /**
         * go traverse the list1
         *   whenever we find one that exists in list2
         *   get the index for them and compare with the minIndexSum
         *  
         *   If it's smaller, clear the original result set and add new String
         */
        while(index1 < len1){
            String curRest = list1[index1];
            
            if(!mapL2.containsKey(curRest)){
                index1++;
                continue;
            }
            
            int index2 = mapL2.get(curRest);
            if(index1 + index2 > minIndexSum){
                index1++;
                continue;
            }else if(index1 + index2 == minIndexSum){
                index1++;
                res.add(curRest);
                continue;
            }else{
                res.clear();
                minIndexSum = index1 + index2;
                index1++;
              
                res.add(curRest);
            }
        }
        
        //form the answer
        String[] ans = new String[res.size()];
        int index = 0;
        for(String str : res)
            ans[index++] = str;
        
        return ans;
        
    }
```









# 600 Non-negative Integers without Consecutive Ones

<img src="501 - 600.assets/image-20210227095957919.png" alt="image-20210227095957919" style="zoom:50%;" />

```java
/*
		source: https://leetcode.com/problems/non-negative-integers-without-consecutive-ones/discuss/103754/C%2B%2B-Non-DP-O(32)-Fibonacci-solution
*/    
		public int findIntegers(int num) {  
        int[] dp = new int[32];
        dp[0] = 1;
        dp[1] = 2;
        
        for(int i = 2; i < 32; i++)
            dp[i] = dp[i - 1] + dp[i - 2];
        
        String numStr = getBinary(num);
        
        int res = 0;
        for(int i = 0; i < numStr.length(); i++){
            if(numStr.charAt(i) == '0')
                continue;
            
            res += dp[numStr.length() - i - 1];
            if(i != 0 && numStr.charAt(i - 1) == '1')
                return res;
        }
        
        return res + 1;
    }
    
    private String getBinary(int num){
        StringBuilder sb = new StringBuilder();
        
        while(num > 0){
            sb.insert(0, num & 1);
            num >>= 1;
        }
        
        return sb.toString();
    }
```

