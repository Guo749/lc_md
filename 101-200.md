# 101-200

# leecode 101-150



# 101 Symmetric Tree



<img src="101-200.assets/image-20201223145234117.png" alt="image-20201223145234117" style="zoom:50%;" />

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root == null)        return true;

        return isSymmetric(root.left, root.right) ;
    }

    public boolean isSymmetric(TreeNode node1, TreeNode node2){

        if(node1 == null || node2 == null){
            if(node1 != null || node2 != null)
                return false;
            return true;
        }

        if(node1.val != node2.val) return false;

        return isSymmetric(node1.left, node2.right) 
            && isSymmetric(node1.right, node2.left);
    }
}
```





<img src="/Users/wenchaoguo/Desktop/Algorithm-Related/01_leecode/01_leecode RecordCollection/FollowedByNumber/101-200.assets/image-20201021153016537.png" alt="image-20201021153016537" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root == NULL)
            return true;

        return isSymmetric(root->left, root->right);
    }

    bool isSymmetric(TreeNode * left, TreeNode * right){
        if(left == NULL && right == NULL){
            return true;
        }

        if((left == NULL || right == NULL) || (left->val != right->val)){
            return false;
        }

        return isSymmetric(left->left, right->right) && isSymmetric(left->right, right->left);
    }
};
```



<img src="/Users/wenchaoguo/Desktop/Algorithm-Related/01_leecode/01_leecode RecordCollection/FollowedByNumber/101-200.assets/image-20201021171013057.png" alt="image-20201021171013057" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool checkNode(TreeNode * left, TreeNode * right){
        if((left == NULL && right == NULL))
            return true;

        if(left == NULL || right == NULL)
            return false;
        
        return left->val == right->val;
    }

    bool isSymmetric(TreeNode * root) {
        if(root == NULL){
            return true;
        }
        deque<TreeNode *> * dq = new deque<TreeNode *>();
        dq->push_back(root);

        bool flag = true;

        while(dq->size() != 0){
            if(flag){
                flag = false;
                TreeNode * cur =  dq->back();
                dq->pop_back();
                if(checkNode(cur->left, cur->right) == false)
                    return false;
                dq->push_front(cur->left);
                dq->push_back(cur->right);
                
            }else{
                TreeNode * left = dq->front();
                TreeNode * right = dq->back();
                dq->pop_back();
                dq->pop_front();

                if(checkNode(left, right) == false)
                    return false;

                if(left == NULL && right == NULL)  
                     continue;

                dq->push_front(left->left);
                dq->push_back(right->right);
            

                dq->push_front(left->right);
                dq->push_back(right->left);
                }
            }
        

        return true; 
    }
};
```







# 103 Binary Tree Zigzag Level Order Traversal

<img src="101-200.assets/image-20210518165444168.png" alt="image-20210518165444168" style="zoom:50%;" />

```go
func zigzagLevelOrder(root *TreeNode) [][]int {
	res := make([][] int, 0)

	queue := make([]*TreeNode, 0)
	if root == nil{
		return res
	}
	queue = append(queue, root)
	odd   := true
	for ;len(queue) != 0;{
		size := len(queue)
		temp := make([]int, 0)
		for i := 0; i < size; i++{
			cur := queue[0]
			queue = queue[1:]

			temp = append(temp, cur.Val)
			if cur.Left != nil{
				queue = append(queue, cur.Left)
			}

			if cur.Right != nil{
				queue = append(queue, cur.Right)
			}
		}

		if !odd{
			for i, j := 0, len(temp) - 1; i < j;{
				temp[i], temp[j] = temp[j], temp[i]
                i++
                j--
			}
		}
		odd = !odd
		res = append(res, temp)
	}
	
	return res
}
```





# 104 Maximum Depth of Binary Tree

<img src="101-200.assets/image-20201223145424685.png" alt="image-20201223145424685" style="zoom:50%;" />

```java
    public int maxDepth(TreeNode root) {
        return root == null ? 0 : (1 + Math.max(maxDepth(root.left), maxDepth(root.right)));
    }
```













# 105 Construct Binary Tree From Preorder and Inorder Traversal



![image-20200709083428234](101-200.assets/image-20200709083428234.png)



<img src="101-200.assets/image-20201223150056866.png" alt="image-20201223150056866" style="zoom:50%;" />

```java
  public TreeNode buildTree(int[] preorder, int[] inorder) {
        if(preorder.length == 0)    return null;
        assert(preorder.length == inorder.length);

        int i = 0;
        for(; i < inorder.length; i++)
            if(inorder[i] == preorder[0])
                break;

        int[] preLeft  = Arrays.copyOfRange(preorder, 1, i + 1);
        int[] preRight = Arrays.copyOfRange(preorder, i + 1, preorder.length);
        int[] inLeft   = Arrays.copyOfRange(inorder, 0, i);
        int[] inRight  = Arrays.copyOfRange(inorder, i + 1, inorder.length);
        
        TreeNode root = new TreeNode(preorder[0]);
        
        root.left  = buildTree(preLeft, inLeft);
        root.right = buildTree(preRight, inRight);
        
        return root;
    }
```







```java
/*
	这个递归写的蛮漂亮的
*/
class Solution {
	public TreeNode buildTree(int[] preorder, int[] inorder) {
		if(preorder.length==0 || inorder.length==0) {
			return null;
		}
		//根据前序数组的第一个元素，就可以确定根节点
		TreeNode root = new TreeNode(preorder[0]);
        
		for(int i=0;i<preorder.length;++i) {
			//用preorder[0]去中序数组中查找对应的元素
			if(preorder[0]==inorder[i]) {
				//将前序数组分成左右两半，再将中序数组分成左右两半
				//之后递归的处理前序数组的左边部分和中序数组的左边部分
				//递归处理前序数组右边部分和中序数组右边部分
				int[] pre_left = Arrays.copyOfRange(preorder,1,i+1);
				int[] pre_right = Arrays.copyOfRange(preorder,i+1,preorder.length);
				int[] in_left = Arrays.copyOfRange(inorder,0,i);
				int[] in_right = Arrays.copyOfRange(inorder,i+1,inorder.length);
				root.left = buildTree(pre_left,in_left);
				root.right = buildTree(pre_right,in_right);
				break;
			}
		}
		return root;
	}
}

作者：wang_ni_ma
链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/dong-hua-yan-shi-105-cong-qian-xu-yu-zhong-xu-bian/
```





# 106 Construct Binary Tree From Inorder And Postorder

![image-20200709090329852](101-200.assets/image-20200709090329852.png)

![image-20200709091106936](101-200.assets/image-20200709091106936.png)



<img src="101-200.assets/image-20201223150846043.png" alt="image-20201223150846043" style="zoom:50%;" />

```java

class Solution {
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        if(postorder.length == 0)    return null;
        //assert(preorder.length == inorder.length);

        int i = 0;
        for(; i < inorder.length; i++)
            if(inorder[i] == postorder[postorder.length - 1])
                break;

        int[] postLeft   = Arrays.copyOfRange(postorder, 0, i);
        int[] postRight  = Arrays.copyOfRange(postorder, i, postorder.length - 1);
        int[] inLeft     = Arrays.copyOfRange(inorder, 0, i);
        int[] inRight    = Arrays.copyOfRange(inorder, i + 1, inorder.length);

        TreeNode root = new TreeNode(postorder[postorder.length - 1]);

        root.left  = buildTree(inLeft, postLeft);
        root.right = buildTree(inRight, postRight);

        return root;
    }
}
```





```java
/*
	和上一个题，异曲同工之秒
*/
public TreeNode buildTree(int[] inorder, int[] postorder) {
    if(inorder.length == 0 || postorder.length == 0)
        return null;

    TreeNode root = new TreeNode(postorder[postorder.length-1]);

    for(int i = 0; i < postorder.length; i++)
    {
        if(postorder[postorder.length-1] == inorder[i])
        {
            int[] in_left = Arrays.copyOfRange(inorder,0,i);
            int[] in_right = Arrays.copyOfRange(inorder, i+1,inorder.length);
            int[] po_left = Arrays.copyOfRange(postorder, 0,i);
            int[] po_right = Arrays.copyOfRange(postorder,i,postorder.length-1);

            root.left = buildTree(in_left, po_left);
            root.right = buildTree(in_right, po_right);
            break;
        }
    }
    return root;
}
```



# 108 Convert Sorted Array To BST

![image-20200709091211683](101-200.assets/image-20200709091211683.png)

![image-20200709092444859](101-200.assets/image-20200709092444859.png)

```java
public TreeNode sortedArrayToBST(int[] nums) {
    if(nums.length == 0)        return null;
    if(nums.length == 1)          return new TreeNode(nums[0]);

    int mid = nums.length / 2;
    TreeNode root = new TreeNode(nums[mid]);

    int[] left_part = Arrays.copyOfRange(nums, 0, mid);
    int[] right_part = Arrays.copyOfRange(nums, mid+1, nums.length);
    root.left = sortedArrayToBST(left_part);
    root.right = sortedArrayToBST(right_part);

    return root;
}
```







# 109 Convert Sorted List to Binary Search Tree





<img src="101-200.assets/image-20201223152900181.png" alt="image-20201223152900181" style="zoom:50%;" />

```java
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        return helper(head, null);
    }

    public TreeNode helper(ListNode head, ListNode tail){
        if(head == tail)                    return null;
        if(head.next == tail)               return new TreeNode(head.val);

        ListNode slow = head;
        ListNode fast = head;

        while(fast != tail && fast.next != tail){
            fast = fast.next.next;
            slow = slow.next;
        }

        TreeNode root = new TreeNode(slow.val);

        root.left  = helper(head, slow);
        root.right = helper(slow.next, tail);

        return root;
    }
}

```





# 110 Balanced Binary Tree



<img src="101-200.assets/image-20201223153231638.png" alt="image-20201223153231638" style="zoom:50%;" />

```java
/*
	注意这里拿的一定是最大深度
*/
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null)    return true;

        return Math.abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 &&
            isBalanced(root.left) && isBalanced(root.right);
    }

    public int maxDepth(TreeNode root){
        return root == null ? 0 : (1 + Math.max(maxDepth(root.left), maxDepth(root.right)));
    }
}
```





# 111 Minimum Depth of Binary Tree

<img src="101-200.assets/image-20201223153714410.png" alt="image-20201223153714410" style="zoom:50%;" />

<img src="101-200.assets/image-20201223153707592.png" alt="image-20201223153707592" style="zoom:50%;" />

```java
    public int minDepth(TreeNode root) {
        if(root == null)                            return 0;
        if(root.left == null || root.right == null){
            if(root.left == null && root.right == null)
                return 1;
            else
                return 1 + (root.left == null ? minDepth(root.right) : minDepth(root.left));
        }

        return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    }
```







```cpp
/*
		BFS 方法
*/
class Solution {
public:
    int minDepth(TreeNode *root) {
        if (root == nullptr) {
            return 0;
        }

        queue<pair<TreeNode *, int> > que;
        que.emplace(root, 1);
      
        while (!que.empty()) {
            TreeNode *node = que.front().first;
            int depth = que.front().second;
            que.pop();
            if (node->left == nullptr && node->right == nullptr) {
                return depth;
            }
            if (node->left != nullptr) {
                que.emplace(node->left, depth + 1);
            }
            if (node->right != nullptr) {
                que.emplace(node->right, depth + 1);
            }
        }

        return 0;
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/solution/er-cha-shu-de-zui-xiao-shen-du-by-leetcode-solutio/
```





# 112 Path Sum

<img src="101-200.assets/image-20201223162131259.png" alt="image-20201223162131259" style="zoom:50%;" />

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210510164754716.png" alt="image-20210510164754716" style="zoom:50%;" />

```java
//二刷 狗
	public boolean hasPathSum(TreeNode root, int targetSum) {
        return getRes(root, targetSum);
    }
    
    public boolean getRes(TreeNode root, int remains){
        if(root == null)
            return false;
        else if(root.left == null && root.right == null){
            if(root.val == remains)
                return true;
            else
                return false;
        }
        
        if(getRes(root.left, remains - root.val) ||
            getRes(root.right, remains - root.val))
            return true;
        
        return false;
    }
```



<img src="101-200.assets/image-20201223162124439.png" alt="image-20201223162124439" style="zoom:50%;" />



```java
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null)                            return false;
        if(root.left == null && root.right == null) return root.val == sum;

        return dfs(root, sum);
    }

    public boolean dfs(TreeNode root, int remains){
        if(remains == 0){
            if(root == null)
                return true;
        }
        if(root == null)        return false;

        if(root.left == null && root.right == null)
            return remains - root.val == 0;

        boolean l = false;
        if(root.left != null)
            l = dfs(root.left, remains - root.val);
        boolean r = false;
        if(root.right != null)
            r = dfs(root.right, remains - root.val);

        return l || r;
    }
```



```java
//这个思路不错
public class Solution {
    public boolean hasPathSum(TreeNode root, int sum) {
        if(root == null){
            return false;
        }
        if(root.left == null && root.right == null){
            return root.val == sum;
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
        
    }
}

作者：fuxuemingzhu
链接：https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





# 113 Path Sum II 回溯不错的题目

<img src="101-200.assets/image-20201223164818174.png" alt="image-20201223164818174" style="zoom:50%;" />

<img src="101-200.assets/image-20201223164810563.png" alt="image-20201223164810563" style="zoom:50%;" />

```java


class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        if(root == null)        return res;

        dfs(new ArrayList<>(), sum, root);
        return res;
    }

    public void dfs(List<Integer> path, int remains, TreeNode root){
        if(root == null)    return;

        if(remains == root.val && root.left == null && root.right == null){
            path.add(root.val);
            res.add(new ArrayList<>(path));
            path.remove(path.size() - 1);  /*注意回溯过程中及时移除元素*/
            return;
        }

        path.add(root.val);
        dfs(path, remains - root.val, root.left);
        dfs(path, remains - root.val, root.right);
        path.remove(path.size() - 1);
  
    }
}

```







# 114 Flatten Binary Tree to Linked List

<img src="101-200.assets/image-20201223165859931.png" alt="image-20201223165859931" style="zoom:50%;" />

```java
class Solution {
    public void flatten(TreeNode root) {
        if(root == null)        return;

        TreeNode temp = root.left;
        root.left     = root.right;
        root.right    = temp;

        TreeNode cur = root;
        while(cur.right != null)
            cur = cur.right;
        
        cur.right = root.left;
        root.left = null;

        flatten(root.right);
    }
}

    1
   / \
  2   5
 / \   \
3   4   6

//将 1 的左子树插入到右子树的地方
    1
  /   \
 5     2         
   \   / \         
    6  3   4                 
//将原来的右子树接到左子树的最右边节点
    1
     \
      2          
     / \          
    3   4  
         \
          5
           \
            6
            
 //将 2 的左子树插入到右子树的地方
    1
     \
      2          
       \          
        3       4  
                 \
                  5
                   \
                    6   
        
 //将原来的右子树接到左子树的最右边节点
    1
     \
      2          
       \          
        3      
         \
          4  
           \
            5
             \
              6         
  
```





# 116 / 117 Populating Next Pointers in Each Node



![image-20201224164714119](101-200.assets/image-20201224164714119.png)

```java
class Solution {
    public Node connect(Node root) {
        if(root == null)    return null;
        Deque<Node> queue = new ArrayDeque<>();

        queue.add(root);

        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                Node cur = queue.pollFirst();
                if(i == size - 1)
                    cur.next = null;
                else
                    cur.next = queue.peekFirst();
                
                if(cur.left != null)
                    queue.add(cur.left);
                if(cur.right != null)
                    queue.add(cur.right);
            }
        }

        return root;
    }
}
```







# 118 Pascal's Triangle

![image-20200709092625134](101-200.assets/image-20200709092625134.png)

![image-20200709093709634](101-200.assets/image-20200709093709634.png)

```java
/*
[
	[1],
	[1,1],
	[1,2,1],
	[1,3,3,1],
	[1,4,6,4,1]
]
*/
public List<List<Integer>> generate(int numRows) {
    List<List<Integer>> res = new ArrayList<>();

    for(int i = 0; i < numRows; i++)
    {
        List<Integer> path = new LinkedList<>();
        for(int j = 0; j < i+1; j++)
        {
            if(j == 0 || j == i || i == 0)
                path.add(1);
            else
                path.add(res.get(i-1).get(j) + res.get(i-1).get(j-1));
        }
        res.add(path);
    }
    return res;
}
```





# 119 Pascal's Triangle II

![image-20200709093744429](101-200.assets/image-20200709093744429.png)

![image-20210512172105901](/Users/admin/Library/Application Support/typora-user-images/image-20210512172105901.png)

```go
func getRow(rowIndex int) []int {
	res := make([]int, 0)

	if rowIndex == 0{
		res = append(res, 1)
		return res
	}else if rowIndex == 1{
		res = append(res, 1)
		res = append(res, 1)
		return res
	}

	temp := make([]int, 0)
	temp = append(temp, 1)
	temp = append(temp, 1)

	for i := 2; i <= rowIndex; i++{
		res = append(res, 1)

		for j := 0; j < len(temp) - 1; j++{
			t := temp[j] + temp[j + 1]
			res = append(res, t)
		}

		res = append(res, 1)

		temp = make([]int, len(res))
		copy(temp, res)
		res = res[:0]
	}

	return temp
}
```





```java
/*
	笨办法，拿到所有行，返回最后一行
*/
public List<Integer> getRow(int rowIndex) {
    List<List<Integer>> res = new ArrayList<>();

    for(int i = 0; i <= rowIndex; i++)
    {
        List<Integer> path = new LinkedList<>();
        for(int j = 0; j < i+1; j++)
        {
            if(j == 0 || j == i || i == 0)
                path.add(1);
            else
                path.add(res.get(i-1).get(j) + res.get(i-1).get(j-1));
        }
        res.add(path);
    }
    return res.get(rowIndex);
}
```



```java
/*
	动态规划
*/
public List<Integer> getRow(int rowIndex) {
    List<Integer> list = new ArrayList<>();
    while (rowIndex-- >= 0) {
        list.add(1);
        //原地更新，属实牛逼
        for (int i = list.size() - 2; i > 0; i--) 
            list.set(i, list.get(i) + list.get(i - 1));
    }

    return list;
}
https://leetcode-cn.com/problems/pascals-triangle-ii/solution/119yang-hui-san-jiao-ii-dong-tai-gui-hua-by-ceng-j/
```



# 120 Triangle

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210512180703612.png" alt="image-20210512180703612" style="zoom:50%;" />

```go
func minimumTotal(triangle [][]int) int {
	row := len(triangle)
	
	for i := row - 2; i >= 0; i--{		
		for j := 0; j < len(triangle[i]); j++{
			triangle[i][j] = min(triangle[i + 1][j], triangle[i + 1][j + 1]) + triangle[i][j]	
		}
	}
	
	return triangle[0][0]
}

func min(a int, b int) int{
	if a < b{
		return a
	}
	
	return b
}
```



![image-20200907162241809](101-200.assets/image-20200907162241809.png)

```java
/*
	典型DP
*/
    public int minimumTotal(List<List<Integer>> triangle) {
        if(triangle.size() == 0)        return 0;
        int[][] dp = new int[triangle.size()][triangle.get(triangle.size() - 1).size()];
        for(int k = 0; k < triangle.get(triangle.size() - 1).size(); k++)
            dp[triangle.size() - 1][k] = triangle.get(triangle.size() - 1).get(k);
        for(int i = triangle.size() - 2; i >= 0; i--)
        {
            for(int j = 0; j < triangle.get(i).size(); j++)
            {
                if(j == 0)
                    dp[i][j] = Math.min(dp[i + 1][j], dp[i+1][j+1]) + triangle.get(i).get(j);
                else    
                    dp[i][j] = Math.min(dp[i+1][j], dp[i+1][j+1]) + 
                        triangle.get(i).get(j);
            }
        }


        return dp[0][0];
    }
```



# 124 Binary Tree Maximum Path Sum

![image-20200709095941949](101-200.assets/image-20200709095941949.png)



```java
/*
	全局变量和递归结合的题目
	
	对这个题做一个深度剖析
*/
class Solution {
    int max = Integer.MIN_VALUE;
    public int maxPathSum(TreeNode root) {
        helper(root);
        return max;
    }

  //该函数返回的是包含当前节点的最大单边路径
    private int helper(TreeNode root)
    {
        if(root == null)        return 0;
        
        int left = Math.max(helper(root.left)  , 0);
        int right = Math.max(helper(root.right), 0);

      	//这里更新 包含横跨我们root 的max 路径， 包含左右
        max = Math.max(max, root.val + left + right);

      		//这里返回单边路径
        return root.val + Math.max(left, right);
    }
}
```





# 125 Valid Palindrome

![image-20200709135751595](101-200.assets/image-20200709135751595.png)

![image-20200709142231955](101-200.assets/image-20200709142231955.png)

```java
public boolean isPalindrome(String s) {
    char[] chars = s.toCharArray();
    HashSet<Character> set = new HashSet<>();
    HashSet<Character> SET = new HashSet<>();
    for(char ch = 'a'; ch <= 'z'; ch++)
        set.add(ch);
    for(char ch = '0'; ch <= '9'; ch++)
        set.add(ch);
    for(char ch = 'A'; ch <= 'Z'; ch++)
        SET.add(ch);

    int left = 0;
    int right = chars.length-1;

    while(left < right)
    {
        while(left <= right && !set.contains(chars[left]) && !SET.contains(chars[left]))
            left++;
        while(left <= right && !set.contains(chars[right]) && !SET.contains(chars[right]))
            right--;

        if(left >= right)    break;

        if(SET.contains(chars[left]))
            chars[left] += 32;
        if(SET.contains(chars[right]))
            chars[right] += 32;

        if(chars[right] != chars[left])
            return false;
        left++;
        right--;
    }
    return true;
}
```



# 126 Word ladder II 回溯 + bfs综合



```java
class Solution {
    List<List<String>> graph = new ArrayList<>();
    List<List<String>> res = new ArrayList<>();
    HashSet<String> marked = new HashSet<>();
    
    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
        if(!wordList.contains(endWord))
            return res;
        wordList.remove(beginWord);
        HashSet<String> wordSet = new HashSet<>();
        wordSet.addAll(wordList);

        ArrayDeque<String> queue = new ArrayDeque<>();
        queue.addLast(beginWord);
        graph = construcGraph(queue, wordSet);
        List<String> path =  new ArrayList<>();
        path.add(beginWord);

        backtrack(beginWord, endWord, path, 0);

        return res;
    }

    private void backtrack(String beginWord, String endWord, List<String> path, int level)
    {
        if(beginWord.equals(endWord))
        {
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; level < graph.size() && i < graph.get(level).size(); i++)
        {
            String s = graph.get(level).get(i);
            if(!isDifOne(s, path.get(path.size()-1)))
                continue;
            path.add(s);

            backtrack(s, endWord, path, level+1);

            path.remove(path.size()-1);
        }

    }

    private boolean isDifOne(String a, String b) {
        int count = 0;
        for(int i = 0; i < a.length(); i++)
            if(a.charAt(i) != b.charAt(i))
                count++;
        return  count == 1;
    }

    private List<List<String>> construcGraph(ArrayDeque<String> queue, HashSet<String> wordList)
    {
        while(!queue.isEmpty())
        {
            int size = queue.size();
            List<String> path = new ArrayList<>();

            for(int i = 0; i < size; i++)
            {
                String temp = queue.removeFirst();
                path.add(temp);
                char[] chars = temp.toCharArray();
                for(int j = 0; j < chars.length; j++)
                {
                    char ch = chars[j];
                    for(char c = 'a'; c <= 'z'; c++)
                    {
                        if(c == ch)
                            continue;
                        chars[j] = c;
                        String cs = toStr(chars);
                        if(wordList.contains(cs) && !marked.contains(cs))
                        {
                            queue.addLast(cs);
                            marked.add(cs);
                        }
                    }
                    chars[j] = ch;
                }
            }
            graph.add(path);
        }
        graph.remove(0);
        return graph;
    }

    private String toStr(char[] chars)
    {
        StringBuilder sb = new StringBuilder();
        for(char ch : chars)
            sb.append(ch);
        return sb.toString();
    }

}

作者：venturekwok
链接：https://leetcode-cn.com/problems/word-ladder-ii/solution/java-jie-gou-qing-xi-shi-pin-jiang-jie-zhu-yao-zhi/
```



# 128 Longest Consecutive Sequence

![image-20200709143315945](101-200.assets/image-20200709143315945.png)





![image-20200709144932605](101-200.assets/image-20200709144932605.png)

方法二：

```java
/*哈希表的value存什么
key存数字，value存什么？
新存入的数字，如果它找到相邻的数，它希望从邻居数那里获取什么信息？
很显然它希望，左邻居告诉它左边能提供的连续长度，右邻居告诉它右边能提供的连续长度
加上它自己的长度，就有了自己处在的连续序列的长度

作者：hyj8
链接：https://leetcode-cn.com/problems/longest-consecutive-sequence/solution/fang-fa-cong-yi-dao-nan-bing-cha-ji-fang-fa-bu-hui/
*/

/*
	这是动态规划的方法，注意理解
*/
public int longestConsecutive(int[] nums) 
{
	HashMap<Integer, Integer> map = new HashMap<>();
    int max = 0;
    for(int num : nums)
    {
        if(!map.containsKey(num))
        {
            int preLen = map.get(num-1) == null ? 0 : map.get(num-1);
            int nextLen = map.get(num+1) == null ? 0 : map.get(num+1);
            int curLen = preLen + 1 + nextLen;
            map.put(num, curLen);
            max = Math.max(max, curLen);
            map.put(num - preLen, curLen);		//对序列左边进行更新
            map.put(num + nextLen, curLen);		//对序列右边进行更新
        }
    }
    return max;
}
```

![image-20200709150805396](101-200.assets/image-20200709150805396.png)

可以看到，运行后，map 连续序列中只记录两边的，并不断更新，而该序列比如1,2,3,4,等的值并没有同样更新为6







# 129 Sum Root to Leaf Numbers



<img src="101-200.assets/image-20201224172710163.png" alt="image-20201224172710163" style="zoom:50%;" />



```java
/*
		整体思路采用回溯，
		
		记得在每一步都进行 
				做出选择
				进入回溯
				撤销选择
			包括在特殊判定部分
*/
class Solution {
    int res = 0;
    public int sumNumbers(TreeNode root) {
        dfs(root, new StringBuilder());
        return res;
    }

    private void dfs(TreeNode root, StringBuilder path){
        if(root == null)    return;
        if(root.left == null && root.right == null){
            path.append(root.val);
            res += Integer.parseInt(path.toString());
             path.setLength(path.length() - 1);
            return;
        }

        path.append(root.val);

        dfs(root.left , path);
        dfs(root.right, path);

        path.setLength(path.length() - 1);
    }
}
```











# 130 Surrounded Regions



<img src="101-200.assets/image-20201224173735719.png" alt="image-20201224173735719" style="zoom:50%;" />



```java
class Solution {
    int row =  0;
    int column = 0;
    public void solve(char[][] board) {
        row = board.length;
        column = row == 0 ? 0 : board[0].length;
        if(column == 0)     return;

        for(int i = 0; i < row; i++){
            dfs(board, i, 0);
            dfs(board, i, column - 1);
        }

        for(int j = 0; j < column; j++){
            dfs(board, 0, j);
            dfs(board, row - 1, j);
        }

        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(board[i][j] == '@')
                    board[i][j] = 'O';
                else
                    board[i][j] = 'X';
            
    }

    private boolean isInRange(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < column;
    }

    public void dfs(char[][] board, int i, int j){
        if(isInRange(i, j) && board[i][j] == 'O'){
            board[i][j] = '@';

            dfs(board, i + 1, j);
            dfs(board, i - 1, j);
            dfs(board, i, j + 1);
            dfs(board, i, j - 1);
        }
    }
}
```



![image-20200729080951251](101-200.assets/image-20200729080951251.png)

```java
private char[][] board;
public void solve(char[][] board) {
    this.board = board;
    int row = board.length;
    if(row == 0)        return;
    int column = board[0].length;

    for(int i = 0; i < row; i++)
        for(int j = 0; j < column; j++)
        {
            if(isInEdge(i,j))
                if(board[i][j] == 'O')
                    dfs(board, i, j);
        }

    for(int i = 0; i < row; i++)
        for(int j = 0; j < column; j++)
        {
            if(board[i][j] == 'O')
                board[i][j] = 'X';
            else if(board[i][j] == '@')
                board[i][j] = 'O';
        }
}

private void dfs(char[][] board, int i, int j)
{
    if(i < 0 || j < 0 || i >= board.length || j >= board[0].length)
        return;

    if(board[i][j] == 'O')
        board[i][j] = '@';
    else
        return;

    dfs(board, i, j+1);
    dfs(board, i+1, j);
    dfs(board, i, j-1);
    dfs(board, i-1, j);

}

private boolean isInEdge(int i, int j)
{
    return i == 0 || i == board.length - 1 || j == 0 || j == board[0].length-1;
}
```



<img src="101-200.assets/image-20201224180253737.png" alt="image-20201224180253737" style="zoom:50%;" />

```cpp
/*
		Union Find 这个思路蛮好的
*/
class Solution {
    int row;
    int column;
    public void solve(char[][] board) {
         row    = board.length;
         column = row == 0 ? 0  : board[0].length;

        if(column == 0) return;
        UnionFind uf = new UnionFind(row * column + 1);
        int dummy = row * column;

        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(board[i][j] == 'O'){
                    if(i == 0 || j == 0 || i == row - 1 || j == column - 1)
                        uf.union(dummy, i * column + j);
                    else{
                        if (i > 0 && board[i - 1][j] == 'O')
                            uf.union(node(i, j), node(i - 1, j));
                        if (i < row - 1 && board[i + 1][j] == 'O')
                            uf.union(node(i, j), node(i + 1, j));
                        if (j > 0 && board[i][j - 1] == 'O')
                            uf.union(node(i, j), node(i, j - 1));
                        if (j < column - 1 && board[i][j + 1] == 'O')
                            uf.union(node(i, j), node(i, j + 1));
                    }
                }

        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(board[i][j] == 'O')
                    if(!uf.connected(dummy, i * column + j))
                        board[i][j] = 'X';
            
    }

    int node(int i, int j) {
        return i * column + j;
    }
}

//手写并查集
class UnionFind{
    private int[] size;
    private int[] id;
    private int count;

    public UnionFind(){}
    public UnionFind(int N){
        count = N;
        id = new int[N];
        size = new int[N];

        for(int i = 0; i < N; i++){
            id[i]   = i;
            size[i] = 1;
        }
    }

    public boolean connected(int p, int q){
        return find(p) == find(q);
    }

    private int find(int p){
        while(p != id[p]){ 
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }

    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)  return;

        if(size[p] > size[q]){
            id[qRoot] = pRoot;
            size[p] += size[q];
        }else{
            id[pRoot] = qRoot;
            size[q] += size[p];
        }

        count--;
    }

    public int count(){return count;}
}
```



```cpp
/*
		BFS 方法
*/
    int row, column;
    const int dirx[4] = {1, -1, 0, 0};
    const int diry[4] = {0, 0, 1, -1};
    void solve(vector<vector<char>>& board) {
        row = board.size();
        column = row == 0 ? 0 : board[0].size();
        if(column == 0)     return;

        queue<pair<int, int>> que;
        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(board[i][j] == 'O')
                    if(i == 0 || j == 0 || i == row - 1 || j == column - 1)
                       que.emplace(i, j);
        while(!que.empty()){
            int x = que.front().first;
            int y = que.front(). second;
            que.pop();

            board[x][y] = '@';
            for(int k = 0; k < 4; k++){
                int newX = x + dirx[k];
                int newY = y + diry[k];
                if(newX < 0 || newY < 0 || newX >= row || newY >= column || board[newX][newY] != 'O')
                    continue;
                
                que.emplace(newX, newY);
            }
        }

        for (int i = 0; i < row; i++) 
            for (int j = 0; j < column; j++) 
                if (board[i][j] == '@') 
                    board[i][j] = 'O';
                 else if (board[i][j] == 'O') 
                    board[i][j] = 'X';
    }

```





# 131 Palindrome Patitioning



```java
    List<List<String>> res;
    public List<List<String>> partition(String s) {
        res = new ArrayList<>();

        backtrack(s, 0, new ArrayList<>());
        return res;
    }

    private void backtrack(String s, int index, List<String> path) {
        if(index == s.length()){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = index + 1; i <= s.length(); i++){
            String frac = s.substring(index, i);

            if(isPalindrome(frac)){
                path.add(frac);
                backtrack(s, i, path);
                path.remove(path.size() - 1);
            }
        }
    }

    private boolean isPalindrome(String s){
        int left = 0, right = s.length() - 1;
        while(left < right){
            if(s.charAt(left) != s.charAt(right))
                return false;
            left++;
            right--;
        }

        return true;
    }
```





```java
//二刷，需要记忆化优化
List<List<String>> res = new ArrayList<>();
    public List<List<String>> partition(String s) {
        backtrack(s.toCharArray(), new ArrayList<>(), 0);

        return res;
    }

    private void backtrack(char[] chars, List<String> path, int index) {
        if(index == chars.length){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = index; i < chars.length; i++){
            if(isPalindrome(chars, index, i)){
                String str = toStr(chars, index, i);

                path.add(str);
                backtrack(chars, path, i + 1);
                path.remove(path.size() - 1);
            }
        }
    }

    private String toStr(char[] chars, int left, int right){
        StringBuilder res = new StringBuilder();
        for(int i = left; i <= right; i++)
            res.append(chars[i]);

        return res.toString();
    }

    private boolean isPalindrome(char[] chars, int left, int right){
        while(left < right){
            if(chars[left] != chars[right])
                return false;

            left++;
            right--;
        }

        return true;
    }
```





<img src="101-200.assets/image-20201224181236706.png" alt="image-20201224181236706" style="zoom:50%;" />

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    public List<List<String>> partition(String s) {
        
        backtrack(s, new ArrayList<>());
        return res;
    }

    public void backtrack(String s, List<String> path){
        if(s.equals("")){
            res.add(new ArrayList<>(path));
            return;
        }

        for(int i = 0; i < s.length(); i++){
            String frac = s.substring(0, i + 1);

            if(isPalindrome(frac)){
                path.add(frac);

                backtrack(s.substring(i + 1), path);

                path.remove(path.size() - 1);
            }
        }

    }

    public boolean isPalindrome(String s){
        int left = 0, right = s.length() - 1;
        while(left < right)
            if(s.charAt(left++) != s.charAt(right--))
                return false;
        
        return true;
    }
}
```

















# 132 Palindrome Partitioning II

![j](101-200.assets/image-20200709151544431.png)

![image-20200907144003369](101-200.assets/image-20200907144003369.png)

```java
/*
	动态规划
	dp[i]：表示前缀子串 s[0:i] 分割成若干个回文子串所需要最小分割次数。
	同时预处理s， 利用Leetcode 第五题， 从而快速判断
*/

    public int minCut(String s) {
        int len = s.length();
        if(len < 2)     return 0;

        int[] dp = new int[len];
        for(int i = 0; i < len; i++)
            dp[i] = i;
        boolean[][] test = longestPalinrome(s.toCharArray());

        for(int i = 1; i < len; i++)
        {
            if(test[0][i])
            {
                dp[i] = 0;
                continue;
            }

            for(int j = 0; j < i; j++)
            {
                if(test[j + 1][i])
                    dp[i] = Math.min(dp[i], dp[j] + 1);
            }
        }
         return dp[len - 1];
    }

    private boolean[][] longestPalinrome(char[] chars)
    {
        int len = chars.length;
        //dp[i][j] from s[i...j] is Palindrome
        boolean[][] dp = new boolean[len][len];
        for(int i = 0; i < len; i++)
            dp[i][i] = true;

        for(int j = 0; j < len; j++)
            for(int i = 0; i < j; i++)
            {
                if(chars[i] == chars[j])
                    dp[i][j] = (j - i <= 2 || dp[i + 1][j - 1]);
                else
                    dp[i][j] = false;
            }

        return dp;
    }
https://leetcode-cn.com/problems/palindrome-partitioning-ii/solution/dong-tai-gui-hua-by-liweiwei1419-2/
```



```java
/*
	这个方法不知道为什么，只能通过27/29个案例
	
	想来想去，应该是算法问题
	因为我的算法基于以下假设：
		拿到该字符串中最长的回文串， 然后在回文串的两边做切割，进而再一步判断
	但事实上可能并非切割最长的回文串，才能拿到最大，因此该算法需要再次考虑
*/
    public int minCut(String s) {
        return minCut(s.toCharArray());
    }

    private int minCut(char[] chars)
    {
        if(chars.length <= 1)       return 0;
        int[] arr = longestPalinrome(chars);
        if(arr[0] == arr[1])        return chars.length - 1;

        if(arr[0] == 0 && arr[1] == chars.length - 1)   return 0;
        else if(arr[0] == 0)                            return 1 + minCut(Arrays.copyOfRange(chars, arr[1] + 1, chars.length));
        else if(arr[1] == chars.length - 1)             return 1 + minCut(Arrays.copyOfRange(chars, 0, arr[0]));
        else
            return 2 +minCut(Arrays.copyOfRange(chars, arr[1] + 1, chars.length)) +
                    minCut(Arrays.copyOfRange(chars, 0, arr[0]));
    }

    //this function returns the upperbound and lowerbound of the palindrome
    private int[] longestPalinrome(char[] chars)
    {
        int len = chars.length;
        //dp[i][j] from s[i...j] is Palindrome
        boolean[][] dp = new boolean[len][len];
        for(int i = 0; i < len; i++)
            dp[i][i] = true;

        for(int j = 0; j < len; j++)
            for(int i = 0; i < j; i++)
            {
                if(chars[i] == chars[j])
                    dp[i][j] = (j - i <= 2 || dp[i + 1][j - 1]);
                else
                    dp[i][j] = false;
            }

        int[] res = new int[2];
        int maxLen = 0;
        for(int i = 0; i < len ; i++)
            for(int j = i; j < len; j++)
            {
                if(dp[i][j])
                    if(j - i + 1 > maxLen)
                    {
                        maxLen = j - i + 1;
                        res[0] = i;
                        res[1] = j;
                    }
            }
        return res;
    }
```



# 133 Clone Graph

![image-20200907085738229](101-200.assets/image-20200907085738229.png)

```java
//典型BFS, 很类似链表操作
class Solution {
    public Node cloneGraph(Node node) {
        if(node == null)    return null;
        HashMap<Node, Node> map = new HashMap<>();
        Deque<Node> queue       = new ArrayDeque<>();
        HashSet<Node> visited   = new HashSet<>();
        map.put(node, new Node(node.val));
        queue.add(node);
        
        while(!queue.isEmpty()){
            Node cur = queue.removeFirst();
            if(visited.contains(cur)) continue;

            for(Node n : cur.neighbors){
                map.putIfAbsent(n, new Node(n.val));

                map.get(cur).neighbors.add(map.get(n));
                queue.add(n);
            }

            visited.add(cur);
        }


        return map.get(node);
    }
}
```



```java
class Solution {
    public Node cloneGraph(Node node) {
        Map<Node, Node> lookup = new HashMap<>();
        return dfs(node, lookup);
    }
	//递归， 坚定不移的相信，这个函数将返回对应点的克隆点
    private Node dfs(Node node, Map<Node,Node> lookup) {
        if (node == null) return null;
        if (lookup.containsKey(node)) return lookup.get(node);
        Node clone = new Node(node.val, new ArrayList<>());
        lookup.put(node, clone);
        for (Node n : node.neighbors)clone.neighbors.add(dfs(n,lookup));
        return clone;
    }
}

作者：powcai
链接：https://leetcode-cn.com/problems/clone-graph/solution/dfs-he-bfs-by-powcai/
```



```cpp
/*
		Cpp 版本
*/
class Solution {
public:
    Node* cloneGraph(Node* node) {
        if (node == nullptr) {
            return node;
        }

        unordered_map<Node*, Node*> visited;

        // 将题目给定的节点添加到队列
        queue<Node*> Q;
        Q.push(node);
        // 克隆第一个节点并存储到哈希表中
        visited[node] = new Node(node->val);

        // 广度优先搜索
        while (!Q.empty()) {
            // 取出队列的头节点
            auto n = Q.front();
            Q.pop();
            // 遍历该节点的邻居
            for (auto& neighbor: n->neighbors) {
                if (visited.find(neighbor) == visited.end()) {
                    // 如果没有被访问过，就克隆并存储在哈希表中
                    visited[neighbor] = new Node(neighbor->val);
                    // 将邻居节点加入队列中
                    Q.push(neighbor);
                }
                // 更新当前节点的邻居列表
                visited[n]->neighbors.emplace_back(visited[neighbor]);
            }
        }

        return visited[node];
    }
};

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/clone-graph/solution/ke-long-tu-by-leetcode-solution/
```



# 134 Gas Station



![image-20200709174705493](101-200.assets/image-20200709174705493.png)

<img src="101-200.assets/image-20210507073114109.png" alt="image-20210507073114109" style="zoom:50%;" />

```java
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;

        for(int i = 0; i < len; i++){
            int index = i;
            int oilSum = 0;
            while(gas[index] - cost[index] + oilSum >= 0){
                oilSum += gas[index] - cost[index];
                index = (index + 1) % len;

                if(index == i)
                    return i;
            }

            if(index < i)
                return -1;
            i = index;
        }

        return -1;
    }
```





<img src="101-200.assets/image-20210507071941132.png" alt="image-20210507071941132" style="zoom:33%;" />

```java
//n 刷 0507
public int canCompleteCircuit(int[] gas, int[] cost) {

        for(int i = 0; i < gas.length; i++){
            if(gas[i] < cost[i])
                continue;
            
            int index = i;
            int oilSum = 0;

            while(true){
                oilSum += gas[index] -  cost[index];
                int step = gas[index];

                index++;
                index %= gas.length;

                if(index == i){
                    //System.out.println(i);
                    return i;
                }else if(cost[index] - gas[index] > oilSum)
                    break;
            }
        }

        return -1;
    }
```





```java
public int canCompleteCircuit(int[] gas, int[] cost) {
    int volumn = 0;
    for(int i = 0; i < gas.length; i++)
    {
        volumn = gas[i] - cost[i];
        if(volumn < 0)     continue;
        int j = (i + 1) % gas.length;
        for(; j != i; j = (j + 1) % gas.length)
        {
            volumn += gas[j] - cost[j];
            if(volumn < 0)     break;
        }

        if(j == i)      return j;
    }
    return -1;
}
```



# 135 Candy 



![image-20200709175759073](101-200.assets/image-20200709175759073.png)

<img src="101-200.assets/image-20210106200425645.png" alt="image-20210106200425645" style="zoom:50%;" />

```java

class Solution {
    public int candy(int[] ratings) {
        int len = ratings.length;
        TreeMap<Integer, List<Integer>> map = new TreeMap<>();


        //for 不同索引， 分配的糖果
        HashMap<Integer, Integer> record    = new HashMap<>();
        for(int i = 0; i < len; i++){
            if(!map.containsKey(ratings[i]))
                map.put(ratings[i], new ArrayList<>());

            map.get(ratings[i]).add(i);
        }

        boolean first = true;
        int count = 0;
        for(Map.Entry<Integer, List<Integer>> entry : map.entrySet()){
            if(first){
                for(Integer index : entry.getValue()){
                    record.put(index, 1);
                    count += 1;
                }
                first = !first;
            }else{
                for(Integer index : entry.getValue()){
                    int num = 1;
                    if(index > 0 && ratings[index - 1] < ratings[index])
                        num = Math.max(num, record.getOrDefault(index - 1, 0) + 1);
                    if(index < len - 1 && ratings[index + 1] < ratings[index])
                        num = Math.max(num ,record.getOrDefault(index + 1, 0) + 1);

                    record.put(index, num);
                    count += num;
                }
            }
        }

        return count;
    }

}

```







```java
/*
Req:
	Each child must have at least one candy.
	Children with a higher rating get more candies than their neighbors.
从左遍历和从右遍历
取两次遍历结果的最大值，这样可以保证都符合规则

*/
class Solution {
    public int candy(int[] ratings) {
        int[] left = new int[ratings.length];
        int[] right = new int[ratings.length];
        Arrays.fill(left, 1);
        Arrays.fill(right, 1);
        //和左边比
        for(int i = 1; i < ratings.length; i++)
            if(ratings[i] > ratings[i - 1])
                left[i] = left[i - 1] + 1;
        
        int count = left[ratings.length - 1];
        
        //和右边比
        for(int i = ratings.length - 2; i >= 0; i--)
        {
            if(ratings[i] > ratings[i + 1]) 
                right[i] = right[i + 1] + 1;
            count += Math.max(left[i], right[i]);
        }
        return count;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/candy/solution/candy-cong-zuo-zhi-you-cong-you-zhi-zuo-qu-zui-da-/
```







# 136 Single Number  map方法的掌握以及异或的玩法



![image-20200709181622930](101-200.assets/image-20200709181622930.png)

![image-20200709182658301](101-200.assets/image-20200709182658301.png)

```java
/*
	注意如何拿出map的元素方法
*/
public int singleNumber(int[] nums) {
    int len = nums.length;
    HashMap<Integer, Integer> map = new HashMap<>();

    for(int i = 0; i < len; i++)
    {
        map.put(nums[i], map.getOrDefault(nums[i],0) + 1);
        if(map.get(nums[i]) == 2)
            map.remove(nums[i]);
    }

    for(Map.Entry<Integer, Integer> entry : map.entrySet())
        return entry.getKey();
    return 0;
}
```



```java
/*
牛逼解法 异或
a^b^a=a^a^b=b,因此ans相当于nums[0]^nums[1]^nums[2]^nums[3]^nums[4].
然后再根据交换律把相等的合并到一块儿进行异或（结果为0），然后再与只出现过一次的元素进行异或，这样最后的结果就是，只出现过一次的元素（0^任意值=任意值）
*/
int ans = nums[0];
if (nums.length > 1) {
   for (int i = 1; i < nums.length; i++) {
      ans = ans ^ nums[i];
   }
 }
 return ans;

作者：yinyinnie
链接：https://leetcode-cn.com/problems/single-number/solution/xue-suan-fa-jie-guo-xiang-dui-yu-guo-cheng-bu-na-y/
```





# 137 Single Number II

![image-20200709183708778](101-200.assets/image-20200709183708778.png)

![image-20200709183715881](101-200.assets/image-20200709183715881.png)

```java
public int singleNumber(int[] nums) {
    int len = nums.length;
    HashMap<Integer, Integer> map = new HashMap<>();

    for(int i = 0; i < len; i++)
    {
        map.put(nums[i], map.getOrDefault(nums[i],0) + 1);
        if(map.get(nums[i]) == 3) //这里是与上一个题唯一不同的地方
            map.remove(nums[i]);
    }

    for(Map.Entry<Integer, Integer> entry : map.entrySet())
        return entry.getKey();
    return 0;
}
```



# 138 Copy List With Random Pointer 哈希map的灵活应用

![image-20200709194020670](101-200.assets/image-20200709194020670.png)



```java
/*
	使用HashMap 进行复制
*/
public Node copyRandomList(Node head) {
    if (head == null) return null;
    HashMap<Node, Node> map = new HashMap<>();
    Node p = head;
    
    while (p != null) {
        map.put(p, new Node(p.val));
        p = p.next;
    }
    
    p = head;
    
    while (p != null) {
        map.get(p).next = map.get(p.next);
        map.get(p).random = map.get(p.random);
        p = p.next;
    }
    
    return map.get(head);
}

作者：jerrymouse1998
链接：https://leetcode-cn.com/problems/copy-list-with-random-pointer/solution/javatu-jie-cong-hashmapdao-chang-shu-kong-jian-by-/
```







# 140 Word Break II 

![image-20200702174347446](101-200.assets/image-20200702174347446.png)



```java
/*
	以下代码可以通过 31/36 个测试案例
	但是时间太高了，需要优化
	本质是dp， dfs， 我把他放入dp-part中 
	
	下面附一个记忆化回溯
*/
class Solution {
    public List<String> res;
    public char[] charArray;
    public List<String> wordBreak(String s, List<String> wordDict) {
        Set<String> dict = new HashSet<>(wordDict);
        res = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        charArray = s.toCharArray();

        backtrack(0, charArray, dict, sb);
        return res;
    }

    private void backtrack(int start, char[] charArray, Set<String> dict, StringBuilder sb) {
        if(start == charArray.length)
        {
            StringBuilder fruit = new StringBuilder(sb);
            fruit.setLength(fruit.length()-1);
            res.add(fruit.toString());
            return;
        }

        for(int i = 0; i < charArray.length; i++)
        {
            if(start + i+1 <= charArray.length)
            {
                StringBuilder frac = new StringBuilder();
                frac.append(charArray, start, i+1);	//	就算这样优化，回溯时间也还是很多

                if(dict.contains(frac.toString()))
                {
                    sb.append(frac).append(" ");
                    backtrack(start + i+1, charArray, dict, sb);
                    sb.setLength(sb.length() - frac.length() - 1);
                }
            }
        }
    }
}
```



```java
/*
		更好理解的一种方法， 就是记忆化回溯
		
		将map 作为记忆 数据结构， 
		workBreakHelper 本质上是递归
*/
class Solution {
    private HashMap<String, List<String>> map = new HashMap<>();
    public List<String> wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>();
        for(String str : wordDict)
            set.add(str);

        wordBreakHelper(s, set);
        return map.get(s);
    }

    private List<String> wordBreakHelper(String s, HashSet<String> set)
    {
        if(map.containsKey(s))
            return map.get(s);
        if(s.length() == 0)         return new ArrayList<>();
        List<String> res = new ArrayList<>();

        for(int j = 1; j <= s.length(); j++)
        {
            String frac = s.substring(0, j);

            if(set.contains(frac))
            {
                if(j == s.length())
                    res.add(frac);
                else
                {
                    List<String> temp = wordBreakHelper(s.substring(j), set);
                    for(String ss : temp)
                        res.add(frac + " " + ss);
                }
            }
        }
        map.put(s, res);
        return res;
    }

    public static void main(String[] args){
        String s = "catsanddog";
        List<String> wordDict = new ArrayList<>(Arrays.asList("cat", "cats", "and", "sand", "dog"));
        Solution ss = new Solution();

        ss.wordBreak(s, wordDict);
    }
}
```





# 141 Linked List Cycle

![image-20200709202636677](101-200.assets/image-20200709202636677.png)

![image-20200709202944385](101-200.assets/image-20200709202944385.png)

```java
public boolean hasCycle(ListNode head) {
    if(head == null)    return false;

    ListNode fast = head;
    ListNode slow = head;

    while(fast != null && fast.next != null)
    {
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow)
            return true;
    }
    return false;
}
```



# 142 Linked List Cycle II

![image-20200710064116611](101-200.assets/image-20200710064116611.png)

![image-20200710065839022](101-200.assets/image-20200710065839022.png)

```java
public ListNode detectCycle(ListNode head) {
    if(head == null)        return null;
    if(head.next == null)    return null;
    if(head.next.next == head)     return head;

    ListNode slow = head;
    ListNode fast = head;
    while(fast != null && fast.next != null)
    {
        fast = fast.next.next;
        slow = slow.next;
        if(fast == slow)
            break;
    }
    if(fast != slow)        return null;

    slow = head;
    while(slow != fast)
    {
        slow = slow.next;
        fast = fast.next;
    }

    return fast;
}
```





# 143 Reorder List

![image-20200710072316814](101-200.assets/image-20200710072316814.png)

![image-20200710075244002](101-200.assets/image-20200710075244002.png)

```java
public void reorderList(ListNode head) {
    if(head == null)        return;

    Deque<ListNode> stack = new ArrayDeque<>();
    ListNode cur = head;
    while(cur != null)
    {
        stack.push(cur);
        cur = cur.next;
    }

    cur = head;
    ListNode stack_cur = new ListNode(Integer.MAX_VALUE);

    while(cur.next != stack_cur.next)
    {
        stack_cur = stack.poll();
        stack_cur.next = cur.next;
        cur.next = stack_cur;

        cur = cur.next.next;
    }
    
    stack_cur.next = null;		//to avoid the cycle
}
```

![image-20200808181151369](101-200.assets/image-20200808181151369.png)

```java
public void reorderList(ListNode head) {
    Deque<ListNode> queue = new ArrayDeque<>();
    if(head == null)        return;

    ListNode cur = head;
    while(cur != null)
    {
        queue.addLast(cur);
        cur = cur.next;
    }

    ListNode dummy = new ListNode(0);
    cur = dummy;
    ListNode left = null, right = null;
    while(queue.size() >= 2)
    {
        left = queue.removeFirst();
        right = queue.removeLast();

        cur.next = left;
        cur.next.next = right;
        cur = cur.next.next;
        cur.next = null;
    }

    if(!queue.isEmpty()){
        cur.next = queue.removeFirst();
        cur.next.next = null;
    }        


    head = dummy.next;
}
```







# 145 Binary Tree Postorder Traversal



<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210512192320196.png" alt="image-20210512192320196" style="zoom:50%;" />

```go
func postorderTraversal(root *TreeNode) []int {
	res := make([]int, 0)
	stack := make([]*TreeNode, 0)
	
	if root == nil{
		return res
	}

	for ; len(stack) != 0 || root != nil;{
		for;root != nil;{
			stack = append(stack, root)
			res = append(res, root.Val)
			root = root.Right
		}		
		
		root = stack[len(stack) - 1]
		stack = stack[0 : len(stack) - 1]
        root = root.Left
	}
	
	for i, j := 0, len(res) - 1 ; i < j; {
		res[i], res[j] = res[j], res[i]
		i++
		j--
	}
	return res
}

```





# 146 LRU Cache ☆☆☆

![image-20200710080821020](101-200.assets/image-20200710080821020.png)

![image-20200710082134183](101-200.assets/image-20200710082134183.png)

```java
/*
	适合查找快，插入快，删除快，有顺序之分的数据结构
	哈希链表 => 双链表和哈希表的结合
	借助哈希表赋予链表快速查找的特性
	
	处理链表节点的时候，不要忘记同时更新哈希表中对节点的映射
*/

class LRUCache
{
    private HashMap<Integer, Node> map;
    
    private DoubleList cache;
    
    private int cap;
    
    public LRUCache(int capacity)
    {
        this.cap = capacity;
        map = new HashMap<>();
        cache = new DoubleList();
    }
    
    public int get(int key)
    {
        if(!map.containsKey(key))
            return -1;
        int val = map.get(key).val;
        put(key, val);
        return val;
    }
    
    public void put(int key, int val)
    {
        Node x = new Node(key, val);
        
        if(map.containsKey(key))
        {
            cache.remove(map.get(key));
            cache.addFirst(x);
            map.put(key, x);
        }
        else
        {
            if(cap == cache.size())
            {
                Node last = cache.removeLast();
                map.remove(last.key);
            }
            cache.addFirst(x);
            map.put(key, x);
        }
    }
}

class Node
{
    public int key, val;
    public Node next, prev;
    public Node(int k, int v)
    {
        this.key = k;
        this.val = v;
    }
}

class DoubleList {  
    private Node head, tail; // 头尾虚节点
    private int size; // 链表元素数

    public DoubleList() {
        head = new Node(0, 0);
        tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
        size = 0;
    }

    // 在链表头部添加节点 x
    public void addFirst(Node x) {
        x.next = head.next;
        x.prev = head;
        head.next.prev = x;
        head.next = x;
        size++;
    }

    // 删除链表中的 x 节点（x 一定存在）
    public void remove(Node x) {
        x.prev.next = x.next;
        x.next.prev = x.prev;
        size--;
    }
    
    // 删除链表中最后一个节点，并返回该节点
    public Node removeLast() {
        if (tail.prev == head)
            return null;
        Node last = tail.prev;
        remove(last);
        return last;
    }
    
    // 返回链表长度
    public int size() { return size; }
}
https://leetcode-cn.com/problems/lru-cache/solution/lru-ce-lue-xiang-jie-he-shi-xian-by-labuladong/
```



# 147 Insertion Sort List

![image-20200710090752522](101-200.assets/image-20200710090752522.png)

![image-20200710104128134](101-200.assets/image-20200710104128134.png)

```java
public ListNode insertionSortList(ListNode head) {
    if(head == null)        return null;

    ListNode newHead = new ListNode(0);

    ListNode cur = head;
    ListNode curNew = newHead;

    while(cur != null)
    {
        ListNode newNode = new ListNode(cur.val);
        while(curNew.next != null && curNew.next.val < newNode.val)
            curNew = curNew.next;

        newNode.next = curNew.next;
        curNew.next = newNode;

        cur = cur.next;
        curNew = newHead;
    }
    return newHead.next;
}
```



# 148 Sort List



<img src="101-200.assets/image-20210628205115866.png" alt="image-20210628205115866" style="zoom:50%;" />

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(head == NULL || head->next == NULL)
            return head;

        ListNode* fast = head;
        ListNode* slow = head;

        ListNode* brk = NULL;
        while(fast != NULL && fast->next != NULL){
            fast = fast->next->next;
            
            if(fast == NULL || fast->next == NULL)
                brk = slow;
            slow = slow->next;
        }
        
        brk->next = nullptr;
        
        ListNode* head1 = sortList(head);
        ListNode* head2 = sortList(slow);

        ListNode dummy(0);
        ListNode* cur = &dummy;
        while(head1 != NULL || head2 != NULL){
            if(head1 == NULL || (head1 != NULL && head2 != NULL && head1->val >= head2->val)){
                cur->next = head2;
                head2 = head2->next;

                cur = cur->next;
            }else if(head2 == NULL || (head1 != NULL && head2 != NULL && head1->val < head2->val)){
                cur->next = head1;

                head1 = head1->next;
                cur = cur->next;
            }
        }

        return dummy.next;
    }
};

```



<img src="101-200.assets/image-20210108192127280.png" alt="image-20210108192127280" style="zoom:50%;" />

```java
class Solution {
    public ListNode sortList(ListNode head) {
        return sort(head, null);
    }

    private ListNode sort(ListNode start, ListNode end) {
        if(start == end)        return start;

        ListNode fast = start, slow = start;
        while(fast != end && fast.next != end){
            fast = fast.next.next;
            slow = slow.next;
        }
        ListNode l2 = sort(slow.next, end);
        slow.next = null;
        ListNode l1 = sort(start, slow);


        return merge(l1, l2);
    }


    private ListNode merge(ListNode l1, ListNode l2) {
        if(l1 == null || l2 == null)
            return l1 == null ? l2 : l1;

        if(l1.val < l2.val){
            l1.next = merge(l1.next, l2);
            return l1;
        }else{
            l2.next = merge(l1, l2.next);
            return l2;
        }
    }


}
```





![image-20200710104239980](101-200.assets/image-20200710104239980.png)

```java
public ListNode sortList(ListNode head) {
    return mergeSort(head);
}

private ListNode mergeSort(ListNode head) {
    if (head == null || head.next == null) 
        return head;
    
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    ListNode fast = dummy;
    ListNode slow = dummy;
    
    //快慢指针找中点
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
    }

   /*
       [Dummy] -> [0]  -> [1]  -> [2]  -> [3]
                         △slow			△fast
        使用dummy的目的，就是让slow停在中间靠左
        然后用head2指向中间靠右，也就是第二个头
        最后slow.next = null  防止循环链表
   */
    ListNode head2 = slow.next;
    slow.next = null;
    head = mergeSort(head);
    head2 = mergeSort(head2);
    return merge(head, head2);

}

private ListNode merge(ListNode head1, ListNode head2) {
    ListNode dummy = new ListNode(0);
    ListNode tail = dummy;
    while (head1 != null && head2 != null) {
        if (head1.val < head2.val) {
            tail.next = head1;
            tail = tail.next;
            head1 = head1.next;
        } else {
            tail.next = head2;
            tail = tail.next;
            head2 = head2.next;
        }

    }
    if (head1 != null) {
        tail.next = head1;
    }

    if (head2 != null) {
        tail.next = head2;
    }

    return dummy.next;

}
```





# 149 Max  Points On a Line

![image-20200710104516131](101-200.assets/image-20200710104516131.png)



```java
/*
	注意本题设置的障碍，存在重复的元素
	先给出原始想法
	20/41
*/

public int maxPoints(int[][] points) {
    HashMap<Integer, HashMap<Integer, Integer>> map = new HashMap<>();
    boolean[] marked = new boolean[points.length];
    if(points.length == 0)      return 0;
    
    //对于每一个点，创建一个hashMap
    //每个点的HashMap 代表， 前面是对应的斜率，后面是个数
    for(int i = 0; i < points.length; i++)
    {
        map.put(i, new HashMap<>());
        for(int j = i+1; j < points.length; j++)
        {
            int k = calculate(points, i, j);
            map.get(i).put(k, map.get(i).getOrDefault(k, 0) + 1);       
        }
    }

    int res = 0;
    for(HashMap<Integer, Integer> m : map.values())
        for(Integer i : m.values())
            res = Math.max(res, i);
    
    return res+1;
}

private int calculate(int[][] points, int i, int j)
{
    int difY = points[j][1] - points[i][1];
    int difX = points[j][0] - points[i][0];

    if(difX == 0)       return Integer.MAX_VALUE;

    return difY / difX;
}

```



```java
/*
	灵感来源于点斜式，确定一个点之后，计算之后的每个点的斜率 即可唯一确定一条直线
	问题转换为 经过某个点的直线，哪条直线上的点最多
*/
public int maxPoints(int[][] points) {
    if(points.length < 3)       return points.length;

    int res = 0;

    for(int i = 0; i < points.length; i++)
    {
        int duplicates = 0;
        int max = 0;
        HashMap<String, Integer> map = new HashMap<>();
        for(int j = i + 1; j < points.length; j++)
        {
            int x = points[j][0] - points[i][0];
            int y = points[j][1] - points[i][1];

            if(x == 0 && y == 0)
            {
                duplicates++;
                continue;
            }

            /*
            解决斜率的问题， 因为有几个特殊案例， 比如求点[0,0] [95465465,95465466] [95465466,95465465]
            这个时候如果用double等等精度可能上不去
            因此采用辗转相除法， greatest common divisor
            求出最大公约数，然后相除，并作为key 保留
            */ 
            int gcd = greatestCommonDivisor(x, y);
            x = x / gcd;
            y = y / gcd;
            String key = x + "@" + y;
            map.put(key, map.getOrDefault(key, 0) + 1);
            max = Math.max(max, map.get(key));
        }
        //每算完一个点，就更新一下最大值
        res = Math.max(res, max + duplicates + 1);
    }
    return res;
}
//辗转相除法
private int greatestCommonDivisor(int a, int b)
{
    while(b != 0)
    {
        int temp = a % b;
        a = b;
        b =temp;
    }

    return a;
}
```





# 150  Evaluate Reverse Polish Notation

![image-20200710142009436](101-200.assets/image-20200710142009436.png)

![image-20200710143334565](101-200.assets/image-20200710143334565.png)

```java
public int evalRPN(String[] tokens) {
    Deque<String> ops = new ArrayDeque<String>();
    Deque<String> nums = new ArrayDeque<String>();

    for(int i = 0; i < tokens.length; i++)
    {
        String s = tokens[i];

        if(s.equals("+") || s.equals("-") || s.equals("*") || s.equals("/"))
        {
            String s2 = nums.pop();
            String s1 = nums.pop();
            nums.push(perform(s1, s2, s) + "");
        }
        else
            nums.push(s);
    }

    return Integer.parseInt(nums.pop());
}

private int perform(String num1, String num2, String op)
{
    int a = Integer.parseInt(num1);
    int b = Integer.parseInt(num2);

    if(op.equals("+"))
        return a + b;
    if(op.equals("-"))
        return a - b;
    if(op.equals("*"))
        return a * b;
    if(op.equals("/"))
        return a / b;

    return -1;
}

```







# leecode 151-200



# 151 Reverse Words In a String



![image-20200710143530333](101-200.assets/image-20200710143530333.png)



```go
func reverseWords(s string) string {
    res := strings.Fields(s)
    length := len(res)

    for i := 0; i < length / 2; i++{
        res[i], res[length - i - 1] = res[length - 1 - i], res[i]
    }

    return strings.Join(res, " ");
}
```





![image-20200710144659148](101-200.assets/image-20200710144659148.png)

```java
public String reverseWords(String s) {
    if(s.length() == 0)     return "";


    int count = 0;
    StringBuilder sb = new StringBuilder();

    String[] words = s.split(" ");
    for(int i = words.length-1; i >= 0; i--)
    {
        if(words[i].equals(""))    continue;

        sb.append(words[i]).append(" ");
    }
    if(sb.length() == 0)      return "";
    sb.setLength(sb.length()-1);

    return sb.toString();
}
```



# 152 Maximum Product Subarray



```java
public int maxProduct(int[] nums) {
    int len = nums.length;

    int[] dpMax = new int[len];
    int[] dpMin = new int[len];
    int maxProduct = nums[0];

    for(int i = 0; i < nums.length; i++)
    {
        if(i == 0)
        {
            dpMax[i] = nums[i];
            dpMin[i] = nums[i];
        }
        else
        {
            if(nums[i] >= 0)
            {
                dpMax[i] = Math.max(dpMax[i-1] * nums[i], nums[i]);
                dpMin[i] = Math.min(dpMin[i-1] * nums[i], nums[i]);
            }
            else
            {
                dpMax[i] = Math.max(dpMin[i-1] * nums[i], nums[i]);
                dpMin[i] = Math.min(dpMax[i-1] * nums[i], nums[i]);
            }
        }

        maxProduct = Math.max(maxProduct, dpMax[i]);
    }

    return maxProduct;
}
```



# 153 Find Min in Sorted Rotated Array

![image-20200710144743240](101-200.assets/image-20200710144743240.png)

![image-20200710144902579](101-200.assets/image-20200710144902579.png)

```java
/*
	结合着看
LeetCode 33 题：搜索旋转排序数组
LeetCode 81 题：搜索旋转排序数组-ii
LeetCode 153 题：寻找旋转排序数组中的最小值
LeetCode 154 题：寻找旋转排序数组中的最小值-ii
*/
public int findMin(int[] nums) {
    Arrays.sort(nums);
    return nums[0];
}
```



```java
/*
	二分正式解法
*/
   public int findMin(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while(left <= right)
    {
        if(nums[left] == nums[right])
            return nums[left];
        int mid = (left + right)/2;
        
        //注意这里理解是关键
        //如果mid - right 区间是单调递增的，那么最小值就不会再这里出现
        //最小值出现的位置只可能是不连续的地方
        if(nums[mid] > nums[right])
            left = mid + 1;
        else
            right = mid;
    }

    return -1;
   }

作者：imageslr
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/solution/yi-wen-jie-jue-4-dao-sou-suo-xuan-zhuan-pai-xu-s-3/
```





# 154 Find Min in Rotate Sorted Array II  

![image-20200710151615203](101-200.assets/image-20200710151615203.png)

<img src="101-200.assets/image-20210514145545417.png" alt="image-20210514145545417" style="zoom:50%;" />

```go
func findMin(nums []int) int {
	left, right := 0, len(nums) - 1

	res := nums[0]
	for ; left <= right; {
		mid := (left + right) / 2

		res = min(res, nums[mid])

		if nums[left] == nums[mid]{
			left++
		}else if nums[left] < nums[mid]{
			res = min(nums[left], res)
			left = mid + 1
		}else{
			res = min(nums[mid], res)
			res = min(nums[right], res)

			right = mid - 1
		}
	}

	return res
}

func min(a int, b int) int{
	if a < b{
		return a
	}

	return b
}
```





```java
public class Solution {
    public int findMin(int[] nums) {
        int len = nums.length;
        if (len == 0) {
            return 0;
        }
        int left = 0;
        int right = len - 1;
        while (left < right) {
            // int mid = left + (right - left) / 2;
            int mid = (left + right) >>> 1;
            if (nums[mid] > nums[right]) 
                left = mid + 1;
            else if (nums[mid] < nums[right]) 
                right = mid;
             else {
                assert nums[mid] == nums[right];
                right--;
            }
        }
        return nums[left];
    }

}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/solution/er-fen-fa-fen-zhi-fa-python-dai-ma-by-liweiwei1419/
```





# 155 Min Stack

.![image-20200710192409914](101-200.assets/image-20200710192409914.png)





```java
/*
	采用一个Node 类结构，额外记录我们的最小值，值得学习！
*/
private static class Node{
    int val;
    int min;
    public Node(int val, int min)
    {
        this.val = val;
        this.min = min;
    }
}
    public Deque<Node> stack;
    public MinStack() {
    	stack = new ArrayDeque<>();
    }
    public void push(int x) 
    {

        if(stack.isEmpty())
        stack.push(new Node(x, x));
        else
        stack.push(new Node(x, Math.min(x, stack.peek().min)));
    }

    public void pop() 
    {
 	   stack.pop();
    }

    public int top() {
  	  return stack.peek().val;
    }

    public int getMin() {
    	return stack.peek().min;
}
```





# 156 Binary Tree Upside Down ? 未完成

![image-20200710195233372](101-200.assets/image-20200710195233372.png)

```java
class Solution {
    // 处理之后的根节点
     TreeNode head;

    public  TreeNode upsideDownBinaryTree(TreeNode root) {
        if (root == null) 
            return null;
        
        dfs(root);
        return head;
    }

    public  TreeNode dfs(TreeNode node) {
        if (node == null) 
            return null;
        
        if (node.left == null && node.right == null) {
            if (head == null) {
                // 最左边的节点即为实际的根节点
                head = node;
            }
            return node;
        }
        TreeNode left = dfs(node.left);
        TreeNode right = dfs(node.right);
        if (left != null) {
            // 左孩子的左子树为当前的右节点
            left.left = right;
            // 左孩子的右子树为当前父节点
            left.right = node;
        }
        // 清空的当前父节点的左右子树
        node.right = null;
        node.left = null;
        return node;
    }
}

作者：yand-3
链接：https://leetcode-cn.com/problems/binary-tree-upside-down/solution/hou-xu-bian-li-di-gui-chu-li-zuo-hai-zi-de-zuo-zi-/
```



# 157 Read N Characters Given Read 4

![image-20200710200133432](101-200.assets/image-20200710200133432.png)



```java
/**
 * The read4 API is defined in the parent class Reader4.
 *     int read4(char[] buf);
 */

public class Solution extends Reader4 {
    /**
     * @param buf Destination buffer
     * @param n   Number of characters to read
     * @return    The number of actual characters read
     */
  public int read(char[] buf, int n) {
        int tmp;
        int length = 0;
        char [] bufTmp = new char[4];
        while ((tmp = read4(bufTmp)) != 0) {
            for (int i = 0; i < tmp && length < n; i++) {
                buf[length++] = bufTmp[i];
            }

        }
        return length;
    }
}

作者：yand-3
    链接：https://leetcode-cn.com/problems/read-n-characters-given-read4/solution/xun-huan-du-xun-huan-tiao-jian-pan-duan-chang-du-s/
```



# 158 Read N Chara from Read4II 未完成





# 160  Intersection of Two Linked Lists

![image-20200710202236460](101-200.assets/image-20200710202236460.png)



```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode node1 = headA, node2 = headB;
        while(node1 != node2) {
        	node1 = node1.next == null ? headB : node1.next;
        	node2 = node2.next == null ? headA : node2.next;
        }
        return node1;
    }
ref := https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/
```





![image-20200710205059690](101-200.assets/image-20200710205059690.png)

```java
/*
	给两个链表加个头结点，这样会方便很多
*/
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    if(headA == headB)      return headB;
    if(headA == null && headB != null)      return null;
    if(headA != null && headB == null)      return null;
    if(headA.next == headB)     return headB;
    if(headB.next == headA)     return headA;

    ListNode newA = new ListNode(0);
    ListNode newB = new ListNode(1);
    newA.next = headA;
    newB.next = headB;
    ListNode curA = newA;
    ListNode curB = newB;

    while(curA != null)
    {
        while(curB != null && curA.next != curB.next)
        	curB = curB.next;
    	if(curB != null && curB.next == curA.next)
    		return curB.next;
    	else
        {
            curA = curA.next;
            curB = newB;
        }
    }

    return null;
}
```

![image-20200710205808615](101-200.assets/image-20200710205808615.png)

```java
/*
	哈希表会让时间快一点
*/
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    HashSet<ListNode> set = new HashSet<>();
    ListNode cur = headA;
    while(cur != null)
    {
        set.add(cur);
        cur = cur.next;
    }
    cur = headB;
    while(cur != null)
    {
        if(set.contains(cur))
            return cur;
        cur = cur.next;
    }
    return null;
}
```



```java
/*
	第三种方法，就是走两遍，第二遍就会相遇
*/
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode ha = headA, hb = headB;
        while (ha != hb) {
            ha = ha != null ? ha.next : headB;
            hb = hb != null ? hb.next : headA;
        }
        return ha;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/solution/intersection-of-two-linked-lists-shuang-zhi-zhen-l/
```

![image-20200808183434014](101-200.assets/image-20200808183434014.png)

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    List<ListNode> queueOne = new ArrayList<>();
    List<ListNode> queueTwo = new ArrayList<>();

    if(headA == null || headB == null)      return null;

    ListNode cur = headA;
    while(cur != null)
    {
        queueOne.add(cur);
        cur = cur.next;
    }
    
    cur = headB;
    
    while(cur != null)
    {
        queueTwo.add(cur);
        cur = cur.next;
    }

    int indexA = queueOne.size() - 1;
    int indexB = queueTwo.size() - 1;

    while(indexA >= 0 && indexB >= 0)
    {
        if(queueOne.get(indexA) != queueTwo.get(indexB))
            if(indexA == queueOne.size() - 1)
                return null;
            else
                return queueOne.get(indexA + 1);

        indexA--;
        indexB--;
    }
    return queueOne.get(indexA + 1);
}
```

# 161 One Edit Distance

![image-20200711073104945](101-200.assets/image-20200711073104945.png)

![image-20200711081206052](101-200.assets/image-20200711081206052.png)

```java
/*
	借鉴了同一类型题的解法， 78 Edit Distance
*/
public boolean isOneEditDistance(String s, String t) {
        if(s.length() - t.length() >= 2)    return false;
        
        int[][] dp = new int[s.length()+1][t.length()+1];
        for(int i = 0; i <= s.length(); i++)
            dp[i][0] = i;
        for(int j = 0; j <= t.length(); j++)
            dp[0][j] = j;
        
        for(int i = 1; i <= s.length(); i++)
            for(int j = 1; j <= t.length(); j++)
            {
                if(s.charAt(i-1) == t.charAt(j-1))  
                    dp[i][j] =dp[i-1][j-1];
                else
                    dp[i][j] = Math.min(dp[i][j-1], Math.min(dp[i-1][j], dp[i-1][j-1])) + 1;
            }
        
        return dp[s.length()][t.length()] == 1;
    }
```



```java
/*
	思路很清晰  确保s.length < t.length
	首先排除不可能情况
	之后对前i个进行判断，
		如果相同，往下走
		如果不同，判断剩余的是否相同
    最后如果都相等，那么必须是s.length() + 1 = t.length()
*/
class Solution {
  public boolean isOneEditDistance(String s, String t) {
    int ns = s.length();
    int nt = t.length();

    // Ensure that s is shorter than t.
    if (ns > nt)
      return isOneEditDistance(t, s);

    // The strings are NOT one edit away distance  
    // if the length diff is more than 1.
    if (nt - ns > 1)
      return false;

    for (int i = 0; i < ns; i++)
      if (s.charAt(i) != t.charAt(i))
        // if strings have the same length
        if (ns == nt)
          return s.substring(i + 1).equals(t.substring(i + 1));
        // if strings have different lengths
        else
          return s.substring(i).equals(t.substring(i + 1));

    // If there is no diffs on ns distance
    // the strings are one edit away only if
    // t has one more character. 
    return (ns + 1 == nt);
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/one-edit-distance/solution/xiang-ge-wei-1-de-bian-ji-ju-chi-by-leetcode/
```





# 161 Find Peak Element  二分类题目

![image-20200711081940004](101-200.assets/image-20200711081940004.png)

![image-20200711082400833](101-200.assets/image-20200711082400833.png)



```java
public int findPeakElement(int[] nums) {
    if(nums.length == 1)        return 0;
    if(nums[0] > nums[1])       return 0;
    if(nums[nums.length-1] > nums[nums.length -2])      return nums.length-1;

    for(int i = 1 ; i < nums.length -1;  i++)
        if(nums[i] > nums[i-1] && nums[i] > nums[i+1])
            return i;
    return -1;
}
```



```java
/*
	正宗二分解法， logarithematic
	注意这里，由于数组两边nums[-1] = nums[n] = -∞
	因此，我们只要找到一个局部上升的梯度，就可以在左/右找到peak
	这个性质很重要
*/
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        for (; left < right; ) 
        {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[mid + 1]) {
                right = mid;	//注意这里是包含的，因为mid可能是peak
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}

作者：guanpengchn
链接：https://leetcode-cn.com/problems/find-peak-element/solution/hua-jie-suan-fa-162-xun-zhao-feng-zhi-by-guanpengc/
```





# 163 Missing Ranges

![image-20200711083922034](101-200.assets/image-20200711083922034.png)



![image-20200711092643069](101-200.assets/image-20200711092643069.png)

```java
/*
	通过38/40
	没办法通过Integer.MAX_VALUE
	
	经验教训，碰到超过int情况过不去的，改成long
*/
    public List<String> findMissingRanges(int[] nums, int lower, int upper) {
        long lowerl = lower;
        long upperl = upper;
        Deque<String> stack = new ArrayDeque<>();
        List<String> res = new ArrayList<>();
        
        if(nums.length == 0)
        {
            if(lower == upper){
                res.add(lower + "");
                return res;
            }
            else{
                StringBuilder sb = new StringBuilder();
                sb.append(lower + "").append("->").append(upper + "");
                res.add(sb.toString());
                return res;
            }
        }

        for(int i = 0; i <nums.length-1; i++)
        {
            int dif = nums[i+1] - nums[i];
            if(dif == 0 || dif == 1)        continue;
            else if(dif == 2)
                stack.addLast((nums[i]+1) + "");
            else
            {
                StringBuilder sb = new StringBuilder();
                sb.append(nums[i] + 1).append("->").append(nums[i+1]-1);
                stack.addLast(sb.toString());
            }
        }
        long dif_low = nums[0] - lowerl;
        if(dif_low == 0)    {}
        else if (dif_low == 1)  stack.addFirst(lowerl + "");
        else if (dif_low >= 2)  stack.addFirst(lowerl + "" + "->" + (nums[0]-1));

        long  dif_hi = upperl - nums[nums.length-1];
        if(dif_hi == 0)    {}
        else if (dif_hi == 1)  stack.addLast(upperl + "");
        else if (dif_hi >= 2)  stack.addLast(nums[nums.length-1]+1 + "" + "->" + upperl);

        for(String s : stack)
            res.add(s);

        return res;
    }
```



```java
/*
	双指针蛮巧妙
*/
public List<String> findMissingRanges(int[] nums, int lower, int upper) {
    List<String> res = new ArrayList<>();
    long pre = (long)lower - 1; // prevent 'int' overflow
    for (int i = 0; i < nums.length; i++) {
        if (nums[i] - pre == 2) res.add(String.valueOf(pre + 1));
        else if (nums[i] - pre > 2) res.add((pre + 1) + "->" + (nums[i] - 1));
        pre = nums[i]; // 'int' to 'long'
    }
    if (upper - pre == 1) res.add(String.valueOf(pre + 1));
    else if (upper - pre > 1) res.add((pre + 1) + "->" + upper);
    return res;
}


作者：jyd
链接：https://leetcode-cn.com/problems/missing-ranges/solution/missing-ranges-shuang-zhi-zhen-fa-by-jyd/
```



# 164 Max Gap 搞懂桶排序

![image-20200711093138279](101-200.assets/image-20200711093138279.png)



```java
/*
	将箱子能放的数字个数为interval, 给定的数字最小是min， 最大是max
	箱子划分范围:
	min + 0 * interval ~ min + 1 * interval - 1
	min + 1 * interval ~ min + 2 * interval - 1
	min + 2 * interval ~ min + 3 * interval - 1
	....
	min + (n-2) * interval ~ min + (n-1) * interval - 1
	
	通过(nums[i] - min) / interval 得到当前数字应该放到的箱子编号
	同时需要保证至少有一个空箱子， 这样
		1 可以保证箱子内部不会产生最大Gap
		2 如果在计算中， 跳过某一个空箱子，得到的gap一定会大于interval
	
	如果有 n - 2个数字， 箱子数目多于N-2， 就一定会有空箱子。
	interval = (max - min) / 箱子数目
		因为我们想interval 尽可能大， 因此将箱子数目取得最小，但同时要满足 箱子数目 > n - 2
		因此，箱子数目为n - 1
	So interval = (max - min) / (n - 1) 向上取整
		比如原来范围是[0, 5.5], 内部最大gap = 5 - 0  向上取整，变成[0, 6) 
		内部最大gap依然是5-0

    我们把 0 3 4 6 23 28 29 33 38 依次装到三个箱子中
        0            1            2           3
     -------      -------      -------     ------- 
    |  3 4  |    |       |    | 29    |   | 33    |
    |   6   |    |       |    |  23   |   |       |
    |  0    |    |       |    |  28   |   |  38   |
     -------      -------      -------     ------- 
      0 - 9       10 - 19      20 - 29     30 - 39
    我们把每个箱子的最大值和最小值表示出来
     min  max     min  max     min  max  min  max 
     0     6      -     -      23   29   33   38
*/
public int maximumGap(int[] nums) {
    if (nums.length <= 1) 
        return 0;
    
    int n = nums.length;
    int min = nums[0];
    int max = nums[0];
    //找出最大值、最小值
    for (int i = 1; i < n; i++) 
    {
        min = Math.min(nums[i], min);
        max = Math.max(nums[i], max);
    }
    
    if(max - min == 0) 
        return 0;
    
	
    //算出每个箱子的范围
    int interval = (int) Math.ceil((double)(max - min) / (n - 1));
    
    //每个箱子里数字的最小值和最大值
    int[] bucketMin = new int[n - 1];
    int[] bucketMax = new int[n - 1];
    
    //最小值初始为 Integer.MAX_VALUE
    Arrays.fill(bucketMin, Integer.MAX_VALUE);
    //最大值初始化为 -1，因为题目告诉我们所有数字是非负数
    Arrays.fill(bucketMax, -1);

    //考虑每个数字
    for (int i = 0; i < nums.length; i++) {
        //当前数字所在箱子编号
        int index = (nums[i] - min) / interval;
        //最大数和最小数不需要考虑
        if(nums[i] == min || nums[i] == max) 
            continue;
        
        //更新当前数字所在箱子的最小值和最大值
        bucketMin[index] = Math.min(nums[i], bucketMin[index]);
        bucketMax[index] = Math.max(nums[i], bucketMax[index]);
    }
	 
    int maxGap = 0;
    //min 看做第 -1 个箱子的最大值
    int previousMax = min;
    //从第 0 个箱子开始计算
    for (int i = 0; i < n - 1; i++) {
        //最大值是 -1 说明箱子中没有数字，直接跳过
        if (bucketMax[i] == -1) 
            continue;
        
        
        //当前箱子的最小值减去前一个箱子的最大值
        maxGap = Math.max(bucketMin[i] - previousMax, maxGap);
        previousMax = bucketMax[i];
    }
    
    //最大值可能处于边界，不在箱子中，需要单独考虑
    maxGap = Math.max(max - previousMax, maxGap);
    return maxGap;

}

作者：windliang
链接：https://leetcode-cn.com/problems/maximum-gap/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--39/
```







# 165 Compare Version Numbers

![image-20200711134655440](101-200.assets/image-20200711134655440.png)

![image-20200808202529775](101-200.assets/image-20200808202529775.png)

```java
public int compareVersion(String version1, String version2) {

    String[] strs1 = version1.split("\\.");
    String[] strs2 = version2.split("\\.");

    int i = 0;
    for(; i < strs1.length && i < strs2.length; i++)
    {
        int num1 = Integer.parseInt(strs1[i]);
        int num2 = Integer.parseInt(strs2[i]);

        if(num1 > num2)
            return 1;
        else if(num1 < num2)
            return -1;
        else    
            continue;
    }

    while(i < strs1.length)
        if(Integer.parseInt(strs1[i]) > 0)
            return 1;
    else
        i++;
    while(i < strs2.length)
        if(Integer.parseInt(strs2[i]) > 0)
            return -1;
    else
        i++;

    return 0;
}
```







# 166 Fraction to Recurring Decimal 哈希Map的又一应用

![image-20200711140645870](101-200.assets/image-20200711140645870.png)



```java
/*
	使用HashMap 来存储余数，以及对应的索引。
	这样当相同的余数来临，我们就知道是否是重复了
	先处理整数部分，再处理小数部分
	
	
	这段代码写的相当优雅
*/

public class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        if (numerator == 0) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        
        // 处理符号
        res.append(((numerator > 0) ^ (denominator > 0)) ? "-" : "");
        long num = Math.abs((long)numerator);
        long den = Math.abs((long)denominator);
        
        // 处理整数
        res.append(num / den);
        num %= den;
        if (num == 0) 
            return res.toString();
        
        
        // 处理小数部分
        res.append(".");
        HashMap<Long, Integer> map = new HashMap<Long, Integer>();
        map.put(num, res.length());
        while (num != 0) {
            num *= 10;
            res.append(num / den);
            //这里就相当于拿到每次的余数，如果在一个过程中，余数重复了，说明就是重复小数
            num %= den;	
            if (map.containsKey(num)) {
                int index = map.get(num);
                res.insert(index, "(");
                res.append(")");
                break;
            }
            else {
                //记录不同的余数出现的位置是哪里，便于插入括号
                map.put(num, res.length());
            }
        }
        return res.toString();
    }
}
/*
	对于 14/17 举例,下面这个数字是num每次被den取余后的结果，一旦发现出现重复4， 就停止，因为下面的操作就会重复
			4 6 9 5 16 7 2 3 13 11 8 12 1 10 15 14 4
*/
```



# 168 Excel Sheet Column Title

![image-20200711144821738](101-200.assets/image-20200711144821738.png)



```java
/*
每一次除以26， 都会把右侧的数字给除掉
A   0x26 + 1     AA    1x26+ 1     BA  2×26+ 1     ...     ZA  26×26+ 1     AAA  1×26²+1×26+ 1
B   0x26 + 2     AB    1x26+ 2     BB  2×26+ 2     ...     ZB  26×26+ 2     AAB  1×26²+1×26+ 2
.   .     ..    .....     ..  .......     ...     ..  ........     ...  .............   
.   .     ..    .....     ..  .......     ...     ..  ........     ...  .............
.   .     ..    .....     ..  .......     ...     ..  ........     ...  .............
Z  0x26 + 26     AZ    1x26+26     BZ  2×26+26     ...     ZZ  26×26+26     AAZ  1×26²+1×26+26

*/

//为了保证能拿到A， 我们会先给n-1， 因为 %26 ==0， 代表是26 -> Z, 
//当n = 1， bit == 0， 代表是A
//当n = 26， bit == 25， 代表是Z
// use (n-1)%26 instead, then we get a number range from 0 to 25.
public String convertToTitle(int n) {
    StringBuilder res = new StringBuilder();
    while(n != 0)
    {
        int bit = (n-1) % 26;
        res.append((char)('A' + bit));
        n = (n-1) / 26;
    }
    return res.reverse().toString();
}
```





# 169 Majority Element

![image-20200711152656220](101-200.assets/image-20200711152656220.png)

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210508143327979.png" alt="image-20210508143327979" style="zoom:50%;" />

```java
//二刷
public int majorityElement(int[] nums) {
        int count = 1;
        int ele = nums[0];
        
        for(int i = 1; i < nums.length; i++){
            if(nums[i] == ele){
                count++;
            }else{
                count--;
                if(count == 0){
                    ele = nums[i];
                    count = 1;
                }
            }
        }
        
        return ele;
    }
```



![image-20200711152917802](101-200.assets/image-20200711152917802.png)

```java
public int majorityElement(int[] nums) {
    HashMap<Integer, Integer> map = new HashMap<>();

    for(int num : nums)
        map.put(num, map.getOrDefault(num, 0) + 1);

    int filter = nums.length / 2 ;

    for(Integer i : map.keySet())
        if(map.get(i) > filter)
            return i;
    return -1;
}
```



# 170 Two Sum III data structure

![image-20200711154458226](101-200.assets/image-20200711154458226.png)

![image-20200711154443348](101-200.assets/image-20200711154443348.png)

```java
private HashSet<Integer> set;
private HashMap<Integer, Integer> list;
/** Initialize your data structure here. */
public TwoSum() {
    set = new HashSet<>();
    list = new HashMap<>();
}

/** Add the number to an internal data structure.. */
public void add(int number) {
    set.add(number);
    list.put(number, list.getOrDefault(number, 0) + 1);
}

/** Find if there exists any pair of numbers which sum is equal to the value. */
public boolean find(int value) {
    for(Integer i : set)
        if(set.contains(value-i))
            if(i != value - i)
                return true;
            else
                if(list.get(i) > 1)
                    return true;

    return false;
}
```



# 171 Excel Sheet Column Number

![image-20200711165750165](101-200.assets/image-20200711165750165.png)

![image-20200711170327730](101-200.assets/image-20200711170327730.png)

```java
public int titleToNumber(String s) {
    int n= 1;
    int res = 0;
    for(int i = s.length()-1; i >= 0; i--, n *= 26)
        res += (s.charAt(i) - 'A' + 1) * n;
    return res;
}
```





# 172 Factorial Trailing zeroes

![image-20200711170444200](101-200.assets/image-20200711170444200.png)



```java
/*
	思路：
	我们用n / 5, 可以筛选出比如5,15 35 等等的个数
	注意到25， 是 5 * 5 ，也就是说，如果我们只用n /5， 会导致漏掉一个
	而25*5= 125 有 3 个5， 会漏掉2个5
	因此，我们每次让n /5 就是为了计算对应的个数，从而不漏
*/
public int trailingZeroes(int n) {
    int count = 0;
    while (n > 0) {
        count += n / 5;
        n = n / 5;
    }
    return count;
}

作者：windliang
链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/xiang-xi-tong-su-de-si-lu-fen-xi-by-windliang-3/
```







# 174 Dungeon game 暂且略过











# 175 Combine Two Tables

![image-20200711174744841](101-200.assets/image-20200711174744841.png)

```mysql
#注意：如果没有某个人的地址信息，使用 where 子句过滤记录将失败，因为它不会显示姓名信息
select FirstName, LastName, City, State
from Person left join Address
on Person.PersonId = Address.PersonId;
```





# 176 Second Highest Salary

![image-20200711180812276](101-200.assets/image-20200711180812276.png)

```Mysql
# 用if null 解决，如果没有该记录的情况
SELECT
    IFNULL(
      (SELECT DISTINCT Salary
       FROM Employee
       ORDER BY Salary DESC
        LIMIT 1 OFFSET 1),
    NULL) AS SecondHighestSalary

"作者：LeetCode
链接：https://leetcode-cn.com/problems/second-highest-salary/solution/di-er-gao-de-xin-shui-by-leetcode/"
```









# 177 Sql 未完成



# 178 Sql 未完成







# 179 Largest Number 重写排序规则

![image-20200711181209263](101-200.assets/image-20200711181209263.png)



```java
    public String largestNumber(int[] nums) {
        List<String> res = new ArrayList<>();
        for(int num : nums)
            res.add(num + "");

        res.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                String str1 = o1 + o2;
                String str2 = o2 + o1;

                return str2.compareTo(str1);
            }
        });

        StringBuilder ans = new StringBuilder();
        for(int i = 0; i < res.size(); i++)
            ans.append(res.get(i));

        if(ans.charAt(0) == '0')
            return "0";
        return ans.toString();
    }

```









```java
/*
	思路是：希望拿到该数组的某种排列，使得对于每一个元素a,b都有
	a~b > b~a  这里~代表连接的意思
	
	那么可以理解为，需要我们重新定义排序规则
*/
class Solution {
    private class LargerNumberComparator implements Comparator<String> {
        @Override
        public int compare(String a, String b) {
            String order1 = a + b;
            String order2 = b + a;
           return order2.compareTo(order1);
        }
    }

    public String largestNumber(int[] nums) {
        // Get input integers as strings.
        String[] asStrs = new String[nums.length];
        for (int i = 0; i < nums.length; i++) 
            asStrs[i] = String.valueOf(nums[i]);
        

        // Sort strings according to custom comparator.
        Arrays.sort(asStrs, new LargerNumberComparator());

        // If, after being sorted, the largest number is `0`, the entire number
        // is zero.
        if (asStrs[0].equals("0")) 
            return "0";
        

        // Build largest number from sorted array.
        String largestNumberStr = new String();
        for (String numAsStr : asStrs) 
            largestNumberStr += numAsStr;
        

        return largestNumberStr;
    }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/largest-number/solution/zui-da-shu-by-leetcode/
```





# 180 Consecutive Numbers Sql 未完成











# 181 Employees Earning More Than Their Managers

<img src="101-200.assets/image-20210110164640658.png" alt="image-20210110164640658" style="zoom:50%;" />



```mysql
# Write your MySQL query statement below
select e.Name as Employee
from Employee e
where e.Salary > 
    (
        select Salary
        from Employee e1
        where e.ManagerId = e1.id
    )
```





# 182 Duplicate Emails

<img src="101-200.assets/image-20210110165136726.png" alt="image-20210110165136726" style="zoom:50%;" />

```mysql
SELECT Email
FROM Person
group by Email
having COUNT(Id) > 1
```







# 183 Customers Who Never Orders



<img src="101-200.assets/image-20210110165427439.png" alt="image-20210110165427439" style="zoom:50%;" />

```mysql
SELECT c.Name as Customers
FROM Customers as c
WHERE c.ID not in
    (SELECT DISTINCT CustomerID
    FROM Orders)
```





## 184 部门工资最高的员工

<img src="101-200.assets/image-20210110171811988.png" alt="image-20210110171811988" style="zoom:50%;" />

```mysql
SELECT 
    Department.Name AS Department,
    Employee.Name AS Employee,
    Salary
FROM 
    Employee,
    Department
WHERE Employee.DepartmentId = Department.Id
    AND 
    (Employee.DepartmentId, Employee.Salary)	/*注意这种写法*/
    IN (SELECT DepartmentId, max(Salary)
        FROM Employee
        GROUP BY DepartmentId
       )
```





















# 186 Reverse Words In a String II

![image-20200712075041787](101-200.assets/image-20200712075041787.png)

![image-20200712081124695](101-200.assets/image-20200712081124695.png)

```java
/*
	这种方式就是暴力解，我们下面试试双指针
*/
public void reverseWords(char[] s) {
    List<StringBuilder> jar = new ArrayList<>();

    int index = 0;
    while(index != s.length)
    {
        StringBuilder sb = new StringBuilder();
        while(index < s.length &&  s[index] == ' ')
            index++;
        while(index < s.length && s[index] != ' ')
            sb.append(s[index++]);
        jar.add(sb);
    }

    int indexx = 0;
    int num = jar.size()-1;
    while(num >= 0 && indexx < s.length)
    {
        int pointer = 0;
        StringBuilder sb = jar.get(num--);
        char[] chars = sb.toString().toCharArray();

        for(;pointer < chars.length;)
            s[indexx++] = chars[pointer++];
        if(indexx < s.length)
            s[indexx++] = ' ';
    }
}
```



```java
/*
	思路： 翻转两次字符串，一次全局，一次单个反转
*/
private void reverse(char[] s, int start, int end) {
        while (start < end) {
            char tmp = s[start];
            s[start] = s[end];
            s[end] = tmp;
            start++;
            end--;
        }
    }

public void reverseWords(char[] s) {
    // 两次翻转即可，第一次全局翻转，第二次翻转各个单词
    int len = s.length;
    reverse(s, 0, len - 1);

    int start = 0;
    for (int i = 0; i < len; i++) {
        if (s[i] == ' ') {
            // 翻转前面的单词
            reverse(s, start, i-1);
            start = i + 1;
        }
    }

    // 翻转最后一个单词
    reverse(s, start, len - 1);
}


作者：yuruiyin
链接：https://leetcode-cn.com/problems/reverse-words-in-a-string-ii/solution/java-liang-ci-fan-zhuan-by-npe_tle/
```





# 187 Repeated DNA Sequences



![image-20200712082220014](101-200.assets/image-20200712082220014.png)

![image-20200712085315225](101-200.assets/image-20200712085315225.png)

```java
public List<String> findRepeatedDnaSequences(String s) {
    List<String> res= new ArrayList<>();
    HashMap<String, Integer> map = new HashMap<>();

    for(int i = 0; i <= s.length() - 10; i++)
    {
        String frac = s.substring(i, i+10);
        map.put(frac, map.getOrDefault(frac, 0) + 1);
    }

    for(String str : map.keySet())
        if(map.get(str) > 1)
            res.add(str);

    return res;
}
```





# 189 Rotate Array



![image-20200712135721004](101-200.assets/image-20200712135721004.png)

![image-20200712140335831](101-200.assets/image-20200712140335831.png)

```java
public void rotate(int[] nums, int k) {
    if(nums.length == k)        return;
    if(nums.length < k)     k = k - nums.length;
    if(k == 0)      return;

    List<Integer> record = new ArrayList<>();
    for(int i = nums.length - k; record.size() < nums.length; i = (i+1) % nums.length)
        record.add(nums[i]);

    int index = 0;
    for(Integer i : record)
        nums[index++] = i;
}
```

![image-20200712140719651](101-200.assets/image-20200712140719651.png)

```java
public void rotate(int[] nums, int k) {
    if(nums.length == k || k == 0)        return;
    if(nums.length < k)     k = k - nums.length;

    int[] newNums = new int[nums.length];

    for(int i = nums.length - k,index = 0; index <nums.length; index++,i = (i+1)%nums.length)
        newNums[index] = nums[i];
    for(int i = 0; i < nums.length; i++)
        nums[i] = newNums[i];
}
```





# 190 Reverse Bits

![image-20200712141049804](101-200.assets/image-20200712141049804.png)



```java
public int reverseBits(int n)
{
    int res = 0;
    int count = 0;
    while(count < 32)
    {
        res <<= 1;	//左移一位，空出位置给下面的
        res |= (n & 1);	//把拿到的最低位给res
        n >>= 1;
        count++;
    }
    return res;
}
```



# 191 Number of 1 bits

![image-20200712142251319](101-200.assets/image-20200712142251319.png)

![image-20200712142445154](101-200.assets/image-20200712142445154.png)

```java
public int hammingWeight(int n) {
    int res = 0;
    int count = 0;
    while(count < 32)
    {
        res += (n & 1) == 1 ? 1 : 0;
        count++;
        n >>= 1;
    }
    return res;
}
```





# 192 Word Frequency -- Bash

![image-20200712142539849](101-200.assets/image-20200712142539849.png)







# 199 Binary Tree Right Side View



<img src="101-200.assets/image-20201224204528528.png" alt="image-20201224204528528" style="zoom:50%;" />

```java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        if(root == null)    return res;
        postOrder(root);

        Collections.reverse(res);
        return res;
    }

    public void postOrder(TreeNode root){
        if(root == null)    return;

        postOrder(root.left);

        postOrder(root.right);

        res.add(root.val);
    }
}
```





DFS 方法很巧妙

```java
    List<Integer> res = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 0); // 从根节点开始访问，根节点深度是0
        return res;
    }

    private void dfs(TreeNode root, int depth) {
        if (root == null) {
            return;
        }
        // 先访问 当前节点，再递归地访问 右子树 和 左子树。
        if (depth == res.size()) {   // 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。
            res.add(root.val);
        }
        depth++;
        dfs(root.right, depth);
        dfs(root.left, depth);
    }
}

作者：sweetiee
链接：https://leetcode-cn.com/problems/binary-tree-right-side-view/solution/jian-dan-bfsdfs-bi-xu-miao-dong-by-sweetiee/
```











# 200 Number of Islands









太慢了<img src="101-200.assets/image-20201224212315473.png" alt="image-20201224212315473" style="zoom:50%;" />



```java
class Solution {
    int row;
    int column;
    int[][] dir = {{1, 0},{-1, 0},{0, -1},{0, 1}};
    public int numIslands(char[][] grid) {
        row = grid.length;
        column = row == 0 ? 0 : grid[0].length;

        if(column == 0) return 0;
        HashSet<Integer> set = new HashSet<>();
        WeightedUnionFind wuf = new WeightedUnionFind(row * column);

        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                for(int k  = 0; k < 4; k++){
                    int newX = i + dir[k][0];
                    int newY = j + dir[k][1];
                    if(isInRange(newX, newY) && grid[i][j] == grid[newX][newY]){
                        wuf.union(node(i, j), node(newX, newY));
                    }
                }
        
            
        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(grid[i][j] == '1' && !set.contains(wuf.find(node(i, j)))){
                    set.add(wuf.find(node(i, j)));
                }
        
        return set.size(); 
        
    }

    public boolean isInRange(int i, int j){ return i >= 0 && j >= 0 && i < row && j < column;}

    public int node(int i, int j){
        return i * column + j;
    }
}

class WeightedUnionFind{
    public int[] id;
    private int[] sz;
    private int count;

    public WeightedUnionFind(int N){
        this.count = 0;
        id = new int[N];
        sz = new int[N];
        for(int i = 0; i < N; i++){
            id[i] = i;
            sz[i] = 1;
        }
    }

    public int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        return p;
    }

    public boolean connected(int p, int q){return find(p) == find(q);}

    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)  return;

        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = pRoot;
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = qRoot;
        }

      
    }
}
```







![image-20201224212353171](101-200.assets/image-20201224212353171.png)

```java
class Solution {
    int row;
    int column;
    int res = 0;
    public int numIslands(char[][] grid) {
        row = grid.length;
        column = row == 0 ? 0 : grid[0].length;

        if(column == 0)     return 0;

        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(grid[i][j] == '1'){
                    dfs(grid, i, j);
                    res += 1;
                }

        return res;
    }


    private void dfs(char[][] grid, int i, int j){
        if(isInRange(i, j) && grid[i][j] == '1'){
            grid[i][j] = '-';

            dfs(grid, i + 1, j);
            dfs(grid, i - 1, j);
            dfs(grid, i, j + 1);
            dfs(grid, i, j - 1);
        }
    }

    public boolean isInRange(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < column;
    }
}
```















