# 801 Minimum Swaps To Make Sequences Increasing



```cpp
//典型dp
/*
	ref:https://www.youtube.com/watch?v=_XAmQQVhvy8
	主要看和区间的关系
*/
class Solution {
public:
    int minSwap(vector<int>& nums1, vector<int>& nums2) {
        int unchanged = 0, changed = 1;
        for(int i = 1; i < nums1.size(); i++){
            int unchanged_prev = unchanged;
            int changed_prev   = changed;

            unchanged = INT_MAX;
            changed   = INT_MAX;
            if(nums1[i - 1] < nums1[i] && nums2[i - 1] < nums2[i])
                unchanged = min(unchanged, unchanged_prev);
            if(nums2[i - 1] < nums1[i] && nums1[i - 1] < nums2[i])
                unchanged = min(unchanged, changed_prev);
            if(nums1[i - 1] < nums2[i] && nums2[i - 1] < nums1[i])
                changed   = min(unchanged_prev + 1, changed);
            if(nums1[i - 1] < nums1[i] && nums2[i - 1] < nums2[i])
                changed   = min(changed_prev + 1, changed);
        }

        return min(unchanged, changed);
    }
};
```







# 802 Find Eventual Safe Status

<img src="801-900.assets/image-20211126205035301.png" alt="image-20211126205035301" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> res;
    unordered_map<int, bool> map;
    unordered_set<int> visited;
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        /*
            thinking process
                1. using DFS to traversal all nodes

                2. check if all possible paths can be terminaled
                    if yes, we mark this node to be safe
                    if no, we mark this node to be unsafe

                3. return res;
        */
        for(int i = 0; i < graph.size(); i++){
            dfs(graph, i);
            if(map[i])
                res.push_back(i);
        }

        return res;
    }

    //return true if this node is isolated
    //return false if not
    bool dfs(vector<vector<int>>& graph, int curNode){
        if(map.count(curNode) != 0)
            return map[curNode];

        if(visited.count(curNode) != 0){
            return false;
        }

        visited.insert(curNode);
        int size = graph[curNode].size();

        //has no outgoing path, definitely a safe and terminal node
        //or it could just be an isloated node
        if(size == 0){
            map[curNode] = true;
            visited.insert(curNode);
            return true;
        }


        int count = 0;
        for(int i = 0; i < size; i++){
            if(curNode == graph[curNode][i])
                continue;

            if(dfs(graph, graph[curNode][i])){
                count++;
            }
        }

        if(count == size){
            map[curNode] = true;
        }else
            map[curNode] = false;


        return map[curNode];
    }
};

```









# 804 Unique Morse Code Words

<img src="image-20210510162506503.png" alt="image-20210510162506503" style="zoom:50%;" />

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210510162454938.png" alt="image-20210510162454938" style="zoom:50%;" />

```java

    static String[] alpha = {".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."};
    public int uniqueMorseRepresentations(String[] words) {
        Set<String> set = new HashSet<>();
        for(String str : words)
            set.add(getStr(str));
        return set.size();
    }

    private String getStr(String str){
        StringBuilder res = new StringBuilder();
        for(char ch : str.toCharArray()){
            res.append(alpha[ch - 'a']);
        }
        
        return res.toString();
    }
```









# 805 Split Array With Same Average



```cpp
//超时，通过 52 / 92
class Solution {
public:
    bool splitArraySameAverage(vector<int>& nums) {
        int size = nums.size();
        if(size <= 1)
            return false;

        int sum = 0;
        for(int num : nums)
            sum += num;
        
        sort(nums.begin(), nums.end());
        //the size A should have
        for(int i = 1; i <= size / 2; i++){
            double totalSum = sum * 1.0 * (i *1.0) / size;
            double temp;
            if(modf(totalSum, &temp) != 0 || modf(sum * 1.0 - totalSum, &temp) != 0)
                continue;

            if(backtrack(nums, i, totalSum, 0, 0, 0))
                return true;
        }

        return false;
    }

    bool backtrack(vector<int>& nums, int size, int totalSum, int curSum, int curNum, int index){
        if(curNum == size){
            if(curSum == totalSum)
                return true;
            return false;
        }

        for(int i = index; i < nums.size(); i++){
            if(curSum + nums[i] > totalSum)
                break;

            if(backtrack(nums, size, totalSum, curSum + nums[i], curNum + 1, i + 1))
                return true;
        }

        return false;
    }
};
```









# 807 Max Increase to Keep City Skyline



<img src="801-900.assets/image-20210630092222993.png" alt="image-20210630092222993" style="zoom:50%;" />

```cpp
class Solution {
public:
    int min(int i, int j){
        return i >= j ? j : i;
    }
    
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        int row = grid.size();
        int col = grid[0].size();
        
        vector<int> rowLine(row, 0);
        vector<int> colLine(col ,0);
        
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                rowLine[i] = rowLine[i] > grid[i][j] ? rowLine[i] : grid[i][j];
                colLine[j] = colLine[j] > grid[i][j] ? colLine[j] : grid[i][j];
            }
        }
        
        int res = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                int standard =  min(rowLine[i], colLine[j]);
                if(grid[i][j] < standard){
                    res += standard - grid[i][j];
                }
            }
        }
        
        return res;
    }
};
```





# 809 Expressive Words

<img src="801-900.assets/image-20211128195810794.png" alt="image-20211128195810794" style="zoom:50%;" />

```cpp
class Solution {
public:
    int expressiveWords(string s, vector<string>& words) {
        auto v = getRes(s);
        int size = v.size();
        int count = 0;
        for(string& word : words){
            auto temp = getRes(word);
            if(size != temp.size())
                continue;
            
            int index = 0;
            int add = 1;
            for(int i = 0; i < size; i++){
                if(v[i].first != temp[i].first || v[i].second < temp[i].second){
                    add = 0;
                    break;
                }

                if(v[i].second > temp[i].second && v[i].second == 2){
                    add = 0;
                    break;
                }

            }

            if(add == 1)
                count++;
        }

        return count;
    }

    vector<pair<int, int>> getRes(string& s){
        vector<pair<int, int>> res;
        int left = 0, right = 0;
        int size = s.size();
        while(right < size){
            while(right < size && s[right] == s[left])
                right++;
            
            res.push_back({s[left], right - left});
            left = right;
        }

        return res;
    }
};
```









# 811 Subdomain Visit Count

<img src="801-900.assets/image-20210518164329035.png" alt="image-20210518164329035" style="zoom:50%;" />

```go

func subdomainVisits(cpdomains []string) []string {
	m := make(map[string]int)

	for _, str := range cpdomains{
		splits := strings.Fields(str)
		strs :=  strings.Split(splits[1], ".")
		num, ok := strconv.Atoi(splits[0])
		if ok == nil{
			rawString := ""

			for i := len(strs) - 1; i >= 0; i--{
                newString := ""
                if i == len(strs) - 1{
                    newString = strs[i]
                }else{
    				newString = strs[i] + "." + rawString
                }

				m[newString] += num
				rawString = newString
			}
		}
	}

	res := make([]string, 0)
	for key, val := range m{
		res = append(res, strconv.Itoa(val) + " " + key)
	}
	
	return res
}
```









# 812 Largest Triangle Area

<img src="801-900.assets/image-20211130093358502.png" alt="image-20211130093358502" style="zoom:50%;" />

```cpp
//暴力求解
class Solution {
public:
    double largestTriangleArea(vector<vector<int>>& points) {
        int N = points.size();
        double ans = 0;
        for (int i = 0; i < N; ++i)
            for (int j = i+1; j < N; ++j)
                for (int k = j+1; k < N; ++k)
                    ans = max(ans, area(points[i], points[j], points[k]));
        return ans;
    }

    double area(vector<int>& P, vector<int>& Q, vector<int>& R) {
        return 0.5 * abs(P[0]*Q[1] + Q[0]*R[1] + R[0]*P[1]
                             -P[1]*Q[0] - Q[1]*R[0] - R[1]*P[0]);
    }

};

```









# 813 Largest Sum of Averages

<img src="801-900.assets/image-20211129150337323.png" alt="image-20211129150337323" style="zoom:50%;" />

```cpp
/*
ref: https://github.com/wisdompeak/LeetCode/blob/master/Dynamic_Programming/813.Largest-Sum-of-Averages/813.Largest-Sum-of-Averages.cpp
	本质就是 区间型 dp
		dp[i][k]
			从 nums[0...i] 分成 k份能有几个
				那么需要找到分割点 j
				dp[i][k] = max(dp[i][k], avg[i:j] + dp[j - 1][k - 1]);
*/
class Solution {
public:
    double largestSumOfAverages(vector<int>& A, int pieces) {
        int N = A.size();
        auto dp = vector<vector<double>>(N + 1, vector<double>(pieces + 1, 0));

        A.insert(A.begin(), 0);
        for(int i = 1; i <= N; i++){
            dp[i][0] = INT_MIN / 10;
        }

        for(int i = 1; i <= N; i++){
            for(int k = 1; k <= min(i, pieces); k++){
                double sum = 0;
                for(int j = i; j >= k; j--){
                    sum += A[j];
                    dp[i][k] = max(dp[i][k], 
                        dp[j - 1][k - 1] + sum * 1.0 / (i - j + 1));
                }
            }
        }

        double res = 0;
        for(int k = 1; k <= pieces; k++){
            res = max(res, dp[N][k]);
        }

        return res;
    }
};
```









# 819 Most Common Word

<img src="801-900.assets/image-20211128173428342.png" alt="image-20211128173428342" style="zoom:50%;" />

```cpp
class Solution {
public:
    string mostCommonWord(string paragraph, vector<string>& banned) {
        unordered_map<string, int> map;
        unordered_set<string> set;
        for(auto& str : banned)
            set.insert(str);
        
        paragraph = paragraph;
        int left = 0, right = 0;
        int size = paragraph.size();
        int maxFreq = 0;
        string res;
        while(right < size){
            while(right < size && isalpha(paragraph[right])){
                right++;
            }

            if(left == right){
                left++;
                right = left;
                continue;
            }

            string word2 = paragraph.substr(left, right - left);
            string word;
            for(char ch : word2)
                word.push_back(tolower(ch));

            if(set.count(word) == 0){
                map[word]++;

                if(map[word] > maxFreq){
                    maxFreq = map[word];
                    res = word;
                }
            }

            if(right == size)
                break;

            left = right + 1;
            right = left;
        }

        return res;
    }
};
```









# 827 Making a Large Island



![image-20210916094044165](801-900.assets/image-20210916094044165.png)

```cpp
/*
		并查集的板子
		Author: guoguo
		09/16
*/
class WeightedUnionFind{
public:
    vector<int> id;
    vector<int> sz;

    WeightedUnionFind(int N) : id(vector<int>(N, 0)), sz(vector<int>(N, 1)){
        for(int i = 0; i < N; i++)
            id[i] = i;
    }

    void uni(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)
            return;

        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }
    }

    bool isConnected(int p, int q){
        return find(p) == find(q);
    }

    int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }

};

class Solution {
public:
    vector<vector<bool>> visited;
    int dir[4][2] = {{-1, 0},{0, -1},{1, 0},{0, 1}};
    int row;
    int col;
    vector<vector<int>> myGrid;
    int largestIsland(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();
        myGrid = grid;
        visited = vector<vector<bool>>(row, vector<bool>(col, false));

        WeightedUnionFind wuf(550 * 550);

        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 1 && !visited[i][j])
                    dfs(grid, i, j, i, j, wuf);
            }
        }

        int res = 0;
        if(wuf.sz[wuf.find(getCoor(0, 0))] == row * col)
            return row * col;

        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 0){
                   int tempRes = 0;
                   for(int k = 0; k < 4; k++){
                       int newX = i + dir[k][0];
                       int newY = j + dir[k][1];

                       bool calculateBefore = false;
                       for(int m = k - 1; m >= 0; m--){
                           int coorNew = getCoor(newX, newY);
                           int coorM   = getCoor(i + dir[m][0], j + dir[m][1]);

                           if(isInRangeAndValueOne(newX, newY) && isInRangeAndValueOne(i + dir[m][0], j + dir[m][1])
                                && wuf.isConnected(coorNew, coorM)) {
                               calculateBefore = true;
                               break;
                           }
                       }

                       if(!calculateBefore && isInRange(newX, newY) && grid[newX][newY] == 1){
                           tempRes += wuf.sz[wuf.find(getCoor(newX, newY))];
                       }
                   }

                   res = max(res, 1 + tempRes);
                }
            }
        }

        return res;
    };

    void dfs(vector<vector<int>>& grid, int curI, int curJ, int i, int j, WeightedUnionFind& wuf){
        visited[curI][curJ] = true;

        wuf.uni(getCoor(curI, curJ), getCoor(i, j));

        for(int k = 0; k < 4; k++){
            int newI = curI + dir[k][0];
            int newJ = curJ + dir[k][1];

            if(isInRange(newI, newJ) && !visited[newI][newJ] && grid[newI][newJ] == 1)
                dfs(grid, newI, newJ, i, j, wuf);
        }
    }

    int getCoor(int i, int j){
        return i * col + j;
    }

    bool isInRangeAndValueOne(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < col && myGrid[i][j] == 1;
    }

    bool isInRange(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < col;
    }
};
```







# 828 Count Unique Characters of All Substrings of a Given String

<img src="801-900.assets/image-20210806215438050.png" alt="image-20210806215438050" style="zoom:50%;" />

```cpp
class Solution {
public:
    int uniqueLetterString(string s) {
        int size = s.size();

        auto leftIndex  = vector<int>(size, -1);
        auto rightIndex = vector<int>(size, -1);
        auto alpha      = vector<int>(26, -1);

        for(int i = 0; i < size; i++){
            char ch = s[i];
            int pos = ch - 'A';

            if(alpha[pos] != -1)
                leftIndex[i] = alpha[pos];

            alpha[pos] = i;
        }
        
        alpha = vector<int>(26, -1);
        for(int i = size - 1; i >= 0; i--){
            char ch = s[i];
            int pos = ch  - 'A';
            
            if(alpha[pos] != -1)
                rightIndex[i] = alpha[pos];

            alpha[pos] = i;

//            cout << rightIndex[i] << " ";
        }

        int res = 0;
        for(int i = 0; i < size; i++){
            int left;
            int right;
            if(leftIndex[i] == -1)
                left = i + 1;
            else 
                left = i - leftIndex[i];

            if(rightIndex[i] == -1)
                right = size - i;
            else
                right = rightIndex[i] - i;

            res += left * right;
        }

        return res;
    }
};
```















```cpp
//思路实际上就是 通过扩散
/*
	找到 每一个字符的不重复长度，然后进行求解
	
	比如 L E E T C O D E
	          3
		找到 T 的不重复空间 [0, size - 1]
		那么 可以组成的字符串个数为
		
		 4 * 5 = 20
		
*/
class Solution {
public:
    const int mod = 1e9 + 7;
    int uniqueLetterString(string s) {
        int size = s.size();
        int left = 0, right = size - 1;

        vector<int> alpha(26, -1);
        vector<int> leftIndex(size, -1);
        vector<int> rightIndex(size, -1);

        for(int i = 0; i < size; i++){
            leftIndex[i] = alpha[s[i] - 'A'];
            alpha[s[i] - 'A'] = i;
        }

        std::fill(alpha.begin(), alpha.end(), size);

        for(int i = size - 1; i >= 0; i--){
            rightIndex[i] = alpha[s[i] - 'A'];
            alpha[s[i] - 'A'] = i;
        }

        int res = 0;
        for(int i = 0 ; i < size; i++){
            long left = i - leftIndex[i];
            long right = rightIndex[i] - i;

            res = (res + (left * right) % mod) % mod;
        }

        return res;
    }
};
```







# 833 Find And Replace in String

<img src="801-900.assets/image-20210926214402996.png" alt="image-20210926214402996" style="zoom:50%;" />

```cpp
class Solution {
public:
    string findReplaceString(string s, vector<int>& indices, vector<string>& sources, vector<string>& targets) {
        int size = indices.size();
        
        //this is used to get the corresponding result after replacement
        //we do not do any replace in place
        unordered_map<int, pair<string, string>> map;
        
        //step1 go througth all the strings and check the replacement
        for(int i = 0; i < size; i++){
            int index   = indices[i];
            string& str = sources[i];
            
            if(s.find(str, index) == index){
                map[index] = {str, targets[i]};
            }
        }
        
        //step2 -> concatanation the string based on map and return
        string res = "";
        for(int i = 0; i < s.size();){
            if(map.count(i) == 0){ // no replacement occurs
                res.push_back(s[i]);
                i++;
            }else{
                res += map[i].second;
                i += map[i].first.size();
            }
        }
            
        return res;
    }
};
```







# 836 Overlapping Rec 很棒的思路



```cpp
class Solution {
public:
    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        if(rec1[0] == rec1[2] || rec1[1] == rec1[3] ||
            rec2[0] == rec2[2] || rec2[1] == rec2[3])
            return false;

        bool horizontal = !(rec1[2] <= rec2[0] || rec2[2] <= rec1[0]);
        bool vertical   = !(rec1[3] <= rec2[1] || rec2[3] <= rec1[1]);

        return horizontal && vertical;
    }
};
```









# 837 New 21 Game

<img src="801-900.assets/image-20210930170604050.png" alt="image-20210930170604050" style="zoom:50%;" />

```cpp
/*
		典型 dp 问题
		比如 21点 ， 17点后不能加牌
		
		那么 26 是我能够拿到的最大的数字
		
		15 16 17 18 19 20 21 22 23 24 25 26
P:				1 	1	1	 1	 1	0	0 	0	0  0

	计算 P(16) = sum(p17-p26) / 10 = 0.5
	P(15) = sum(p16-p25) / 10 = 0.55
	...
*/
class Solution {
public:
    double new21Game(int N, int K, int W) {
        vector<double> dp(N + W, 0);
        std::fill(dp.begin() + K, dp.begin() + min(K + W - 1, N) + 1, 1);
//        for(int i = K; i <= min(K + W - 1, N); i++)
//            dp[i] = 1;
        
        double sumPro = 0;
        for(int i = K - 1; i >= 0; i--){
            if(i == K - 1){
                sumPro += min(K + W - 1, N) - i;
                dp[i] = sumPro / W;
            }else{
                sumPro = sumPro + dp[i + 1] - dp[i + 1 + W];
                dp[i] = sumPro / W;
            }
            
        }
        
        return dp[0];
    }
};
```







# 841 Key and Rooms

<img src="801-900.assets/image-20210519171717843.png" alt="image-20210519171717843" style="zoom:50%;" />

```go

func canVisitAllRooms(rooms [][]int) bool {
	queue := make([]int, 0)
	m := make(map[int]bool)

	queue = append(queue, 0)

	for ; len(queue) != 0; {
		size := len(queue)

		for i := 0; i < size; i++{
			cur := queue[0]
			queue = queue[1 : ]
			m[cur] = true
			canOpenRooms := rooms[cur]

			for j := 0;  j < len(canOpenRooms); j++{
				if !m[canOpenRooms[j]]{
					queue = append(queue, canOpenRooms[j])
				}
			}
		}
	}

	return len(m) == len(rooms)
}
```





# 843 Guess the Word



```cpp
//ref: https://github.com/wisdompeak/LeetCode/blob/master/Others/843.Guess-the-Word/843.Guess-the-Word.cpp
/*
		每次保留和当前相似度一样的元素， 其他的不可能是我们的target
*/
class Solution {
public:
    void findSecretWord(vector<string>& wordlist, Master& master) 
    {
        for (int i=0; i<10; i++)
        {
            int r = rand() % wordlist.size();
            string x = wordlist[r];
            int count = master.guess(x);
            if (count==6) return;
            
            vector<string>temp;
            for (auto s:wordlist)
            {
                if (s==x) continue;
                if (sameCount(s,x)==count) temp.push_back(s);
            }
            wordlist = temp;
        }
    }
    
    int sameCount(string A, string B)
    {
        int count=0;
        for (int i=0; i<6; i++)
            if (A[i]==B[i]) count++;
        return count;
    }
};
```









# 847 Shortest Path Visiting All Nodes

<img src="801-900.assets/image-20210803213908379.png" alt="image-20210803213908379" style="zoom:50%;" />

```cpp
/*
		根据 不同的二进制位， 表示是否访问过
*/
struct pair_hash
{
    template <class T1, class T2>
    std::size_t operator () (std::pair<T1, T2> const &pair) const
    {
        std::size_t h1 = std::hash<T1>()(pair.first);
        std::size_t h2 = std::hash<T2>()(pair.second);

        return h1 ^ h2;
    }
};

class Solution {
public:
    int shortestPathLength(vector<vector<int>>& graph) {
        int maxNum = graph.size() - 1;

        unordered_set<pair<int, int>, pair_hash> visited;
        queue<vector<int>> myQueue;
        const int finalState = (1 << (maxNum + 1)) - 1;
        for(int i = 0; i < maxNum + 1; i++){
            int state = 1 << i;
            myQueue.push({i, state});
        }

        int round = 0;
        while(!myQueue.empty()){
            int size = myQueue.size();

            for(int i = 0; i < size; i++){
                vector<int> curState = myQueue.front(); myQueue.pop();
                int curNode = curState[0];
                int key = curState[1];
                visited.insert({curNode, key});

                if(key == finalState)
                    return round;

                for(int nextPos : graph[curNode]){
                    int nextKey = key | (1 << nextPos);

                    pair<int, int> nextNode = {nextPos, nextKey};
                    if(visited.count(nextNode) == 0){
                        visited.insert(nextNode);
                        myQueue.push({nextPos, nextKey});
                    }
                }
            }

            round++;
        }

        return -1;
    }
};
```









# 852 Peak Index in a Mountain Array



<img src="801-900.assets/image-20210906144237565.png" alt="image-20210906144237565" style="zoom:50%;" />

```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& arr) {
        int size = arr.size();
        int left = 0, right = size - 1;
        while(left <= right){
            int mid = (left + right) / 2;
//            cout << mid << endl;
            if(mid == 0)
                return 1;
            else if(mid == size - 1)
                return size - 2;


            if(arr[mid] > arr[mid - 1] && arr[mid] > arr[mid + 1])
                return mid;
            else if(arr[mid] > arr[mid - 1] && arr[mid] < arr[mid + 1])
                left = mid + 1;
            else
                right = mid - 1;
        }

        return -1;
    }
};
```









# 857 Minimum Cost to Hire K Workers

<img src="801-900.assets/image-20210806091922580.png" alt="image-20210806091922580" style="zoom:50%;" />

```cpp
//ref: https://www.youtube.com/watch?v=ZHFRB58hlQw&t=548s
/*
	当 出现两个评价指标的时候， 可以考虑 sort + pq
	
	在本题中， 可以把 wage[i] / quality[i] 作为评价指标，
	因为这个代表 《单位工作量工人的工资》， 而 对于要找 k个人，肯定是希望平均的支配工资最低
	
	那么如果 必须是这个人，我希望总的工作量最小， 因此会维护一个 k - 1 大的 pq 大顶堆
	
	很不错的思路
*/
class Solution {
public:
    static bool cmp(pair<int, int>& p1, pair<int, int>& p2){
        return (p1.second * 1.0 / p1.first) < (p2.second * 1.0 / p2.first);
    }

    double mincostToHireWorkers(vector<int>& quality, vector<int>& wage, int k) {
        vector<pair<int, int>> persons;
        for(int i = 0; i < quality.size(); i++)
            persons.push_back({quality[i], wage[i]});
        
        sort(persons.begin(), persons.end(), cmp);

        priority_queue<int> pq;
        int qualitySum = 0;
        double res = DBL_MAX;
        
        for(int i = 0; i < quality.size(); i++){
            while(pq.size() > k - 1){
                qualitySum -= pq.top();
                pq.pop();
            }

            double ratio = persons[i].second * 1.0 / persons[i].first;
            qualitySum += persons[i].first;

            if(pq.size() == k - 1)
                res = min(res, qualitySum * ratio);
            pq.push(persons[i].first);
        }

        return res;
    }
};
```





# 863 All Nodes Distance K in Binary Tree

<img src="801-900.assets/image-20210525082017898.png" alt="image-20210525082017898" style="zoom:50%;" />

<img src="801-900.assets/image-20210922084341577.png" alt="image-20210922084341577" style="zoom:50%;" />

```cpp

class Solution {
public:
        //    node itself, parent
    unordered_map<TreeNode*, TreeNode*> map;
    vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
        vector<int> res;
        if(root == NULL)
            return res;
        
        preorder(root);

        deque<TreeNode*> myQueue;
        unordered_set<TreeNode*> set;
        myQueue.push_back(target);
        set.insert(target);

        int steps = 0;
        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                TreeNode* curNode = myQueue.front(); myQueue.pop_front();

                if(k == steps){
                    res.push_back(curNode->val);
                    continue;
                }

                if(curNode->left != NULL){
                    if(set.count(curNode->left) == 0){
                        set.insert(curNode->left);
                        myQueue.push_back(curNode->left);
                    }
                }

                if(curNode->right != NULL){
                    if(set.count(curNode->right) == 0){
                        set.insert(curNode->right);
                        myQueue.push_back(curNode->right);
                    }
                }

                if(map[curNode] != NULL){
                    if(set.count(map[curNode]) == 0){
                        set.insert(map[curNode]);
                        myQueue.push_back(map[curNode]);
                    }
                }
            }

            steps++;
        }

        return res;
    }

    void preorder(TreeNode* root){
        if(root == NULL)
            return ;

        if(root->left != NULL)
            map[root->left] = root;
        
        if(root->right != NULL)
            map[root->right] = root;

        preorder(root->left);
        preorder(root->right);
    }
};
```







```java
    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {
        Map<TreeNode, List<TreeNode>> map = new HashMap<>();
        List<Integer> res = new ArrayList<>();

        if(k == 0){
            if(root != null){
                res.add(target.val);
            }

            return res;
        }
        preorder(map, root);
        Deque<TreeNode> queue = new ArrayDeque<>();
        Set<TreeNode> visited = new HashSet<>();
        queue.add(target);

        

        while(!queue.isEmpty()){
            int size = queue.size();
            k--;
            for(int i = 0; i < size; i++){
                TreeNode node = queue.removeFirst();
                visited.add(node);
                List<TreeNode> treeNodes = map.get(node);


                for(TreeNode node2 : treeNodes){
                    if(!visited.contains(node2))
                        queue.addLast(node2);
                }
            }

            if(k == 0){
                for(TreeNode node : queue){
                    res.add(node.val);
                }
            }
        }

        return res;
    }

    private void preorder(Map<TreeNode, List<TreeNode>> map, TreeNode root){
        if(root == null){
            return;
        }

        map.putIfAbsent(root, new ArrayList<>());
        if(root.left != null){
            map.get(root).add(root.left);
            map.putIfAbsent(root.left, new ArrayList<>());
            map.get(root.left).add(root);
        }

        if(root.right != null){
            map.get(root).add(root.right);
            map.putIfAbsent(root.right, new ArrayList<>());
            map.get(root.right).add(root);
        }

        preorder(map, root.left);
        preorder(map, root.right);
    }
```





# 864 Shortest Path to Get All Keys

<img src="801-900.assets/image-20210803203223329.png" alt="image-20210803203223329" style="zoom:50%;" />

```cpp
//source : https://happygirlzt.com/code/864.html
/*
	这个题目可以理解为一个加强版本的 BFS
	
	因为本身 如果只是搜集 钥匙， 没有锁， 那么 BFS 完全可以完成这个任务，
	
	但是因为有锁的限制， 所以 必须要对 锁的状态加以记录
	因此时间复杂度为 O(N * M * 2 ^ k)
	
	使用 vector<vector<vector<int>>> visited 进行状态的记录
*/
class Solution {
public:
    int shortestPathAllKeys(vector<string>& grid) {
        int row = grid.size();
        int col = grid[0].size();
        vector<vector<int>> dir{{-1, 0}, {0, -1}, {1, 0}, {0, 1}};

        int keys = 0;
        queue<vector<int>> myQueue;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                char ch = grid[i][j];
                if(ch == '@'){
                            //    x, y, curMove, have keys
                    myQueue.push({i, j, 0, 0});
                }else if(ch >= 'a' && ch <= 'z'){
                    keys++;
                }
            }
        }

        keys = (1 << keys) - 1;
        auto visited = 
            vector<vector<vector<int>>>(row, vector<vector<int>>(col, vector<int>(keys + 1, 0)));
        auto isInRange = [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};

        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                vector<int> curState = myQueue.front(); myQueue.pop();

                int x     = curState[0];
                int y     = curState[1];
                int moves = curState[2];
                int key   = curState[3];

                if(key == keys)
                    return moves;

                for(int k = 0; k < 4; k++){
                    int newX = x + dir[k][0];
                    int newY = y + dir[k][1];

                    if(isInRange(newX, newY) && grid[newX][newY] != '#'){
                        char ch = grid[newX][newY];

                        if(ch >= 'A' && ch <= 'Z'){
                            if( ((key >> (ch - 'A')) & 1) && visited[newX][newY][key] == 0){
                                myQueue.push({newX, newY, moves + 1, key});
                                visited[newX][newY][key] = 1;
                            }
                        }else if(ch >= 'a' && ch <= 'z'){
                            int newKey = (key | (1 << (ch - 'a')));
                            if(visited[newX][newY][newKey] == 0){
                                myQueue.push({newX, newY, moves + 1, newKey});
                                visited[newX][newY][newKey] = 1;
                            }
                        }else{
                            if(visited[newX][newY][key] == 0){
                               myQueue.push({newX, newY, moves + 1, key});
                                visited[newX][newY][key] = 1;
                            }
                        }
                    }
                }
            }
        }

        return -1;
    }
};
```







# 871 Minimum Number of Refueling

<img src="801-900.assets/image-20210930190230617.png" alt="image-20210930190230617" style="zoom:50%;" />

```cpp
class Solution {
public:
    int minRefuelStops(int target, int startFuel, vector<vector<int>>& stations) {
        if(target <= startFuel)
            return 0;
        
        priority_queue<int, vector<int>, less<>> pq;
        stations.push_back({target, 0});
        
        int curIndex = 0;
        int count = 0;
        while(curIndex < stations.size()){
//            cout << curIndex << endl;
            //cannot reach to the next station
            if((curIndex == 0 && stations[curIndex][0] > startFuel) ||
                (curIndex > 0 && startFuel < stations[curIndex][0] - stations[curIndex - 1][0])){
                if(pq.empty())
                    return -1;
                startFuel += pq.top(); pq.pop();
                count++;
            }else{
                if(curIndex == 0)
                    startFuel -= stations[curIndex][0];
                else
                    startFuel -= (stations[curIndex][0] - stations[curIndex - 1][0]);
                
                pq.push(stations[curIndex][1]);
                curIndex++;
            }
        }
        
        return count;
    }
};
```











# 875 Koko Eating Bananas

<img src="801-900.assets/image-20210930174649758.png" alt="image-20210930174649758" style="zoom:50%;" />

```cpp
/*
		典型的一个 二分查找 逆向思维
		
		既然不好说 啥speed ，那么就 二分
		
		类似题目
			410
*/
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        long left = 1;
        long right = 0;
        int size = piles.size();
        for(int num : piles)
            right += num;
        
        int ans = -1;
        while(left <= right){
            long mid = (left + right) / 2;
            int hour = getRes(piles, mid);
            
            if(hour <= h){
                ans = mid;
                right = mid - 1;
            }else{
                left = mid + 1;
            }
        }
        
        return ans;
    }
    
    int getRes(vector<int>& piles, int speed){
        int res = 0;
        for(int pile : piles){
            if(pile % speed == 0)
                res += pile / speed;
            else
                res += pile / speed + 1;
        }
        
        return res;
    }
};
```







# 876 Middle of the Linked List

<img src="801-900.assets/image-20211127180605780.png" alt="image-20211127180605780" style="zoom:50%;" />

```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        if(head == nullptr || head->next == nullptr)
            return head;

        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != nullptr && fast->next != nullptr){
            fast = fast->next->next;
            slow = slow->next;
        }

        return slow;
    }
};
```









# 887 Super Egg Drop



<img src="801-900.assets/image-20210730112517994.png" alt="image-20210730112517994" style="zoom:50%;" />

```cpp

//Author: guoguo
class Solution {
public:
    //                 eggs   floor
    int superEggDrop(int k, int n) {
        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= k; i++){
            dp[i][1] = 1;
        }

        for(int j = 1; j <= n; j++){
            dp[1][j] = j;
        }

        for(int i = 2; i <= k; i++){
            for(int j = 2; j <= n; j++){
                if(i > j){
                    dp[i][j] = dp[i - 1][j];
                }else{
                    //dp[i][j] = 1 + std::max(dp[i - 1][m - 1], dp[i][j - m]);

                    int left = 1, right = j;
                    int ans = left;
                    while(left <= right){
                        int mid = (left + right) / 2;

                        int f = dp[i - 1][mid - 1];
                        int g = dp[i][j - mid];

                        if(f >= g){
                            ans = mid;
                            right = mid - 1;

                            if(f == g)
                                break;
                        }else{
                            left = mid + 1;
                        }
                    }

                    dp[i][j] = 1 + std::max(dp[i - 1][ans - 1], dp[i][j - ans]);
                }
            }
        }


        return dp[k][n];
    }
};
```





```cpp
//超出时间限制，时间复杂度是 O(n2 * k)
class Solution {
public:
    //          eggs   floor
    int superEggDrop(int k, int n) {
        vector<vector<int>> dp(k + 1, vector<int>(n + 1, 0));
        for(int i = 1; i <= k; i++){
            dp[i][1] = 1;
        }

        for(int j = 1; j <= n; j++){
            dp[1][j] = j;
        }

        for(int i = 2; i <= k; i++){
            for(int j = 2; j <= n; j++){
                if(i > j){
                    dp[i][j] = dp[i - 1][j];
                }else{
                    for(int m = 1; m <= j; m++){
                        if(m == 1)
                            dp[i][j] = 1 + std::max(dp[i - 1][m - 1], dp[i][j - m]);
                        else
                            dp[i][j] = std::min(dp[i][j], 1 + std::max(dp[i - 1][m - 1], dp[i][j - m]));
                    }
                }
            }
        }

        return dp[k][n];
    }
};

```



```cpp
//po 一个 花花的超时代码
public:
	int superEggDrop(int K, int N){
    vector<vector<int>> m(K + 1, vector<int>(N + 1, INT_MAX));
    function<int(int, int)> dp = [&](int k, int n){
      if(k == 0)	return 0;
      if(k == 1)	return n;
			if(n <= 1)  return n;
      
      int& ans = m[k][n];
      if(ans != INT_MAX)	return ans;
      for(int i = 1; i <= n; i++)
        	ans = min(ans, 1 + max(dp(k - 1, i -1), dp(k, n - i)));
      
      return ans;
    }
    return dp(K, N);
  }
```







# 889 Construct Binary Tree From Preorder and Postorder



```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

//1 2 4 5 3 6 7
//4 5 2 6 7 3 1
//      i

    TreeNode* constructFromPrePost(vector<int>& preorder, vector<int>& postorder) {
        int size = preorder.size();
        if(size == 0)
            return nullptr;
        else if(size == 1)
            return new TreeNode(preorder[0]);

        TreeNode* root = new TreeNode(preorder[0]);

        int i = 0;
        for(; i < size; i++){
            if(preorder[1] == postorder[i]){
                i++;
                break;
            }
        }

//        cout << i << "----" << endl;
        vector<int> preorderLeft   = vector<int>(preorder.begin() + 1, preorder.begin() + i + 1);
//        cout << preorderLeft.size() << endl;
        vector<int> preorderRight  = vector<int>(preorder.begin() + i + 1, preorder.end());
//        cout << preorderRight.size() << endl;
        vector<int> postorderLeft  = vector<int>(postorder.begin(), postorder.begin() + i);
//        cout << postorderLeft.size() << endl;
        vector<int> postorderRight = vector<int>(postorder.begin() + i, postorder.end() - 1);
//        cout << postorderRight.size() << endl;

        root->left = constructFromPrePost(preorderLeft, postorderLeft);
        root->right = constructFromPrePost(preorderRight, postorderRight);

        return root;
    }
};
```







# 894 All Possible Full Binary Trees

<img src="801-900.assets/image-20211012134440128.png" alt="image-20211012134440128" style="zoom:50%;" />

```cpp
/*
	有点类似 96
*/
class Solution {
public:
    vector<TreeNode*> allPossibleFBT(int n) {
        if(n == 0 || n == 2)
            return {};
        else if(n == 1)
            return {new TreeNode(0)};

        vector<TreeNode*> res;
        int m = n - 1;
        for(int i = 1; i < m; i++){
            vector<TreeNode*> left  = allPossibleFBT(i);
            vector<TreeNode*> right = allPossibleFBT(m - i);

            for(TreeNode* l : left){
                for(TreeNode* r : right){
                    TreeNode* root = new TreeNode(0);
                    root->left = l;
                    root->right = r;

                    res.push_back(root);
                }
            }
        }

        return res;
    }
};
```







# 897 Increasing Order Search Tree

<img src="801-900.assets/image-20211125205705669.png" alt="image-20211125205705669" style="zoom:50%;" />

```cpp
class Solution {
public:
    TreeNode* increasingBST(TreeNode* root) {
        if(root == nullptr)
            return nullptr;
        else if(root->left == nullptr && root->right == nullptr)
            return root;

        TreeNode* resLeft  = increasingBST(root->left);
        TreeNode* resRight = increasingBST(root->right);

        root->right = resRight;
        if(resLeft == nullptr)
            return root;

        TreeNode* temp = resLeft;
        while(temp->right != nullptr)
            temp = temp->right;

        temp->right = root;
        root->left = nullptr;

        return resLeft;
    }
};
```









# 900 RLE Interator

<img src="801-900.assets/image-20210927182727864.png" alt="image-20210927182727864" style="zoom:50%;" />

```cpp
/*
		正常迭代， 我觉得 之后如果需要优化，可以采用 
*/
class RLEIterator {
public:
    int index;
    vector<int> v;
    RLEIterator(vector<int>& encoding) {
        v = encoding;
        index = 0;
    }
    
    int next(int n) {
        if(index >= v.size())
            return -1;
        
        if(n == 0){
            if(index < v.size())
                return index;
            return -1;
        }
        
        int curNum = v[index + 1];
        int freq   = v[index];
        
        if(freq == n){
            index += 2;
            n -= freq;
            return curNum;
        }else if(freq > n){
            v[index]  -= n;
            return curNum;
        }else{ // freq < n
            n -= freq;
            index += 2;
            return next(n);
        }
    }
};

```









