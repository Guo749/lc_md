

# 605 Can Place Flowers

<img src="601-700.assets/image-20210713085441947.png" alt="image-20210713085441947" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int index = 0;
        while(index < flowerbed.size() && n != 0) {
            while(index < flowerbed.size() && flowerbed[index] == 1)
                index++;
            
            if(index == flowerbed.size())
                break;
            
            if((index == 0 || (flowerbed[index - 1] == 0)) 
            && (index == flowerbed.size() - 1 || flowerbed[index + 1] == 0)){
                n--;
                index += 2;
            }else
                index++;
        }

        return n == 0;
    }
};
```







# 611 Valid Triangle Number



```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int res = 0;
        int size = nums.size();
        for(int i = 0; i < size - 2; i++){
            int k = i + 2;
            for(int j = i + 1; j < nums.size() - 1 && nums[i] != 0; j++){
                while(k < nums.size() && nums[i] + nums[j] > nums[k])
                    k++;
                res += k - j - 1;
            }
        }

        return res;
    }
};
```











# 617 Merge Two Binary Tree

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210510180733810.png" alt="image-20210510180733810" style="zoom:50%;" />

```java
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null || root2 == null){
            return root1 == null ? root2 : root1;
        }

        root1.val += root2.val;
        root1.left  = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);

        return root1;
    }s
```





# 621 Task Scheduler



```cpp
//ref: http://zxi.mytechroad.com/blog/greedy/leetcode-621-task-scheduler/
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> count(26, 0);        
        for (const char task : tasks) 
            ++count[task - 'A'];
        const int max_count = *max_element(count.begin(), count.end());
        size_t ans = (max_count - 1) * (n + 1);
        ans += count_if(count.begin(), count.end(),
                        [max_count](int c){ return c == max_count; });
        return max(tasks.size(), ans);
    }
};
```









# 638 Shopping Offers



<img src="601-700.assets/image-20210705081316748.png" alt="image-20210705081316748" style="zoom:50%;" />



```cpp
//暴力回溯
class Solution {
public:
    int minPrice = 0;
    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
        int sum = 0;
        for(int i = 0; i < price.size(); i++){
            sum += price[i] * needs[i];
        }

        minPrice = sum;

        backtrack(price, special, needs, 0);

        return minPrice;
    }

    int backtrack(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int expense){
        if(allSell(needs)){
            minPrice = min(minPrice, expense);
        }

        int res = minPrice;
        for(int i = 0; i < special.size(); i++){
            vector<int> sp = special[i];
            bool canUse = true;
            for(int j = 0; j < needs.size(); j++) {
                if (sp[j] > needs[j]) {
                    canUse = false;
                    break;
                }
            }

            if(canUse){
                for(int j = 0; j < price.size(); j++){
                    needs[j] -= sp[j];
                }

                res = min(backtrack(price, special, needs, expense + special[i][price.size()]), res);
                minPrice = (res + expense, minPrice);
                
                for(int j = 0; j < price.size(); j++){
                    needs[j] += sp[j];
                }
            }
        }

        int temp = 0;
        for(int i = 0; i < price.size(); i++){
            temp += price[i] * needs[i];
        }
     
        minPrice = min(temp + expense, minPrice);

        return res;
    }

    bool allSell(vector<int>& needs){
        for(int i = 0; i < needs.size(); i++){
            if(needs[i] != 0)
                return false;
        }

        return true;
    }

    int min(int i, int j){
        return i >= j ? j : i;
    }
};
```





# 647 Palindromic Substrings

<img src="601-700.assets/image-20210804202913413.png" alt="image-20210804202913413" style="zoom:50%;" />

```cpp
// 灵感来源第五题
class Solution {
public:
    int countSubstrings(string s) {
        int size = s.size();
        vector<vector<bool>> dp(size, vector<bool>(size, false));

        for(int i = 0; i < size; i++){
            dp[i][i] = true;
        }

        int count = 0;
        for(int i = size - 1; i >= 0; i--){
            for(int j = i + 1; j < size; j++){
                if(s[i] == s[j]){
                    if(i + 1 == j)
                        dp[i][j] = true;
                    else
                        dp[i][j] = dp[i + 1][j - 1];
                }

                if(dp[i][j])
                    count++;
            }
        }

        count += size;
        return count;
    }
};
```





# 652 Find Duplicate Subtrees

```cpp
class Solution {
public:
    unordered_map<string, vector<TreeNode*> > map;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        postorder(root, "");
        
        vector<TreeNode*> res;
        for(auto it = map.begin(); it != map.end(); it++){
            if(it->second.size() > 1){
                res.push_back(it->second[0]);
            }
        }
        
        return res;
    }
    
    string postorder(TreeNode* root, string path){
        if(root == nullptr)
            return "@";
        
        path += to_string(root->val);
        
        string leftS  = postorder(root->left, "");
        string rightS = postorder(root->right, "");
        
        path += "L" + leftS + "R" + rightS;
        
        map[path].push_back(root);
        
        return path;
    }
};
```





<img src="601-700.assets/image-20210722204340704.png" alt="image-20210722204340704" style="zoom:50%;" />

```cpp
class Solution {
public:
    unordered_map<string, vector<TreeNode*>> map;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        postorder(root);

        vector<TreeNode*> res;
        for(auto it = map.begin(); it != map.end(); it++){
            if(it->second.size() >= 2){
                res.push_back(it->second[0]);
            }
        }

        return res;
    }

    string postorder(TreeNode* root){
        if(root == nullptr)
            return "#";

        string left = postorder(root->left);
        string right = postorder(root->right);

        string cur = to_string(root->val) + ">"+ left +"<" + right;
        //cout << to_string(root->val) << " " << cur << endl;
        map[cur].push_back(root);
        return cur;
    }
};
```











# 654 Maximum Binary Tree

<img src="601-700.assets/image-20210519183246609.png" alt="image-20210519183246609" style="zoom:50%;" />

<img src="601-700.assets/image-20210519183238553.png" alt="image-20210519183238553" style="zoom:50%;" />

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func constructMaximumBinaryTree(nums []int) *TreeNode {
	return buildTree(nums, 0, len(nums) - 1)

}


func buildTree(nums []int, start int, end int) *TreeNode{
	if start > end{
		return nil
	}else if start == end{
		root := new(TreeNode)
		root.Val = nums[start]
		return root
	}
	
	index := start
	max := nums[start]

	for i := start; i <= end; i++{
		if max < nums[i]{
			index = i
			max   = nums[i]
		}
	}

	root := new(TreeNode)
	root.Val = max
	root.Left  = buildTree(nums, start, index  - 1)
	root.Right = buildTree(nums, index + 1, end)
	
	return root
}

```







# 650 2 Keys Keyboard 不错的DP 题目



```cpp
class Solution {
public:
    int minSteps(int n) {
        if(n == 1)
            return 0;
        vector<int> dp(n + 1, INT_MAX);
        dp[1] = 0;
        dp[2] = 2;

        for(int i = 3; i <= n; i++){
            dp[i] = i;

            for(int j = 2; j * j <= i; j++){
                if(i % j == 0)
                    dp[i] = dp[j] + dp[i / j];
            }
        }

        return dp[n];
    }
};
```







# 658 Find K Closet Elements

<img src="601-700.assets/image-20210922204811920.png" alt="image-20210922204811920" style="zoom:50%;" />

```cpp
/*
		优化采用二分
		author guoguo
		date 0922/2021
*/
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        if(arr.size() == k)
            return arr;
        //step1 to find the target index
        //if larger than any elements, return arr.size();
        //if smaller than any elements return -1
        //if there doesnot exist the element, we will return a close one

//        int posIndex = binarySearch(arr, x);
        int posIndex = -1;
        int size = arr.size();
        if(arr[0] >= x){
            return vector<int>(arr.begin(), arr.begin() + k);
        }else if(arr[size - 1] <= x) {
            return vector<int>(arr.end() - k, arr.end());
        }

        int left = 0, right = size - 1;
        int l, r;
        while(left <= right){
            int mid = (left + right) / 2;
            if(arr[mid] == x){
                l = mid;
                r = mid + 1;
                break;
            }else if(arr[mid] < x){
                if(arr[mid + 1] > x){
                    l = mid;
                    r = mid + 1;
                    break;
                }else{
                    left = mid + 1;
                }
            }else{//arr[mid] > x
                if(arr[mid - 1] < x){
                    l = mid - 1;
                    r = mid;
                    break;
                }else{
                    right = mid - 1;
                }
            }
        }
        
        //step2
        //using double points to solve this problem
        vector<int> res;
        while((l >= 0 || r < size) && res.size() < k){
            if(l < 0){
                res.push_back(arr[r++]);
            }else if(r >= size){
                res.push_back(arr[l--]);
            }else{
                if(abs(arr[l] - x) <= abs(arr[r] - x)){
                    res.push_back(arr[l--]);
                }else{
                    res.push_back(arr[r++]);
                }
            }
        }
        
        sort(res.begin(), res.end());
        return res;
    

    }
};
```



<img src="601-700.assets/image-20210922204241767.png" alt="image-20210922204241767" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        if(arr.size() == k)
            return arr;
        //step1 to find the target index
        //if larger than any elements, return arr.size();
        //if smaller than any elements return -1
        //if there doesnot exist the element, we will return a close one

//        int posIndex = binarySearch(arr, x);
        int posIndex = -1;
        int size = arr.size();
        if(arr[0] >= x){
            return vector<int>(arr.begin(), arr.begin() + k);
        }else if(arr[size - 1] <= x) {
            return vector<int>(arr.end() - k, arr.end());
        }

        int left, right;
        for(int i = 0; i < size - 1; i++){
            if(arr[i] == x){
                left = i;
                right = i + 1;
                break;
            }else if(arr[i] < x && arr[i + 1] > x){
                left = i;
                right = i + 1;
                break;
            }
        }
        
        //step2
        //using double points to solve this problem
        vector<int> res;
        while((left >= 0 || right < size) && res.size() < k){
            if(left < 0){
                res.push_back(arr[right++]);
            }else if(right >= size){
                res.push_back(arr[left--]);
            }else{
                if(abs(arr[left] - x) <= abs(arr[right] - x)){
                    res.push_back(arr[left--]);
                }else{
                    res.push_back(arr[right++]);
                }
            }
        }
        
        sort(res.begin(), res.end());
        return res;
    

    }
};
```









# 662 Maximum Width of Binary Tree

<img src="601-700.assets/image-20210923145838658.png" alt="image-20210923145838658" style="zoom:50%;" />

```cpp
/*
		如果发现值太大，就找个小的
*/
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if(root == nullptr)
            return 0;

        root->val = 1;
        deque<pair<TreeNode*, long>> myQueue;
        myQueue.push_back({root, 1});
        long  res = 1;

        while(!myQueue.empty()){
            int size = myQueue.size();
            long  left = LONG_MAX, right = LONG_MIN;
            int minus = 0;
            for(int i = 0; i < size; i++){
                auto p = myQueue.front(); myQueue.pop_front();
                if(i == 0)
                    minus = p.second - 1;

                if(i == 0)
                    left = min((long)left,   p.second);
                
                if(i == size - 1)
                    right = max((long)right, p.second);

                
                if(p.first->left != nullptr){
                    myQueue.push_back({p.first->left, (p.second - minus) * 2});
                }
                if(p.first->right != nullptr)
                    myQueue.push_back({p.first->right, (p.second - minus) * 2 + 1});

            }

            res = max(res, right - left  + 1);
        }

        return res;
    }

};
```











# 665 Non Decreasing Array

<img src="601-700.assets/image-20210621092112834.png" alt="image-20210621092112834" style="zoom:50%;" />

```java
    public boolean checkPossibility(int[] nums) {
        int len = nums.length;
        int left = 0, right = len - 1;

        while(left < len - 1 && nums[left] <= nums[left + 1])
            left++;
        
        if(left == len - 1)
            return true;
        
        while(right >= 1 && nums[right] >= nums[right - 1])
            right--;
        
        if(left + 1 != right)
            return false;
        
        if(left == 0 || right == len - 1)
            return true;
        
        return nums[left - 1] <= nums[right] || nums[right + 1] >= nums[left];
    }
```







# 669 Trim a Binary Search Tree

<img src="601-700.assets/image-20210613195032485.png" alt="image-20210613195032485" style="zoom:50%;" />

```java
    public TreeNode trimBST(TreeNode root, int low, int high) {
        root = helper(root, low, high);
        return root;
    }

    private TreeNode helper(TreeNode root, int low, int high){
        if(root == null)
            return null;
        
        root.left  = helper(root.left , low, high);
        root.right = helper(root.right, low, high);

        if(low <= root.val && root.val <= high){
            return root;
        }else{
            if(root.right == null)
                return root.left;
            else{
                TreeNode cur = root.right;
                while(cur.left != null)
                    cur = cur.left;
                
                cur.left = root.left;
                root.left = null;

                return root.right;
            }
                
        }
    }
```











# 674 Longest Continuous Increasing Subsequence



<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210513174107314.png" alt="image-20210513174107314" style="zoom:50%;" />

````go
func findLengthOfLCIS(nums []int) int {
	left, right := 0, 1
	res := 1

	for ;right < len(nums);{
		for ;right < len(nums) && nums[right] > nums[right - 1];{
			res = max(res, right - left + 1)
			right++
		}

		if right == len(nums){
			break
		}

		left = right
		right = right + 1
	}


	return res
}

func max(a int, b int) int{
	if a > b{
		return a
	}

	return b
}
````







# 678 Valid Parenthesis String



```cpp
class Solution {
public:
    bool checkValidString(string s) {
        vector<char> vec;

        int star = 0;
        for(char ch : s){
            if(ch == '(' || ch == '*'){
                vec.push_back(ch);
                if(ch == '*')
                    star++;
            }else{
                if(vec.empty() && star == 0)
                    return false;
                
                bool seenLeft = false;
                int size = vec.size();
                for(int i = size - 1; i >= 0; i--){
                    if(vec[i] == '('){
                        seenLeft = true;
                        vec.erase(vec.begin() + i);
                        break;
                    }
                }

                if(!seenLeft){
                    vec.pop_back();
                    star--;
                }
            }
        }

        int size = vec.size();
        star = 0;
        for(int i = size - 1; i >= 0; i--){
            if(vec[i] == '*')
                star++;
            else{
                if(star <= 0)
                    return false;
                star--;
            }
        }

        return true;
        
    }
};
```



<img src="601-700.assets/image-20210620204828516.png" alt="image-20210620204828516" style="zoom:50%;" />

```java

    public boolean checkValidString(String s) {
        List<Character> stack = new ArrayList<>();
        int star = 0;
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '(' || s.charAt(i) == '*'){
                stack.add(s.charAt(i));
                if(s.charAt(i) == '*')
                    star++;
            }else{
                if(stack.isEmpty() || stack.get(stack.size() - 1) == ')')
                    return false;

                boolean seen = false;
                for(int j = stack.size() - 1; j >= 0; j--){
                    if(stack.get(j) == '(') {
                        stack.remove(j);
                        seen = true;
                        break;
                    }
                }

                if(!seen){
                    stack.remove(stack.size() - 1);
                    star--;
                }
            }
        }

        star = 0;
        for(int i = stack.size() - 1; i >= 0; i--){
            if(stack.get(i) == '*')
                star++;
            else{
                if(star > 0){
                    star--;
                }else{
                    return false;
                }
            }
        }

        return true;
    }
```









# 679 24 Game



```cpp
/*
		实际上因为本身就4个数字，可以直接排列组合
		1.每次挑选两个数字，然后 做运算，放到 vector里
		2.进入递归
		
		同时注意精度的问题，
		如果最后的结果 和 24 在 1e6 的差别，那么可以直接返回true
*/
class Solution {
public:
    vector<char> ops = {'+','-','*','/'};
    unordered_set<int> set;
    bool judgePoint24(vector<int>& cards) {
        vector<double> path;
        for(int num : cards)
            path.push_back(num);

        return backtrack(path);
    }

    bool backtrack(vector<double> cards){
        int size = cards.size();
        if(size == 1)
            return abs(cards[0] - 24) < 1e-6;


        for(int i = 0; i < size; i++){
            for(int j = i + 1; j < size; j++){
                for(int k = 0; k < ops.size(); k++){
                    vector<double> next;
                    double res;
                    if(ops[k] == '+'){
                        res = cards[i] + cards[j];
                    }else if(ops[k] == '-'){
                        res = abs(cards[i] - cards[j]);
                    }else if(ops[k] == '*'){
                        res = cards[i] * cards[j];
                    }else{
                        res = cards[i] / cards[j];
                        double res1 = cards[j] / cards[i];

                        vector<double> nextNext;
                        nextNext.push_back(res1);
                        
                        for(int m = 0; m < size; m++){
                            if(m == i || m == j)
                                continue;
                            nextNext.push_back(cards[m]);
                        }

                        if(backtrack(nextNext))
                            return true;
                    }

                    next.push_back(res);
                    for(int m = 0; m < size; m++){
                        if(m == i || m == j)
                            continue;
                        next.push_back(cards[m]);
                    }

                    if(backtrack(next))
                        return true;
                }
            }
        }

        return false;
    }
};
```







# 680 Valid Palindrome II

<img src="601-700.assets/image-20210916080631214.png" alt="image-20210916080631214" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool validPalindrome(string s) {
        int size = s.size();
        return isValid(s, 0, size - 1, 1);
    }

    bool isValid(string& s, int start, int end, int token){
        if(start >= end)
            return true;
        
        char ch1 = s[start];
        char ch2 = s[end];

        if(ch1 == ch2){
            return isValid(s, start + 1, end - 1, token);
        }else{
            if(start + 1 == end)
                return token == 1;
            else{
                if(token == 0)
                    return false;
                return isValid(s, start + 1, end, 0) || isValid(s, start, end - 1, 0);
            }
        }
    }
};
```









<img src="601-700.assets/image-20210514153340972.png" alt="image-20210514153340972" style="zoom:50%;" />

```go
/*
	思路就是 递归 + 双指针， 因为可能有两种情况
	
	同时注意 go 的全局变量可能会导致 OJ 有问题，因此需要调整， 变成指针
*/
func validPalindrome(s string) bool {
	var firstCounter bool = false
	return myValidPalindDrome(s, &firstCounter)

}

func myValidPalindDrome(s string, firstCounter *bool) bool{
	if isPalindrome(s){
		return true
	}

	for left, right := 0, len(s) - 1; left < right;{

		if s[left] == s[right]{
			left++
			right--
		}else{
			if left + 1 == right{
				return true
			}else{
				if *firstCounter{
					return false
				}

				*firstCounter = true

				if s[left + 1] == s[right] || s[left] == s[right - 1]{
					if s[left + 1] == s[right] && s[left] == s[right - 1] {
						return myValidPalindDrome(s[left+2:right], firstCounter) || myValidPalindDrome(s[left+1:right-1], firstCounter)
					}else if s[left + 1] == s[right]{
						return myValidPalindDrome(s[left+2:right], firstCounter)
					}else if  s[left] == s[right - 1]{
						return  myValidPalindDrome(s[left+1:right-1], firstCounter)
					}
				}
			}
		}
	}

	return true
}

func isPalindrome(s string) bool{
	for i, j := 0, len(s) - 1; i < j; {
		if s[i] != s[j]{
			println(s[0:i])
			return false
		}

		i++
		j--
	}

	return true
}
```





```go
//超出时间限制
func validPalindrome(s string) bool {
	for i := 0; i < len(s); i++{
		newStr := s[0:i] + s[i + 1:]
		
		if isPalindrome(newStr){
			return true
		}
		
	}
	
	return false
}

func isPalindrome(s string) bool{
	for i, j := 0, len(s) - 1; i < j; {
		if s[i] != s[j]{
			return false
		}
		
		i++
		j--
	}
	
	return true
}
```





# 681 Next Closet Time



<img src="601-700.assets/image-20210726102952640.png" alt="image-20210726102952640" style="zoom:50%;" />

```cpp
class Solution {
public:
    string END_TIME   = "23:59";
    string START_TIME = "0:0";
    unordered_set<string> possibleStr;
    string nextClosestTime(string time) {
        unordered_set<char> set;
        for(char ch : time){
            if(ch == ':')
                continue;
            set.insert(ch);
        }

        generate(time, 0, set);

        string res = "";
        int minDiff = INT_MAX;
        for(const string& str1 : possibleStr){
            if(str1 == time)
                continue;
            int diff = difference(time, str1);
            if(diff < minDiff){
                minDiff = diff;
                res = str1;
            }


           // cout << "time ->" << str1 << " diff -> " << diff << endl;
        }

        return res == "" ? time : res;
    }

    void generate(string& time, int curPos, unordered_set<char>& set){
        if(curPos == time.size())
            return;

        for(char ch : set){
            if(curPos == 2){
                generate(time, curPos + 1, set);
            }else{
                string nextTime(time);
                nextTime[curPos] = ch;

                if(curPos == 4){
                    int hour = getHour(nextTime);
                    int min  = getMin(nextTime);

                    if(hour >= 24 || min >= 60)
                        continue;

                    possibleStr.insert(nextTime);
                }else{
                    generate(nextTime, curPos + 1, set);
                }

            }


        }
    }


    //the time difference between s1 and s2, in mins
    int difference(const string& s1, const string& s2){
        int res = 0;

        int hour1 = getHour(s1);
        int hour2 = getHour(s2);

        int min1  = getMin(s1);
        int min2  = getMin(s2);

        if(hour1 > hour2 || (hour1 == hour2 && min1 > min2)){
            int diff1 = difference(s1, END_TIME);
            int diff2 = difference(START_TIME, s2);

            return diff1 + diff2 + 1;
        }else{
            if(min1 <= min2) {
                int mins = min2 - min1;
                int hour = hour2 - hour1;

                return hour * 60 + mins;
            }else{
                int mins = 60 - min1 + min2;
                int hour = hour2 - hour1 - 1;

                return mins + hour * 60;
            }
        }
    }


    int getHour(const string& s){
        int res = 0;
        int index = 0;
        while(s[index] != ':'){
            res *= 10;
            res += s[index] - '0';
            index++;
        }

        return res;
    }

    int getMin(const string& s){
        int res = 0;
        int index = 0;
        while(s[index] != ':')
            index++;

        index++;
        while(index < s.size()){
            res *= 10;
            res += s[index] - '0';
            index++;
        }

        return res;
    }
};


```







# 682 Baseball Game

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210513160953207.png" alt="image-20210513160953207" style="zoom:50%;" />

```go
func calPoints(ops []string) int {
	res := make([]int, 0)

	for _, op := range ops{
		if num, err := strconv.Atoi(op); err == nil{
			res = append(res, num)
		}else{
			if op == "C"{
				res = res[:len(res) - 1]
			}else if op == "D"{
				temp := res[len(res) - 1]
				res = append(res, temp * 2)
			}else {
				temp := res[len(res) - 1] + res[len(res) - 2]
				res = append(res, temp)
			}
		}
	}
		
	sum := 0
	for _, num := range res{
		sum += num
	}
	
	return sum
}
```



# 688 Knight Probability In Chessboad



```cpp
实际上 dp 里面存储的是 方法种数
  
  比如到达 dp[i][j] 有几种方法， 类似 63 unique path
  同时 采用 swap 技术， 降维 dp 
  
	这样每次 dp1 是新的， dp0 是旧的
  最后进行交换
class Solution {
public:
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<double>> dp0(n, vector<double>(n, 0));
        dp0[row][column] = 1.0;
        
        int dir[8][2] = {{-1, -2}, {-2, -1}, {1, -2}, {2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}};

        for(int round = 0; round < k; round++){
            vector<vector<double>> dp1(n, vector<double>(n, 0.0));
            for(int i = 0; i < n; i++){
                for(int j = 0; j < n; j++){
                    for(int m = 0; m < 8; m++){
                        int newX = i + dir[m][0];
                        int newY = j + dir[m][1];

                        if(newX >= 0 && newY >= 0 && newX < n && newY < n){
                            dp1[newX][newY] += dp0[i][j];
                        }
                    }
                }
            }

            std::swap(dp1, dp0);
        }

        double total = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                total += dp0[i][j];
            }
        }

        return total / pow(8, k);

    }
};
```











# 689 Maximum Sum of 3 Non-Overlapping subarray



<img src="601-700.assets/image-20210703080839344.png" alt="image-20210703080839344" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int size = nums.size();
        int len = size - k + 1;

        vector<int> subArrarySum(len, 0);


        int sum = 0;
        for(int i = 0; i < size; i++){
            sum += nums[i];

            if(i - k >= 0){
                sum -= nums[i - k];
            }

            if(i >= k - 1)
                subArrarySum[i - k + 1] = sum;
        }

        int maxIndex = 0;
        vector<int> leftSum(len, 0);
        vector<int> rightSum(len, 0);

        for(int i = 0; i < len; i++){
            if(subArrarySum[maxIndex] < subArrarySum[i]){
                maxIndex = i;
            }

            leftSum[i] = maxIndex;
        }

        maxIndex = len - 1;
        for(int i = len - 1; i >= 0; i--){
            if(subArrarySum[i] >= subArrarySum[maxIndex]){
                maxIndex = i;
            }

            rightSum[i] = maxIndex;
        }

        vector<int> res(3, -1);
        for(int i = k; i < len - k; i++){
            if(res[0] == -1 ||
            subArrarySum[res[0]] + subArrarySum[res[1]] + subArrarySum[res[2]] < subArrarySum[i] + subArrarySum[leftSum[i - k]] + subArrarySum[rightSum[i + k]]){
                res[0] = leftSum[i - k];
                res[1] = i;
                res[2] = rightSum[i + k];
            }

        }
        return res;
    };
};
```











# 694 Number of Distinct Islands



<img src="601-700.assets/image-20210522155938527.png" alt="image-20210522155938527" style="zoom:50%;" />

```java
```



# 695 Max Area of Island

<img src="601-700.assets/image-20210923165115587.png" alt="image-20210923165115587" style="zoom:50%;" />

```cpp
/*
		典型并查集板子，没啥好说的
*/
class WeightUnionFind{
public:
    vector<int> sz;
    vector<int> id;

    WeightUnionFind(int N) : sz(vector<int>(N, 1)), id(vector<int>(N)){
        for(int i = 0; i < N; i++)
            id[i] = i;
    }

    void uni(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)        
            return;
        
        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }
    }

    bool isConnected(int p, int q){
        return find(p) == find(q);
    }

    int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }
};

class Solution {
public:
    int getCoor(int i, int j){
        return i * col + j;
    }
    
    int row;
    int col;
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();
        
        WeightUnionFind wuf(52 * 52);
        
        int count = 0;
        auto isInRange = [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};
        int res = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 1){
                    count++;
            
                    if(i == 0 && j == 0)
                        continue;
                    
                    if(i != 0 && grid[i - 1][j] == 1)
                        wuf.uni(getCoor(i, j), getCoor(i - 1, j));
                    if(j != 0 && grid[i][j - 1] == 1)
                        wuf.uni(getCoor(i, j - 1), getCoor(i, j));
                    
                    res = max(res, wuf.sz[wuf.find(getCoor(i, j))]);
                }
            }
        }
        
        return count == 0 ? 0 : max(1, res);
    }
    
    
};
```









