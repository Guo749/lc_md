

# 605 Can Place Flowers

<img src="601-700.assets/image-20210713085441947.png" alt="image-20210713085441947" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int index = 0;
        while(index < flowerbed.size() && n != 0) {
            while(index < flowerbed.size() && flowerbed[index] == 1)
                index++;
            
            if(index == flowerbed.size())
                break;
            
            if((index == 0 || (flowerbed[index - 1] == 0)) 
            && (index == flowerbed.size() - 1 || flowerbed[index + 1] == 0)){
                n--;
                index += 2;
            }else
                index++;
        }

        return n == 0;
    }
};
```









# 606 Construct String From Binary Tree

<img src="601-700.assets/image-20211012203259442.png" alt="image-20211012203259442" style="zoom:50%;" />

```cpp
class Solution {
public:
    string tree2str(TreeNode* root) {
        if(root == nullptr)
            return "";
        else if(root->left == nullptr && root->right == nullptr){
            return to_string(root->val);
        }

        string left  = tree2str(root->left);
        string right = tree2str(root->right);

        string res = to_string(root->val);
        if(root->left != nullptr){
            res.push_back('(');
            res += left;
            res.push_back(')');
        }else{
            res += "()";
        }

        if(root->right != nullptr){
            res.push_back('(');
            res += right;
            res.push_back(')');
        }

//        cout << res << endl;

        return res;
    }
};
```







# 609 Find Duplicate File in System



<img src="601-700.assets/image-20211013093021481.png" alt="image-20211013093021481" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<vector<string>> findDuplicate(vector<string>& paths) {
        vector<vector<string>> res;

        unordered_map<string, vector<string>> map;

        for(auto& path : paths){
            stringstream ss(path);
            string token;
            int counter = 0;
            string tempPath;
            while(ss >> token){
                if(counter == 0){
                    tempPath = token;
                    counter++;
                }else{
                    int lp = token.find('(');
                    int rp = token.find(')');

                    string fileName = token.substr(0, lp);
                    string content  = token.substr(lp, rp - lp);

                    map[content].push_back(tempPath  + "/" +  fileName);
                }
            }
        }

        for(auto it = map.begin(); it != map.end(); it++){
            if(it->second.size() == 1)
                continue;
            res.push_back(vector<string>());
            for(string& str : it->second){
                res[res.size() - 1].push_back(str);
            }
        }

        return res;
    }
};
```













# 611 Valid Triangle Number



```cpp
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end());

        int res = 0;
        int size = nums.size();
        for(int i = 0; i < size - 2; i++){
            int k = i + 2;
            for(int j = i + 1; j < nums.size() - 1 && nums[i] != 0; j++){
                while(k < nums.size() && nums[i] + nums[j] > nums[k])
                    k++;
                res += k - j - 1;
            }
        }

        return res;
    }
};
```











# 616 Add Bold Tag In String

<img src="601-700.assets/image-20211013150806403.png" alt="image-20211013150806403" style="zoom:50%;" />

```cpp
class Solution {
public:
    string addBoldTag(string s, vector<string>& words) {
        //start, len of word
        vector<pair<int, int>> start;


        for(string& word : words){
            int left = 0, right = 0;
            while(true){
                left = s.find(word, left);
                if(left == string::npos)
                    break;

                start.push_back({left, left + word.size()});
                left = left + max((int)word.size() - 1, 1);
            }
        }

        sort(start.begin(), start.end(), [&](auto& p1, auto& p2){
            return p1.first < p2.first;
        });

        int left = 0, right = 0;
        vector<int> vec1;
        vector<int> vec2;
        while(right < start.size()){
            int leftBound = start[left].first;
            int rightBound = start[left].second;

            while(right < start.size() && start[right].first <= rightBound){
                rightBound = max(rightBound, start[right].second);
                right++;
            }

            vec1.push_back(leftBound);
            vec2.push_back(rightBound);
            left = right;
        }

        string res = "";
        int index1 = 0;
        int index2 = 0;
        for(int i = 0; i <= s.size(); i++){
            if(index1 != vec1.size() && vec1[index1] == i){
                res += "<b>";
                index1++;
            }

            if(index2 != vec2.size() && vec2[index2] == i){
                res += "</b>";
                index2++;
            }

            if(i == s.size())
                break;
            res.push_back(s[i]);
        }

        return res;
    }
};
```







# 617 Merge Two Binary Tree

<img src="image-20210510180733810.png" alt="image-20210510180733810" style="zoom:50%;" />

```java
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1 == null || root2 == null){
            return root1 == null ? root2 : root1;
        }

        root1.val += root2.val;
        root1.left  = mergeTrees(root1.left, root2.left);
        root1.right = mergeTrees(root1.right, root2.right);

        return root1;
    }s
```





# 621 Task Scheduler



```cpp
//ref: http://zxi.mytechroad.com/blog/greedy/leetcode-621-task-scheduler/
class Solution {
public:
    int leastInterval(vector<char>& tasks, int n) {
        vector<int> count(26, 0);        
        for (const char task : tasks) 
            ++count[task - 'A'];
        const int max_count = *max_element(count.begin(), count.end());
        size_t ans = (max_count - 1) * (n + 1);
        ans += count_if(count.begin(), count.end(),
                        [max_count](int c){ return c == max_count; });
        return max(tasks.size(), ans);
    }
};
```









# 622 Design Circular Queues



```cpp

class MyCircularQueue {
public:
    vector<int> arr;
    int head;
    int tail;
    MyCircularQueue(int k) :arr(k), head(INT_MAX), tail(INT_MAX){

    }

    bool enQueue(int value) {
        //check three things
        //1. if we just initialize the array
        int size = arr.size();
        if(head == INT_MAX){
            head = 0;
            tail = 1 % size;
            arr[head] = value;
            return true;
        }

        //2. check if is full of it
        if(tail == head){
            return false;
        }

        //3 when we reach here, not full, not just initialize
        tail = (tail + 1) % size;
        arr[(tail - 1 + size) % size] = value;
        return true;
    }

    bool deQueue() {
        //1. if we just initialize the array
        if(head == INT_MAX)
            return false;

        int size = arr.size();
        //3. not empty, not just initialize the array
        head = (head + 1) % size;
        if(head == tail){    //clean it
            head = INT_MAX;
            tail = INT_MAX;
        }
        return true;
    }

    int Front() {
        //1 if we just initialize or empty
        if(head == INT_MAX)
            return -1;

        return arr[head];
    }

    int Rear() {
        if(head == INT_MAX)
            return - 1;

        int size = arr.size();
        return arr[(tail - 1 + size) % size];
    }

    bool isEmpty() {
        return head == INT_MAX;
    }

    bool isFull() {
        return head == tail && head != INT_MAX;
    }
};


```









# 623 Add One Row to Tree

![image-20211014081143919](601-700.assets/image-20211014081143919.png)

```cpp
/*
	典型 删除节点做法
*/
class Solution {
public:
    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        root = helper(root, val, depth, 1);
        return root;
    }

    TreeNode* helper(TreeNode* root, int val, int depth, int curDepth){
        if(root == nullptr)
            return nullptr;

        if(depth == 1){
            TreeNode* newRoot = new TreeNode(val);
            newRoot->left = root;
            return newRoot;
        }

        if(depth - 1 == curDepth){ //shoulbe be the part that we add
            TreeNode* tempLeft  = new TreeNode(val);
            TreeNode* tempRight = new TreeNode(val);

            tempLeft->left = root->left;
            tempRight->right = root->right;

            root->left = tempLeft;
            root->right = tempRight;

            return root;
        }

        root->left  = helper(root->left, val, depth, curDepth + 1);
        root->right = helper(root->right, val, depth, curDepth + 1);

        return root;
    }
};
```







# 624 maximum Distance in Arrays

<img src="601-700.assets/image-20211014090551782.png" alt="image-20211014090551782" style="zoom:50%;" />

```cpp
//贪心算法
class Solution {
public:
    int maxDistance(vector<vector<int>>& arrays) {
        int res = INT_MIN;
        int minVal = arrays[0][0];
        int maxVal = arrays[0][arrays[0].size() - 1];

        for(int i = 1; i < arrays.size(); i++){
            res = max(arrays[i][arrays[i].size() - 1] - minVal, res);
            res = max(res, maxVal - arrays[i][0]);

            minVal = min(minVal, arrays[i][0]);
            maxVal = max(maxVal, arrays[i][arrays[i].size() - 1]);
        }

        return res;
    }
};
```







# 625 Minimum Factorization

<img src="601-700.assets/image-20211015150807306.png" alt="image-20211015150807306" style="zoom:50%;" />

```cpp
class Solution {
public:
    int smallestFactorization(int num) {
        if(num == 1)
            return 1;
        string res;

        while(num != 1){
            int count = 0;
            for(int i = 9; i >= 2; i--){
                if(num % i == 0){
                    res.push_back((char)('0' + i));
                    num /= i;
                    break;
                }else{
                    count++;
                }
            }

            if(count == 8)
                return 0;
        }

        if(res.size() > 10)
            return 0;
        
        reverse(res.begin(), res.end());
        long interpret = stol(res);
        if(interpret >  INT_MAX)
            return 0;
        
        return (int) interpret;
    }
};
```













# 632 Smallest Range Covering Elements from k lists

```cpp
//思路就是把每一个row的最小值作为 a 剩下的最大值作为b 遍历得到结果
class Solution {
public:
    vector<int> smallestRange(vector<vector<int>>& nums) {
        int size = nums.size();
        vector<int> progress(size, 0);
        set<pair<int, int>> Set;

        for(int i = 0; i < size; i++){
            Set.insert({nums[i][0], i});
        }

        int range = INT_MAX;
        vector<int> res(2, 0);

        while(true){
            if(Set.rbegin()->first - Set.begin()->first < range){
                range = Set.rbegin()->first - Set.begin()->first;
                res = {Set.begin()->first, Set.rbegin()->first};
            }

            int curPointer = Set.begin()->second;   //row number
            progress[curPointer]++;

            if(progress[curPointer] == nums[curPointer].size())
                break;
            
            Set.erase(Set.begin());
            Set.insert({nums[curPointer][progress[curPointer]], curPointer});
        }

        return res;
    }
};
```







# 628 Maximum Product of Three Numbers

<img src="601-700.assets/image-20211015145739007.png" alt="image-20211015145739007" style="zoom:50%;" />

```cpp
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        
        int size = nums.size();
        int case1 = nums[0] * nums[1] * nums[2];
        int case2 = nums[size - 1] * nums[size - 2] * nums[size - 3];
        int case3 = nums[0] * nums[1] * nums[size - 1];
        int case4 = nums[size - 1] * nums[size - 2] * nums[0];
        
        
        return max(max(case1, case2), max(case3, case4));
    }
};
```







# 633 Sum of Square Numbers

<img src="601-700.assets/image-20211016104220824.png" alt="image-20211016104220824" style="zoom:50%;" />

```cpp

class Solution {
public:
    bool judgeSquareSum(int c) {
        vector<long> res;
        int upperBound = sqrt(c);
        for(int i = 0; i <= upperBound; i++){
            res.push_back(i * i);
        }

        int left = 0, right = res.size() - 1;

        while(left <= right){
            long sum = res[left] + res[right];
            if(sum == c)
                return true;
            else if(sum > c)
                right--;
            else
                left++;
        }

        return false;
    }
};
```



# 634 Find the Derangement of An Array

<img src="601-700.assets/image-20211017103029079.png" alt="image-20211017103029079" style="zoom:50%;" />

```cpp
/*
	ref: https://github.com/wisdompeak/LeetCode/tree/master/Dynamic_Programming/634.Find-the-Derangement-of-An-Array
*/
class Solution {
public:
    int findDerangement(int n) {
        if(n <= 3)
            return n - 1;

        long a = 0;
        long b = 1;
        int mod = 1e9 + 7;

        for(long i = 3; i <= n; i++){
            long temp = (i - 1) * (a + b);
            a = b;
            b = temp;

            a %= mod;
            b %= mod;
        }

        return b ;
    }
};
```







# 636 Exclusive Time of Functions



```cpp
//source: 
class Solution {
public:
    vector<int> exclusiveTime(int n, vector<string>& logs) {
        stack<pair<int, int>> Stack;
        vector<int> res(n, 0);

        for(auto s : logs){
//            cout << s << endl;
            int pos1 = s.find(":", 0);
            int pos2 = s.find(":", pos1 + 1);

            int id = stoi(s.substr(0, pos1));
            bool flag = s[pos1 + 1] == 's' ? true : false;
            int timeStamp = stoi(s.substr(pos2 + 1));

            if(flag){
                Stack.push({id, timeStamp});
            }else{
                int start = Stack.top().second;
                int duration = timeStamp - start + 1;
                res[id] += duration;
                Stack.pop();

                if(Stack.empty())
                    continue;

                int prevId = Stack.top().first;
                res[prevId] -= duration;

            }
        }

        return res;
    }
};
```





# 637 Average of Levels in Binary Tre

<img src="601-700.assets/image-20211018104559755.png" alt="image-20211018104559755" style="zoom:50%;" />

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> res;
        deque<TreeNode*> myQueue;
        if(root == nullptr)
            return res;
        myQueue.push_back(root);
        while(!myQueue.empty()){
            int size = myQueue.size();
            long sum = 0;
            for(int i = 0; i < size; i++){
                sum += myQueue.front()->val;
                TreeNode* cur = myQueue.front(); myQueue.pop_front();

                if(cur->left != nullptr)
                    myQueue.push_back(cur->left);
                if(cur->right != nullptr)
                    myQueue.push_back(cur->right);
            }

            res.push_back((sum * 1.0) / size);
        }

        return res;
    }
};
```









# 638 Shopping Offers



<img src="601-700.assets/image-20210705081316748.png" alt="image-20210705081316748" style="zoom:50%;" />



```cpp
//暴力回溯
class Solution {
public:
    int minPrice = 0;
    int shoppingOffers(vector<int>& price, vector<vector<int>>& special, vector<int>& needs) {
        int sum = 0;
        for(int i = 0; i < price.size(); i++){
            sum += price[i] * needs[i];
        }

        minPrice = sum;

        backtrack(price, special, needs, 0);

        return minPrice;
    }

    int backtrack(vector<int>& price, vector<vector<int>>& special, vector<int>& needs, int expense){
        if(allSell(needs)){
            minPrice = min(minPrice, expense);
        }

        int res = minPrice;
        for(int i = 0; i < special.size(); i++){
            vector<int> sp = special[i];
            bool canUse = true;
            for(int j = 0; j < needs.size(); j++) {
                if (sp[j] > needs[j]) {
                    canUse = false;
                    break;
                }
            }

            if(canUse){
                for(int j = 0; j < price.size(); j++){
                    needs[j] -= sp[j];
                }

                res = min(backtrack(price, special, needs, expense + special[i][price.size()]), res);
                minPrice = (res + expense, minPrice);
                
                for(int j = 0; j < price.size(); j++){
                    needs[j] += sp[j];
                }
            }
        }

        int temp = 0;
        for(int i = 0; i < price.size(); i++){
            temp += price[i] * needs[i];
        }
     
        minPrice = min(temp + expense, minPrice);

        return res;
    }

    bool allSell(vector<int>& needs){
        for(int i = 0; i < needs.size(); i++){
            if(needs[i] != 0)
                return false;
        }

        return true;
    }

    int min(int i, int j){
        return i >= j ? j : i;
    }
};
```







# 643 Maximum Average Subarray

<img src="601-700.assets/image-20211019104324506.png" alt="image-20211019104324506" style="zoom:50%;" />

```cpp
class Solution {
public:
    double findMaxAverage(vector<int>& nums, int k) {
        int size = nums.size();

        int sum = 0;
        double res = INT_MIN;

        for(int i = 0; i < k - 1; i++){
            sum += nums[i];
        }

        for(int i = k - 1; i < size; i++){
            sum += nums[i];

            res = max(res, sum * 1.0 / k);

            sum -= nums[i - (k - 1)];
        }

        return res;
    }
};
```







# 645 Set Mismatch

<img src="601-700.assets/image-20211102173714652.png" alt="image-20211102173714652" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        unordered_set<int> set;
        int duplicate = -1;
        int missing = -1;
        int index = 1;
        for(int i = 0; i < nums.size(); i++){
            if(set.count(nums[i]) == 0)
                set.insert(nums[i]);
            else    
                duplicate = nums[i];
        }

        for(int i = 1; i <= nums.size(); i++){
            if(set.count(i) == 0){
                missing = i;
            }
        }

        return {duplicate, missing};
    }
};
```





# 646  Maximum Lenght of Pair Chain

<img src="601-700.assets/image-20211102175641482.png" alt="image-20211102175641482" style="zoom:50%;" />

```cpp
ON^2 时间复杂度
class Solution {
public:
    //          index,  greates value we have
    unordered_map<int, int> map;
    int findLongestChain(vector<vector<int>>& pairs) {
        sort(pairs.begin(), pairs.end(), [&](auto& v1, auto& v2){
            return v1[0] < v2[0];
        });

        int size = pairs.size();
        int maxValue = 1;
        for(int i = size - 1; i >= 0; i--){
            int res = 1;
            for(int j = i + 1; j < size; j++){
                if(pairs[i][1] < pairs[j][0]){
                    res = max(res, 1 + map[j]);
                }
            }

            map[i] = res;
            maxValue = max(maxValue, res);
        }

        return maxValue;
    }
};
```



# 647 Palindromic Substrings

<img src="601-700.assets/image-20210804202913413.png" alt="image-20210804202913413" style="zoom:50%;" />

```cpp
// 灵感来源第五题
class Solution {
public:
    int countSubstrings(string s) {
        int size = s.size();
        vector<vector<bool>> dp(size, vector<bool>(size, false));

        for(int i = 0; i < size; i++){
            dp[i][i] = true;
        }

        int count = 0;
        for(int i = size - 1; i >= 0; i--){
            for(int j = i + 1; j < size; j++){
                if(s[i] == s[j]){
                    if(i + 1 == j)
                        dp[i][j] = true;
                    else
                        dp[i][j] = dp[i + 1][j - 1];
                }

                if(dp[i][j])
                    count++;
            }
        }

        count += size;
        return count;
    }
};
```





# 652 Find Duplicate Subtrees

```cpp
class Solution {
public:
    unordered_map<string, vector<TreeNode*> > map;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        postorder(root, "");
        
        vector<TreeNode*> res;
        for(auto it = map.begin(); it != map.end(); it++){
            if(it->second.size() > 1){
                res.push_back(it->second[0]);
            }
        }
        
        return res;
    }
    
    string postorder(TreeNode* root, string path){
        if(root == nullptr)
            return "@";
        
        path += to_string(root->val);
        
        string leftS  = postorder(root->left, "");
        string rightS = postorder(root->right, "");
        
        path += "L" + leftS + "R" + rightS;
        
        map[path].push_back(root);
        
        return path;
    }
};
```





<img src="601-700.assets/image-20210722204340704.png" alt="image-20210722204340704" style="zoom:50%;" />

```cpp
class Solution {
public:
    unordered_map<string, vector<TreeNode*>> map;
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        postorder(root);

        vector<TreeNode*> res;
        for(auto it = map.begin(); it != map.end(); it++){
            if(it->second.size() >= 2){
                res.push_back(it->second[0]);
            }
        }

        return res;
    }

    string postorder(TreeNode* root){
        if(root == nullptr)
            return "#";

        string left = postorder(root->left);
        string right = postorder(root->right);

        string cur = to_string(root->val) + ">"+ left +"<" + right;
        //cout << to_string(root->val) << " " << cur << endl;
        map[cur].push_back(root);
        return cur;
    }
};
```











# 654 Maximum Binary Tree

<img src="601-700.assets/image-20210519183246609.png" alt="image-20210519183246609" style="zoom:50%;" />

<img src="601-700.assets/image-20210519183238553.png" alt="image-20210519183238553" style="zoom:50%;" />

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func constructMaximumBinaryTree(nums []int) *TreeNode {
	return buildTree(nums, 0, len(nums) - 1)

}


func buildTree(nums []int, start int, end int) *TreeNode{
	if start > end{
		return nil
	}else if start == end{
		root := new(TreeNode)
		root.Val = nums[start]
		return root
	}
	
	index := start
	max := nums[start]

	for i := start; i <= end; i++{
		if max < nums[i]{
			index = i
			max   = nums[i]
		}
	}

	root := new(TreeNode)
	root.Val = max
	root.Left  = buildTree(nums, start, index  - 1)
	root.Right = buildTree(nums, index + 1, end)
	
	return root
}

```







# 650 2 Keys Keyboard 不错的DP 题目



```cpp
class Solution {
public:
    int minSteps(int n) {
        if(n == 1)
            return 0;
        vector<int> dp(n + 1, INT_MAX);
        dp[1] = 0;
        dp[2] = 2;

        for(int i = 3; i <= n; i++){
            dp[i] = i;

            for(int j = 2; j * j <= i; j++){
                if(i % j == 0)
                    dp[i] = dp[j] + dp[i / j];
            }
        }

        return dp[n];
    }
};
```







# 657 Robot Return to Origin

<img src="601-700.assets/image-20211101210301025.png" alt="image-20211101210301025" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool judgeCircle(string moves) {
        int i = 0;
        int j = 0;

        for(char ch : moves){
            if(ch == 'U'){
                i -= 1;
            }else if(ch == 'D'){
                i += 1;
            }else if(ch == 'L'){
                j -= 1;
            }else if(ch == 'R'){
                j += 1;
            }
        }

        return i == 0 && j == 0;
    }
};
```





# 658 Find K Closet Elements

<img src="601-700.assets/image-20210922204811920.png" alt="image-20210922204811920" style="zoom:50%;" />

```cpp
/*
		优化采用二分
		author guoguo
		date 0922/2021
*/
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        if(arr.size() == k)
            return arr;
        //step1 to find the target index
        //if larger than any elements, return arr.size();
        //if smaller than any elements return -1
        //if there doesnot exist the element, we will return a close one

//        int posIndex = binarySearch(arr, x);
        int posIndex = -1;
        int size = arr.size();
        if(arr[0] >= x){
            return vector<int>(arr.begin(), arr.begin() + k);
        }else if(arr[size - 1] <= x) {
            return vector<int>(arr.end() - k, arr.end());
        }

        int left = 0, right = size - 1;
        int l, r;
        while(left <= right){
            int mid = (left + right) / 2;
            if(arr[mid] == x){
                l = mid;
                r = mid + 1;
                break;
            }else if(arr[mid] < x){
                if(arr[mid + 1] > x){
                    l = mid;
                    r = mid + 1;
                    break;
                }else{
                    left = mid + 1;
                }
            }else{//arr[mid] > x
                if(arr[mid - 1] < x){
                    l = mid - 1;
                    r = mid;
                    break;
                }else{
                    right = mid - 1;
                }
            }
        }
        
        //step2
        //using double points to solve this problem
        vector<int> res;
        while((l >= 0 || r < size) && res.size() < k){
            if(l < 0){
                res.push_back(arr[r++]);
            }else if(r >= size){
                res.push_back(arr[l--]);
            }else{
                if(abs(arr[l] - x) <= abs(arr[r] - x)){
                    res.push_back(arr[l--]);
                }else{
                    res.push_back(arr[r++]);
                }
            }
        }
        
        sort(res.begin(), res.end());
        return res;
    

    }
};
```



<img src="601-700.assets/image-20210922204241767.png" alt="image-20210922204241767" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        if(arr.size() == k)
            return arr;
        //step1 to find the target index
        //if larger than any elements, return arr.size();
        //if smaller than any elements return -1
        //if there doesnot exist the element, we will return a close one

//        int posIndex = binarySearch(arr, x);
        int posIndex = -1;
        int size = arr.size();
        if(arr[0] >= x){
            return vector<int>(arr.begin(), arr.begin() + k);
        }else if(arr[size - 1] <= x) {
            return vector<int>(arr.end() - k, arr.end());
        }

        int left, right;
        for(int i = 0; i < size - 1; i++){
            if(arr[i] == x){
                left = i;
                right = i + 1;
                break;
            }else if(arr[i] < x && arr[i + 1] > x){
                left = i;
                right = i + 1;
                break;
            }
        }
        
        //step2
        //using double points to solve this problem
        vector<int> res;
        while((left >= 0 || right < size) && res.size() < k){
            if(left < 0){
                res.push_back(arr[right++]);
            }else if(right >= size){
                res.push_back(arr[left--]);
            }else{
                if(abs(arr[left] - x) <= abs(arr[right] - x)){
                    res.push_back(arr[left--]);
                }else{
                    res.push_back(arr[right++]);
                }
            }
        }
        
        sort(res.begin(), res.end());
        return res;
    

    }
};
```





# 659 Split Array Into Consecutive Subsequence

<img src="601-700.assets/image-20211031215135134.png" alt="image-20211031215135134" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool isPossible(vector<int>& nums) {
        unordered_map<int, unordered_set<int>> map;
        vector<vector<int>> res;

        for(int i = 0; i < nums.size(); i++){
            int curNum = nums[i];
            if(i == 0){
                res.push_back(vector<int>());
                res[0].push_back(curNum);
                map[curNum].insert(i);
            }else{
                if(map.count(curNum - 1) == 0){ // doest not exist a array taht has the sequence
                    res.push_back(vector<int>());
                    res[res.size() - 1].push_back(curNum);
                    map[curNum].insert(res.size() - 1);
                }else{ 
                    int found = 0;
                    int anotherIndex = -1;
                    for(auto index : map[curNum - 1]){
                        if(res[index].size() < 3){
                            res[index].push_back(curNum);
                            map[curNum - 1].erase(index);
                            map[curNum].insert(index);
                            found = 1;
                            break;
                        }else
                            anotherIndex = index;
                    }

                    if(found == 0){
                        if(anotherIndex != -1){
                            map[curNum - 1].erase(anotherIndex);
                            map[curNum].insert(anotherIndex);
                            res[anotherIndex].push_back(curNum);
                        }else{
                            res.push_back(vector<int>());
                            res[res.size() - 1].push_back(curNum);
                            
                            map[curNum].insert(res.size() - 1);
                        }
                    }
                }
            }

        }

        for(auto& v : res){
            if(v.size() < 3)
                return false;
        }

        return true;
    }
};
```







# 661 Image Smoother

<img src="601-700.assets/image-20211031193612133.png" alt="image-20211031193612133" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<vector<int>> imageSmoother(vector<vector<int>>& img) {
        int row = img.size();
        int col = img[0].size();

        vector<vector<int>> res = vector<vector<int>>(row, vector<int>(col, 0));
        auto isInRange = [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};
        vector<vector<int>> dir = {{1, 0},{0, 1},{-1, 0},{0, -1},{1, 1},{1, -1},{-1, 1},{-1, -1}, {0,0}};
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                int sum  = 0;
                int count = 0;
                for(int k = 0; k < 9; k++){
                    int newX = i + dir[k][0];
                    int newY = j + dir[k][1];

                    if(isInRange(newX, newY)){
                        sum += img[newX][newY];
                        count += 1;
                    }
                }
                // if(i == 0 && j == 0){
                //     cout << count << endl;
                //     cout << sum << endl;
                // }
                res[i][j] = sum / count;
            }
        }

        return res;
    }
};
```













# 662 Maximum Width of Binary Tree

<img src="601-700.assets/image-20210923145838658.png" alt="image-20210923145838658" style="zoom:50%;" />

```cpp
/*
		如果发现值太大，就找个小的
*/
class Solution {
public:
    int widthOfBinaryTree(TreeNode* root) {
        if(root == nullptr)
            return 0;

        root->val = 1;
        deque<pair<TreeNode*, long>> myQueue;
        myQueue.push_back({root, 1});
        long  res = 1;

        while(!myQueue.empty()){
            int size = myQueue.size();
            long  left = LONG_MAX, right = LONG_MIN;
            int minus = 0;
            for(int i = 0; i < size; i++){
                auto p = myQueue.front(); myQueue.pop_front();
                if(i == 0)
                    minus = p.second - 1;

                if(i == 0)
                    left = min((long)left,   p.second);
                
                if(i == size - 1)
                    right = max((long)right, p.second);

                
                if(p.first->left != nullptr){
                    myQueue.push_back({p.first->left, (p.second - minus) * 2});
                }
                if(p.first->right != nullptr)
                    myQueue.push_back({p.first->right, (p.second - minus) * 2 + 1});

            }

            res = max(res, right - left  + 1);
        }

        return res;
    }

};
```











# 665 Non Decreasing Array

<img src="601-700.assets/image-20210621092112834.png" alt="image-20210621092112834" style="zoom:50%;" />

```java
    public boolean checkPossibility(int[] nums) {
        int len = nums.length;
        int left = 0, right = len - 1;

        while(left < len - 1 && nums[left] <= nums[left + 1])
            left++;
        
        if(left == len - 1)
            return true;
        
        while(right >= 1 && nums[right] >= nums[right - 1])
            right--;
        
        if(left + 1 != right)
            return false;
        
        if(left == 0 || right == len - 1)
            return true;
        
        return nums[left - 1] <= nums[right] || nums[right + 1] >= nums[left];
    }
```





# 667 Beautiful Arrangement II



```cpp
/*
	本质上类似 wiggle sort
*/
class Solution {
public:
    vector<int> constructArray(int n, int k) {
        vector<int> res;

        int distinct = k - 1;
        int needNumber = distinct + 1;
        int left = 1, right = needNumber;
        while(left <= right){
            res.push_back(left);
            left++;
            if(left > right)
                break;
            res.push_back(right);
            right--;
        }

        vector<int> ans;
        for(int i = n; i > needNumber; i--){
            ans.push_back(i);
        }

        for(int num : res)
            ans.push_back(num);

        return ans;
    
    }
};
```







# 669 Trim a Binary Search Tree

<img src="601-700.assets/image-20210613195032485.png" alt="image-20210613195032485" style="zoom:50%;" />

```java
    public TreeNode trimBST(TreeNode root, int low, int high) {
        root = helper(root, low, high);
        return root;
    }

    private TreeNode helper(TreeNode root, int low, int high){
        if(root == null)
            return null;
        
        root.left  = helper(root.left , low, high);
        root.right = helper(root.right, low, high);

        if(low <= root.val && root.val <= high){
            return root;
        }else{
            if(root.right == null)
                return root.left;
            else{
                TreeNode cur = root.right;
                while(cur.left != null)
                    cur = cur.left;
                
                cur.left = root.left;
                root.left = null;

                return root.right;
            }
                
        }
    }
```





# 671 Second Minumum Node in a Binary Tree

<img src="601-700.assets/image-20211025215251753.png" alt="image-20211025215251753" style="zoom:50%;" />

```cpp
class Solution {
public:
    set<int> Set;
    int findSecondMinimumValue(TreeNode* root) {
        preorder(root);
        if(Set.size() < 2)
            return -1;

        auto it = ++Set.begin();
        return *it;
    }

    void preorder(TreeNode* root){
        if(root == nullptr)
            return;

        Set.insert(root->val);

        preorder(root->left);
        preorder(root->right);
    }
};
```







# 674 Longest Continuous Increasing Subsequence



<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210513174107314.png" alt="image-20210513174107314" style="zoom:50%;" />

````go
func findLengthOfLCIS(nums []int) int {
	left, right := 0, 1
	res := 1

	for ;right < len(nums);{
		for ;right < len(nums) && nums[right] > nums[right - 1];{
			res = max(res, right - left + 1)
			right++
		}

		if right == len(nums){
			break
		}

		left = right
		right = right + 1
	}


	return res
}

func max(a int, b int) int{
	if a > b{
		return a
	}

	return b
}
````







# 677 Map Sum Pairs

<img src="601-700.assets/image-20211027224534844.png" alt="image-20211027224534844" style="zoom:50%;" />

```cpp
//典型用 trie
class Node{
public:
    vector<Node*> neighbors;
    char ch;
    int val;
    Node(char c, int v):neighbors(vector<Node*>(26, nullptr)), ch(c), val(v){}
};

class MapSum {
public:
    Node* root;
    MapSum() {
        root = new Node('@', 0);
    }

    void insert(string key, int val) {
        Node* cur = root;
        int index = 0;
        while(index != key.size()){
            char ch = key[index];
            int pos = ch - 'a';

            if(cur->neighbors[pos] == nullptr){
                cur->neighbors[pos] = new Node(pos, 0);
            }

            cur = cur->neighbors[pos];
            index++;
        }

        cur->val = val;
    }

    int sum(string prefix) {
        Node* cur = root;
        int index = 0;
        while(index != prefix.size()){
            char ch = prefix[index];
            int pos = ch - 'a';
            if(cur->neighbors[pos] == nullptr)
                return 0;
            cur = cur->neighbors[pos];
            index++;
        }

        return getAllRes(cur);
    }

    int getAllRes(Node* node){
        int res = 0;
        if(node->val != 0)
            res += node->val;

        for(int i = 0; i < 26; i++) {
            if(node->neighbors[i] != nullptr)
                res += getAllRes(node->neighbors[i]);
        }

        return res;
    }
};

/**
 * Your MapSum object will be instantiated and called as such:
 * MapSum* obj = new MapSum();
 * obj->insert(key,val);
 * int param_2 = obj->sum(prefix);
 */
```









# 678 Valid Parenthesis String



```cpp
class Solution {
public:
    bool checkValidString(string s) {
        vector<char> vec;

        int star = 0;
        for(char ch : s){
            if(ch == '(' || ch == '*'){
                vec.push_back(ch);
                if(ch == '*')
                    star++;
            }else{
                if(vec.empty() && star == 0)
                    return false;
                
                bool seenLeft = false;
                int size = vec.size();
                for(int i = size - 1; i >= 0; i--){
                    if(vec[i] == '('){
                        seenLeft = true;
                        vec.erase(vec.begin() + i);
                        break;
                    }
                }

                if(!seenLeft){
                    vec.pop_back();
                    star--;
                }
            }
        }

        int size = vec.size();
        star = 0;
        for(int i = size - 1; i >= 0; i--){
            if(vec[i] == '*')
                star++;
            else{
                if(star <= 0)
                    return false;
                star--;
            }
        }

        return true;
        
    }
};
```



<img src="601-700.assets/image-20210620204828516.png" alt="image-20210620204828516" style="zoom:50%;" />

```java

    public boolean checkValidString(String s) {
        List<Character> stack = new ArrayList<>();
        int star = 0;
        for(int i = 0; i < s.length(); i++){
            if(s.charAt(i) == '(' || s.charAt(i) == '*'){
                stack.add(s.charAt(i));
                if(s.charAt(i) == '*')
                    star++;
            }else{
                if(stack.isEmpty() || stack.get(stack.size() - 1) == ')')
                    return false;

                boolean seen = false;
                for(int j = stack.size() - 1; j >= 0; j--){
                    if(stack.get(j) == '(') {
                        stack.remove(j);
                        seen = true;
                        break;
                    }
                }

                if(!seen){
                    stack.remove(stack.size() - 1);
                    star--;
                }
            }
        }

        star = 0;
        for(int i = stack.size() - 1; i >= 0; i--){
            if(stack.get(i) == '*')
                star++;
            else{
                if(star > 0){
                    star--;
                }else{
                    return false;
                }
            }
        }

        return true;
    }
```









# 679 24 Game



```cpp
/*
		实际上因为本身就4个数字，可以直接排列组合
		1.每次挑选两个数字，然后 做运算，放到 vector里
		2.进入递归
		
		同时注意精度的问题，
		如果最后的结果 和 24 在 1e6 的差别，那么可以直接返回true
*/
class Solution {
public:
    vector<char> ops = {'+','-','*','/'};
    unordered_set<int> set;
    bool judgePoint24(vector<int>& cards) {
        vector<double> path;
        for(int num : cards)
            path.push_back(num);

        return backtrack(path);
    }

    bool backtrack(vector<double> cards){
        int size = cards.size();
        if(size == 1)
            return abs(cards[0] - 24) < 1e-6;


        for(int i = 0; i < size; i++){
            for(int j = i + 1; j < size; j++){
                for(int k = 0; k < ops.size(); k++){
                    vector<double> next;
                    double res;
                    if(ops[k] == '+'){
                        res = cards[i] + cards[j];
                    }else if(ops[k] == '-'){
                        res = abs(cards[i] - cards[j]);
                    }else if(ops[k] == '*'){
                        res = cards[i] * cards[j];
                    }else{
                        res = cards[i] / cards[j];
                        double res1 = cards[j] / cards[i];

                        vector<double> nextNext;
                        nextNext.push_back(res1);
                        
                        for(int m = 0; m < size; m++){
                            if(m == i || m == j)
                                continue;
                            nextNext.push_back(cards[m]);
                        }

                        if(backtrack(nextNext))
                            return true;
                    }

                    next.push_back(res);
                    for(int m = 0; m < size; m++){
                        if(m == i || m == j)
                            continue;
                        next.push_back(cards[m]);
                    }

                    if(backtrack(next))
                        return true;
                }
            }
        }

        return false;
    }
};
```







# 680 Valid Palindrome II

<img src="601-700.assets/image-20210916080631214.png" alt="image-20210916080631214" style="zoom:50%;" />

```cpp
class Solution {
public:
    bool validPalindrome(string s) {
        int size = s.size();
        return isValid(s, 0, size - 1, 1);
    }

    bool isValid(string& s, int start, int end, int token){
        if(start >= end)
            return true;
        
        char ch1 = s[start];
        char ch2 = s[end];

        if(ch1 == ch2){
            return isValid(s, start + 1, end - 1, token);
        }else{
            if(start + 1 == end)
                return token == 1;
            else{
                if(token == 0)
                    return false;
                return isValid(s, start + 1, end, 0) || isValid(s, start, end - 1, 0);
            }
        }
    }
};
```









<img src="601-700.assets/image-20210514153340972.png" alt="image-20210514153340972" style="zoom:50%;" />

```go
/*
	思路就是 递归 + 双指针， 因为可能有两种情况
	
	同时注意 go 的全局变量可能会导致 OJ 有问题，因此需要调整， 变成指针
*/
func validPalindrome(s string) bool {
	var firstCounter bool = false
	return myValidPalindDrome(s, &firstCounter)

}

func myValidPalindDrome(s string, firstCounter *bool) bool{
	if isPalindrome(s){
		return true
	}

	for left, right := 0, len(s) - 1; left < right;{

		if s[left] == s[right]{
			left++
			right--
		}else{
			if left + 1 == right{
				return true
			}else{
				if *firstCounter{
					return false
				}

				*firstCounter = true

				if s[left + 1] == s[right] || s[left] == s[right - 1]{
					if s[left + 1] == s[right] && s[left] == s[right - 1] {
						return myValidPalindDrome(s[left+2:right], firstCounter) || myValidPalindDrome(s[left+1:right-1], firstCounter)
					}else if s[left + 1] == s[right]{
						return myValidPalindDrome(s[left+2:right], firstCounter)
					}else if  s[left] == s[right - 1]{
						return  myValidPalindDrome(s[left+1:right-1], firstCounter)
					}
				}
			}
		}
	}

	return true
}

func isPalindrome(s string) bool{
	for i, j := 0, len(s) - 1; i < j; {
		if s[i] != s[j]{
			println(s[0:i])
			return false
		}

		i++
		j--
	}

	return true
}
```





```go
//超出时间限制
func validPalindrome(s string) bool {
	for i := 0; i < len(s); i++{
		newStr := s[0:i] + s[i + 1:]
		
		if isPalindrome(newStr){
			return true
		}
		
	}
	
	return false
}

func isPalindrome(s string) bool{
	for i, j := 0, len(s) - 1; i < j; {
		if s[i] != s[j]{
			return false
		}
		
		i++
		j--
	}
	
	return true
}
```





# 681 Next Closet Time



<img src="601-700.assets/image-20210726102952640.png" alt="image-20210726102952640" style="zoom:50%;" />

```cpp
class Solution {
public:
    string END_TIME   = "23:59";
    string START_TIME = "0:0";
    unordered_set<string> possibleStr;
    string nextClosestTime(string time) {
        unordered_set<char> set;
        for(char ch : time){
            if(ch == ':')
                continue;
            set.insert(ch);
        }

        generate(time, 0, set);

        string res = "";
        int minDiff = INT_MAX;
        for(const string& str1 : possibleStr){
            if(str1 == time)
                continue;
            int diff = difference(time, str1);
            if(diff < minDiff){
                minDiff = diff;
                res = str1;
            }


           // cout << "time ->" << str1 << " diff -> " << diff << endl;
        }

        return res == "" ? time : res;
    }

    void generate(string& time, int curPos, unordered_set<char>& set){
        if(curPos == time.size())
            return;

        for(char ch : set){
            if(curPos == 2){
                generate(time, curPos + 1, set);
            }else{
                string nextTime(time);
                nextTime[curPos] = ch;

                if(curPos == 4){
                    int hour = getHour(nextTime);
                    int min  = getMin(nextTime);

                    if(hour >= 24 || min >= 60)
                        continue;

                    possibleStr.insert(nextTime);
                }else{
                    generate(nextTime, curPos + 1, set);
                }

            }


        }
    }


    //the time difference between s1 and s2, in mins
    int difference(const string& s1, const string& s2){
        int res = 0;

        int hour1 = getHour(s1);
        int hour2 = getHour(s2);

        int min1  = getMin(s1);
        int min2  = getMin(s2);

        if(hour1 > hour2 || (hour1 == hour2 && min1 > min2)){
            int diff1 = difference(s1, END_TIME);
            int diff2 = difference(START_TIME, s2);

            return diff1 + diff2 + 1;
        }else{
            if(min1 <= min2) {
                int mins = min2 - min1;
                int hour = hour2 - hour1;

                return hour * 60 + mins;
            }else{
                int mins = 60 - min1 + min2;
                int hour = hour2 - hour1 - 1;

                return mins + hour * 60;
            }
        }
    }


    int getHour(const string& s){
        int res = 0;
        int index = 0;
        while(s[index] != ':'){
            res *= 10;
            res += s[index] - '0';
            index++;
        }

        return res;
    }

    int getMin(const string& s){
        int res = 0;
        int index = 0;
        while(s[index] != ':')
            index++;

        index++;
        while(index < s.size()){
            res *= 10;
            res += s[index] - '0';
            index++;
        }

        return res;
    }
};


```







# 682 Baseball Game

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210513160953207.png" alt="image-20210513160953207" style="zoom:50%;" />

```go
func calPoints(ops []string) int {
	res := make([]int, 0)

	for _, op := range ops{
		if num, err := strconv.Atoi(op); err == nil{
			res = append(res, num)
		}else{
			if op == "C"{
				res = res[:len(res) - 1]
			}else if op == "D"{
				temp := res[len(res) - 1]
				res = append(res, temp * 2)
			}else {
				temp := res[len(res) - 1] + res[len(res) - 2]
				res = append(res, temp)
			}
		}
	}
		
	sum := 0
	for _, num := range res{
		sum += num
	}
	
	return sum
}
```





# 684 Redundant Connection



<img src="601-700.assets/image-20211024214040627.png" alt="image-20211024214040627" style="zoom:50%;" />

```cpp
class WeighedUnionFind{
public:
    vector<int> id;
    vector<int> sz;

    WeighedUnionFind(int N) : id(vector<int>(N, 0)), sz(vector<int>(N, 1)){
        for(int i = 0; i < N; i++)
            id[i] = i;
    }

    bool isConnected(int p, int q){
        return find(p) == find(q);
    }

    int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }

    void uni(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot){
            return;
        }

        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }
    }
};
class Solution {
public:
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n = edges.size();
        WeighedUnionFind wuf(n + 1);

        vector<int> res;
        for(auto& edge : edges){

            if(wuf.isConnected(edge[0], edge[1])){
                res = {edge[0], edge[1]};
                return res;
            }else{
                wuf.uni(edge[0], edge[1]);
            }
        }

        return {-1, -1};
    }
};
```





# 686 Repeated String Match

<img src="601-700.assets/image-20211026095409215.png" alt="image-20211026095409215" style="zoom:50%;" />

```cpp
class Solution {
public:
    int repeatedStringMatch(string a, string b) {
      
      //如果a的长度 比 b 的长度大
        if(a.size() > b.size()){
            if(a.find(b) != string::npos)
                return 1;
            a += a;
            if(a.find(b) != string::npos)
                return 2;
            return -1;
        }

        int times = b.size() / a.size();

        string res;
        for(int i = 0; i < times; i++)
            res += a;
        
      // 比如这种情况 a aaaaaaa
        if(b.size() % a.size() == 0){
            if(res.find(b) == 0)
                return times;
        }

        times += 1;
        res += a;
        int pos = res.find(b);
        if(pos != string::npos){
            return times;
        }

        res += a;
        if(res.find(b) != string::npos)
            return times + 1;
        return -1;
    }
};
```















# 688 Knight Probability In Chessboad



```cpp
实际上 dp 里面存储的是 方法种数
  
  比如到达 dp[i][j] 有几种方法， 类似 63 unique path
  同时 采用 swap 技术， 降维 dp 
  
	这样每次 dp1 是新的， dp0 是旧的
  最后进行交换
class Solution {
public:
    double knightProbability(int n, int k, int row, int column) {
        vector<vector<double>> dp0(n, vector<double>(n, 0));
        dp0[row][column] = 1.0;
        
        int dir[8][2] = {{-1, -2}, {-2, -1}, {1, -2}, {2, -1}, {-2, 1}, {-1, 2}, {1, 2}, {2, 1}};

        for(int round = 0; round < k; round++){
            vector<vector<double>> dp1(n, vector<double>(n, 0.0));
            for(int i = 0; i < n; i++){
                for(int j = 0; j < n; j++){
                    for(int m = 0; m < 8; m++){
                        int newX = i + dir[m][0];
                        int newY = j + dir[m][1];

                        if(newX >= 0 && newY >= 0 && newX < n && newY < n){
                            dp1[newX][newY] += dp0[i][j];
                        }
                    }
                }
            }

            std::swap(dp1, dp0);
        }

        double total = 0;
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                total += dp0[i][j];
            }
        }

        return total / pow(8, k);

    }
};
```











# 689 Maximum Sum of 3 Non-Overlapping subarray



<img src="601-700.assets/image-20210703080839344.png" alt="image-20210703080839344" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        int size = nums.size();
        int len = size - k + 1;

        vector<int> subArrarySum(len, 0);


        int sum = 0;
        for(int i = 0; i < size; i++){
            sum += nums[i];

            if(i - k >= 0){
                sum -= nums[i - k];
            }

            if(i >= k - 1)
                subArrarySum[i - k + 1] = sum;
        }

        int maxIndex = 0;
        vector<int> leftSum(len, 0);
        vector<int> rightSum(len, 0);

        for(int i = 0; i < len; i++){
            if(subArrarySum[maxIndex] < subArrarySum[i]){
                maxIndex = i;
            }

            leftSum[i] = maxIndex;
        }

        maxIndex = len - 1;
        for(int i = len - 1; i >= 0; i--){
            if(subArrarySum[i] >= subArrarySum[maxIndex]){
                maxIndex = i;
            }

            rightSum[i] = maxIndex;
        }

        vector<int> res(3, -1);
        for(int i = k; i < len - k; i++){
            if(res[0] == -1 ||
            subArrarySum[res[0]] + subArrarySum[res[1]] + subArrarySum[res[2]] < subArrarySum[i] + subArrarySum[leftSum[i - k]] + subArrarySum[rightSum[i + k]]){
                res[0] = leftSum[i - k];
                res[1] = i;
                res[2] = rightSum[i + k];
            }

        }
        return res;
    };
};
```







# 692 Top K Freqent Words

<img src="601-700.assets/image-20211109171744163.png" alt="image-20211109171744163" style="zoom:50%;" />

```cpp
class Node{
public:
    int freq;
    string str;
    Node(int f, string s) : freq(f), str(s){}
};
class Solution {
public:
    vector<string> topKFrequent(vector<string>& words, int k) {
        vector<string> res;
        unordered_map<string, int> umap;
        for(auto& word : words){
            umap[word]++;
        }

        vector<Node> vec;
        for(auto it = umap.begin(); it != umap.end(); it++){
            vec.emplace_back(it->second, it->first);
        }

        int size = vec.size();
        int targetIndex = size - k;

        sort(vec.begin(), vec.end(), [&](auto& n1, auto& n2){
            return n1.freq == n2.freq ? n1.str > n2.str : n1.freq < n2.freq;
        });

        int j = vec.size() - 1;
        while(j >= targetIndex){
            res.push_back(vec[j].str);
            j--;
        }

        return res;
    }

    // int parition(vector<Node>& vec, int lo, int hi){
    //     if(lo == hi)
    //         return lo;
        
    //     int i = lo, j = hi + 1;
    //     int freqPivot = vec[lo].freq;

    //     while(true){
    //         while(vec[++i].freq < freqPivot) if(i == hi) break;
    //         while(vec[--j].freq > freqPivot) if(j == lo) break;
        
    //         if(i >= j)
    //             break;
            
    //         exch(vec, i, j);
    //     }   

    //     exch(vec, j, lo);
    //     return j;
    // }

    // void exch(vector<Node>& vec, int i, int j){
    //     Node temp(1, "");
    //     temp.freq   = vec[i].freq;
    //     vec[i].freq = vec[j].freq;
    //     vec[j].freq = temp.freq;

    //     temp.str   = vec[i].str;
    //     vec[i].str = vec[j].str;
    //     vec[j].str = temp.str;
    // }
};
```









# 693 Binary Number with Alternating Bits



![image-20211024110413942](601-700.assets/image-20211024110413942.png)



```cpp
class Solution {
public:
    bool hasAlternatingBits(int n) {
        string res = getBinary(n);
//        cout << res << endl;
        for(int i = 0; i < res.size() - 1; i++){
            if(res[i] == res[i + 1])
                return false;
        }

        return true;
    }

    string getBinary(int n){
        string res;
        while(n != 0){
            int bit = (n & 1);
            n >>= 1;
            res.push_back((char)(bit + '0'));
        }

        return res;
    }
};
```







# 694 Number of Distinct Islands



<img src="601-700.assets/image-20210522155938527.png" alt="image-20210522155938527" style="zoom:50%;" />

```java
```



# 695 Max Area of Island

<img src="601-700.assets/image-20210923165115587.png" alt="image-20210923165115587" style="zoom:50%;" />

```cpp
/*
		典型并查集板子，没啥好说的
*/
class WeightUnionFind{
public:
    vector<int> sz;
    vector<int> id;

    WeightUnionFind(int N) : sz(vector<int>(N, 1)), id(vector<int>(N)){
        for(int i = 0; i < N; i++)
            id[i] = i;
    }

    void uni(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);

        if(pRoot == qRoot)        
            return;
        
        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = id[pRoot];
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = id[qRoot];
        }
    }

    bool isConnected(int p, int q){
        return find(p) == find(q);
    }

    int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }

        return p;
    }
};

class Solution {
public:
    int getCoor(int i, int j){
        return i * col + j;
    }
    
    int row;
    int col;
    int maxAreaOfIsland(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();
        
        WeightUnionFind wuf(52 * 52);
        
        int count = 0;
        auto isInRange = [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};
        int res = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 1){
                    count++;
            
                    if(i == 0 && j == 0)
                        continue;
                    
                    if(i != 0 && grid[i - 1][j] == 1)
                        wuf.uni(getCoor(i, j), getCoor(i - 1, j));
                    if(j != 0 && grid[i][j - 1] == 1)
                        wuf.uni(getCoor(i, j - 1), getCoor(i, j));
                    
                    res = max(res, wuf.sz[wuf.find(getCoor(i, j))]);
                }
            }
        }
        
        return count == 0 ? 0 : max(1, res);
    }
    
    
};
```



# 696 Count Binary Substrings

<img src="601-700.assets/image-20211024100752968.png" alt="image-20211024100752968" style="zoom:50%;" />

```cpp
class Solution {
public:
    int countBinarySubstrings(string s) {
        int left = 0;
        int right = 0;
        int res = 0;
        int size = s.size();

        while(right < size){
            while(right < size && s[right] == s[left])
                right++;
            
            if(right == size)
                break;
            int fixPoint = right;
            // 0 0 1 1 0 0 1 1 
            // l   f   r
            while(right < size && s[right] == s[fixPoint])
                right++;
                        
            res += min(right - fixPoint, fixPoint - left);
            left = fixPoint;
        }

        return res;
    }
};
```







# 697 Degree of an Array

<img src="601-700.assets/image-20211023065421470.png" alt="image-20211023065421470" style="zoom:50%;" />

```cpp
class Solution {
public:
    int findShortestSubArray(vector<int>& nums) {
        unordered_map<int, int> map;
        int degree = 0;
        for(int num : nums){
            map[num]++;
            degree = max(degree, map[num]);
        }

        int left = 0, right = 0;
        int size = nums.size();
        unordered_map<int, int> count;
        int res = INT_MAX;
        while(right < size){
            while(right < size){
                count[nums[right]]++;
                right++;

                if(count[nums[right - 1]] == degree)
                    break;
                
            }

            while(left < right){
                count[nums[left]]--;
                left++;

                if(count[nums[left - 1]] == degree - 1){
                    res = min(res, right - left + 1);
                    break;
                }
            }
        }

        return res;
    }
};
```





# 698 Partition ot K Equal Sum Subsets



```cpp
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0;
        sort(nums.rbegin(), nums.rend());

        for(int num : nums)
            sum += num;
        
        if(sum % k != 0)
            return false;

        vector<bool> visited = vector<bool>(nums.size(), false);
        return backtrack(nums, sum / k, k, visited, 0, 0);
    }

    bool backtrack(vector<int>& nums, int targetSum, int k, vector<bool>& visited, 
        int progress, int curSum)
    {
        if(progress == k && curSum == 0){
            return true;
        }

        for(int i = 0; i < nums.size(); i++){
            if(visited[i])
                continue;

            if(curSum + nums[i] > targetSum)
                break;

            visited[i] = true;    
            
            if(curSum + nums[i] == targetSum){
                if(backtrack(nums, targetSum, k, visited, progress + 1, 0))
                    return true;
            }else{
                if(backtrack(nums, targetSum, k, visited, progress, curSum + nums[i]))
                    return true;                
            }

            visited[i] = false;
        }

        return false;
    }
};
```





```cpp
//超时代码
class Solution {
public:
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0;
        sort(nums.begin(), nums.end());

        for(int num : nums)
            sum += num;
        
        if(sum % k != 0)
            return false;

        vector<bool> visited = vector<bool>(nums.size(), false);
        return backtrack(nums, sum / k, k, visited, 0, 0);
    }

    bool backtrack(vector<int>& nums, int targetSum, int k, vector<bool>& visited, 
        int progress, int curSum)
    {
        if(progress == k && curSum == 0){
            return true;
        }

        for(int i = 0; i < nums.size(); i++){
            if(visited[i])
                continue;

            if(curSum + nums[i] > targetSum)
                break;

            visited[i] = true;    
            
            if(curSum + nums[i] == targetSum){
                if(backtrack(nums, targetSum, k, visited, progress + 1, 0))
                    return true;
            }else{
                if(backtrack(nums, targetSum, k, visited, progress, curSum + nums[i]))
                    return true;                
            }

            visited[i] = false;
        }

        return false;
    }
};
```



