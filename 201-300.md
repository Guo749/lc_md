# 201-300





# 201 Bitwise AND of Numbers Range 

![image-20200712143310847](201-300.assets/image-20200712143310847.png)



```java
/*
	注意审题，他说的是从a~b 比如9 11
	那么就是9 & 10 & 11
	如果只是暴力与，会超出时间限制
	9		0 0 0 0 1 | 0 0 1 
	10       0 0 0 0 1 | 0 1 0 
	11       0 0 0 0 1 | 0 1 1
	12       0 0 0 0 1 | 1 0 0 
	在对上述数字进行完与后, 剩余部分是这些字符串的公共前缀
	换句话说，剩下的部分，因为至少存在1个0，都会消失，最后的结果只取决于公共前缀的大小
	
	因此本题求得是公共前缀的大小
	
	将两个数字向右移动，直到数字相等，即数字被缩减为它们的公共前缀。然后，通过将公共前缀向左移动，将零附加到公共前缀后面以获得最终结果。
*/
class Solution {
  public int rangeBitwiseAnd(int m, int n) {
    int shift = 0;
    // find the common 1-bits
    while (m < n) {
      m >>= 1;
      n >>= 1;
      ++shift;
    }
    return m << shift;
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/solution/shu-zi-fan-wei-an-wei-yu-by-leetcode/
```



# 202 Happy Number

![image-20200712150608053](201-300.assets/image-20200712150608053.png)

![image-20200712151205472](201-300.assets/image-20200712151205472.png)

```java
/*
	使用HashSet记录每次的n
	这样当出现重复的时候，直接return false
*/
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<>();

    while(n != 1)
    {
        if(set.contains(n))
            return false;
        int res = 0;
        set.add(n);
        while(n > 0)
        {
            int c = n % 10;
            res += c * c;
            n /= 10;
        }
        n = res;

    }  
    return true;
}
```





# 203 Remove Linked List Elements

![image-20200712151331358](201-300.assets/image-20200712151331358.png)

![image-20200712151824982](201-300.assets/image-20200712151824982.png)

```java
public ListNode removeElements(ListNode head, int val) {
    if(head == null)        return null;
    while(head != null && head.val == val)      head = head.next;
    if(head == null)        return null;

    ListNode cur = head;
    while(cur != null && cur.next != null)
    {
        if(cur.next.val == val)
        {
            ListNode cleaner = cur.next;
            while(cleaner != null && cleaner.val == val)
                cleaner = cleaner.next;
            cur.next = cleaner;
        } 
        cur = cur.next;

    }
    return head;
}
```

![image-20200809193636091](201-300.assets/image-20200809193636091.png)

```java
public ListNode removeElements(ListNode head, int val) {
    if(head == null)        return null;

    ListNode dummy = new ListNode(0);
    ListNode dummyCur = dummy;

    ListNode cur = head;
    ListNode temp = null;
    while(cur != null)
    {
        temp = cur.next;
        cur.next = null;
        if(cur.val != val){
            dummyCur.next = cur;
            dummyCur = dummyCur.next;
            cur = temp;
        }

        cur = temp;
    }

    return dummy.next;
}
```



# 204 Count Primes

![image-20200712151921543](201-300.assets/image-20200712151921543.png)



```java
/*
	通过17/19
	超出时间限制
	准备拿备忘录优化
*/
public int countPrimes(int n) {
    if(n == 0 || n == 1)    return 0;
    if(n == 2)      return 0;

    boolean flag = false;

    int count = 1;
    for(int i = 3; i < n; i++)
    {
        for(int j = 2; j < i; j++)
        {
            if(i % j == 0)
            {
                flag = true;
                break;
            }

        }
        count += flag? 0 : 1;
        flag = false;
    }

    return count;
}
```

![Sieve_of_Eratosthenes_animation](201-300.assets/Sieve_of_Eratosthenes_animation.gif)

```java
/*
	用notPrime 数组进行优化，节省时间
*/
public class Solution {
    public int countPrimes(int n) {
        boolean[] notPrime = new boolean[n];
        int count = 0;
        for (int i = 2; i < n; i++) 
        {
            if (notPrime[i] == false) 
            {
                count++;
                for (int j = 2; i*j < n; j++) 
                    notPrime[i*j] = true;
            }
        }

        return count;
    }
}
```



# 205 Isomorphic Strings



<img src="201-300.assets/image-20201227211741466.png" alt="image-20201227211741466" style="zoom:50%;" />

```java
//更简单的逻辑判断
class Solution {
    public boolean isIsomorphic(String s, String t) {
        HashMap<Character, Character> mapS = new HashMap<>();
        HashMap<Character, Character> mapT = new HashMap<>();

        if(s.length() != t.length())    return false;

        for(int i = 0; i < s.length(); i++){
            char s1 = s.charAt(i);
            char t1 = t.charAt(i);

            if(mapS.containsKey(s1)){
                if(mapS.get(s1) != t1)
                    return false;
            }else if(mapT.containsKey(t1)){
                return false;
            }else{
                mapS.put(s1, t1);
                mapT.put(t1, s1);
            }
        }   

        return true;
    }
}
```





![image-20200712155852075](201-300.assets/image-20200712155852075.png)

![image-20200804155610700](201-300.assets/image-20200804155610700.png)

```java
public boolean isIsomorphic(String s, String t) {
    HashMap<Character, Character> mapS = new HashMap<>();
    HashMap<Character, Character> mapT = new HashMap<>();
    if(s.length() != t.length())        return false;

    for(int i = 0; i < s.length(); i++)
    {
        char ch1 = s.charAt(i);
        char ch2 = t.charAt(i);
        if(!mapS.containsKey(ch1) && !mapT.containsKey(ch2))
        {
            mapS.put(ch1, ch2);
            mapT.put(ch2, ch1);
        }    
        else if(mapS.containsKey(ch1))
        {
            if(mapS.get(ch1) != ch2)
                return false;
        }
        else if(mapT.containsKey(ch2))
            if(mapT.get(ch2) != ch1)
                return false;
        else
        {
            if(mapS.get(ch1) != ch2 || mapT.get(ch2) != ch1)
                return false;
        }
    }
    return true;
}
```









# 206 Reverse Linked List



![image-20200712181229362](201-300.assets/image-20200712181229362.png)

![image-20200712181437106](201-300.assets/image-20200712181437106.png)



```java
public ListNode reverseList(ListNode head) {
    ListNode cur = head;
    ListNode pre = null, temp = null;

    while(cur != null)
    {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
    return pre;
}
```



```java
/*
	递归解法
*/
class Solution {
	public ListNode reverseList(ListNode head) {
		//递归终止条件是当前为空，或者下一个节点为空
		if(head==null || head.next==null) {
			return head;
		}
		//这里的cur就是最后一个节点
		ListNode cur = reverseList(head.next);
		//这里请配合动画演示理解
		//如果链表是 1->2->3->4->5，那么此时的cur就是5
		//而head是4，head的下一个是5，下下一个是空
		//所以head.next.next 就是5->4
		head.next.next = head;
		//防止链表循环，需要将head.next设置为空
		head.next = null;
		//每层递归函数都返回cur，也就是最后一个节点
		return cur;
	}
}

作者：wang_ni_ma
链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/
```







# 207 Course Schedule

<img src="201-300.assets/image-20201225201744035.png" alt="image-20201225201744035" style="zoom:50%;" />

```java
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegree = new int[numCourses];
        List<List<Integer>> adj = new ArrayList<>();
        for(int i = 0; i < numCourses; i++)
            adj.add(new ArrayList<Integer>());

        for(int[] pre : prerequisites) {
            indegree[pre[0]]++;
            adj.get(pre[0]).add(pre[1]);
        }

        Deque<Integer> queue = new ArrayDeque<>();

        for(int i = 0; i < indegree.length; i++)
            if(indegree[i] == 0)
                queue.add(i);

        HashSet<Integer> finished = new HashSet<>();
        while(!queue.isEmpty()){
            int cur = queue.pollFirst();
            finished.add(cur);
            for(int i = 0; i < numCourses; i++){
                if(adj.get(i).contains(cur)){
                    indegree[i]--;
                    if(indegree[i] == 0)
                        queue.addLast(i);
                }
            }
        }

        return finished.size() == numCourses;
    }
```







# 209 Minimum Size Subarray Sum

![image-20200712193142108](201-300.assets/image-20200712193142108.png)

![image-20200712194340911](201-300.assets/image-20200712194340911.png)

```java
public int minSubArrayLen(int s, int[] nums) {
    int len = nums.length;
    if(len == 0)        return 0;
    if(len == 1)        return nums[0] == s ? 1 : 0;

    int left = 0;
    int right = 0;
    int window = 0;
    int res = Integer.MAX_VALUE;
    while(right < len)
    {
        for(;right < len && window < s; right++) 
            window += nums[right];


        while(window >= s)
        {
            res = Math.min(res, right - left);

            window -= nums[left];
            left++;
        }
    }

    return res == Integer.MAX_VALUE ? 0 : res;
}
```











# 210 Course Schedule II



<img src="201-300.assets/image-20201225200215432.png" alt="image-20201225200215432" style="zoom:50%;" />

```java
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        List<Integer> res = new ArrayList<>();


        int len = numCourses;
        List<List<String>> adj = new ArrayList<>();
        for(int i = 0; i < len; i++)
            adj.add(new ArrayList<>());

        for(int[] pre : prerequisites)
            adj.get(pre[0]).add(pre[1] + "");

        Deque<Integer> queue = new ArrayDeque<>();
        for(int i = 0;  i < len; i++)
            if(adj.get(i).size() == 0)
                queue.addLast(i);

        while(!queue.isEmpty()){
            int cur = queue.pollFirst();
            res.add(cur);

            for(int i = 0; i < len; i++){
                if(adj.get(i).contains(cur + "")){
                    adj.get(i).remove(cur + "");
                    if(adj.get(i).size() == 0)
                        queue.addLast(i);
                }
            }
        }
        if(res.size() != numCourses)    return new int[]{};
        
        int[] ans = new int[res.size()];
        int index = 0;
        for(Integer num : res)
            ans[index++] = num;
        return ans;
    }

```







# 212 Word Search II

![image-20200702203442595](201-300.assets/image-20200702203442595.png)



![image-20200702205140626](201-300.assets/image-20200702205140626.png)

```java
/*
	这个题其实和wordbreak I 没什么本质区别
	记得案例要去重，用set
*/
List<String> res;
private int[][] pos = new int[][]{{-1, 0},{0, -1},{1, 0},{0, 1}};
private char[][] board;
private boolean[][] marked;
public List<String> findWords(char[][] board, String[] words) {
    res = new ArrayList<>();
    this.board = board;
    int row = board.length;
    int column = board[0].length;
    int index = 0;

    for(int k = 0; k < words.length; k++)
    {
        marked = new boolean[row][column];
        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++)
                if(backtrack(i, j, words[k], 0))
                    if(!res.contains(words[k]))
                        res.add(words[k]);
    }

    return res;
}

private boolean backtrack(int i, int j, String s, int checkpoint)
{
    if(checkpoint == s.length() -1)
        return board[i][j] == s.charAt(checkpoint);

    if(s.charAt(checkpoint) == board[i][j])
    {
        marked[i][j] = true;
        for(int k = 0; k < 4; k++)
        {
            int newX = i + pos[k][0];
            int newY = j + pos[k][1];

            if(isInRange(newX, newY) && !marked[newX][newY])
                if(backtrack(newX, newY, s, checkpoint+1))
                    return true;
        }
        marked[i][j] = false;
    }

    return false;
}

private boolean isInRange(int m, int n)
{
    return m >= 0 && n >= 0 && m < board.length && n < board[0].length;
}
```





# 214 Shortest Palindrome  KMP解法待研究



![image-20200712200836942](201-300.assets/image-20200712200836942.png)

```java
/*
	思路：可以从字符串开头找到更大的回文子串，然后反转剩余的子串并附加到开头
	比如"abcbabcab"  从开头找到的最大回文子串 abcba
	将剩余的部分"bcab" 反转并拼接到后面
	
	但是会超出时间限制 119/120
*/
public String shortestPalindrome(String s)
{
    if(s.length() == 0)     return "";
    int index = 0;
    String longestPalindrome = "";
    for(int i = 0; i < s.length(); i++)
    {
        String frac = s.substring(0, i+1);
        if(!isPalindrome(frac))
            continue;
        else
        {
            index = i;
            longestPalindrome = frac;
        }
    }
    StringBuilder sb = new StringBuilder(s.substring(index+1));
    String str = sb.reverse().toString();
    return str + longestPalindrome + sb.reverse().toString();

}

private boolean isPalindrome(String frac) {
    int left = 0, right = frac.length()-1;
    while(left < right)
    {
        if(frac.charAt(left) != frac.charAt(right))
            return false;
        else
        {left++; right--;}
    }
    return true;
}

//----------------------------------------------------------
//CLEAN VERSION
//这种情况下可以过
public String shortestPalindrome(String s) {
    int i = 0, end = s.length() - 1, j = end; char chs[] = s.toCharArray();
    while(i < j) {
         if (chs[i] == chs[j]) {
             i++; j--;
         } else { 
             i = 0; end--; j = end;
         }
    }
    return new StringBuilder(s.substring(end+1)).reverse().toString() + s;
}
```



```java
public String shortestPalindrome(String s) {
    String temp = s + "#" + new StringBuilder(s).reverse().toString();
    int[] table = getTable(temp);

    //get the maximum palin part in s starts from 0
    return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;
}

public int[] getTable(String s){
    //get lookup table
    int[] table = new int[s.length()];

    //pointer that points to matched char in prefix part

    int index = 0;
    //skip index 0, we will not match a string with itself
    for(int i = 1; i < s.length(); i++){
        if(s.charAt(index) == s.charAt(i)){
            //we can extend match in prefix and postfix
            table[i] = table[i-1] + 1;
            index ++;
        }else{
            //match failed, we try to match a shorter substring

            //by assigning index to table[i-1], we will shorten the match string length, and jump to the 
            //prefix part that we used to match postfix ended at i - 1
            index = table[i-1];

            while(index > 0 && s.charAt(index) != s.charAt(i)){
                //we will try to shorten the match string length until we revert to the beginning of match (index 1)
                index = table[index-1];
            }

            //when we are here may either found a match char or we reach the boundary and still no luck
            //so we need check char match
            if(s.charAt(index) == s.charAt(i)){
                //if match, then extend one char 
                index ++ ;
            }

            table[i] = index;
        }

    }

    return table;
}
https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation
```



# 215 Kth Largest Element in An array   快排Partition

![image-20200713081505526](201-300.assets/image-20200713081505526.png)

![image-20200713082344396](201-300.assets/image-20200713082344396.png)

```java
public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    int count = 0;
    for(int i = 0; i < nums.length; i++)
    {
        count++;
        if(count == nums.length - k + 1)
            return nums[i];
    }
    return -1;
}

public class Solution {

    public int findKthLargest(int[] nums, int k) {
        int len = nums.length;
        Arrays.sort(nums);
        return nums[len - k];
    }
}
作者：liweiwei1419
```



```java
//用了快排中的partition
public int findKthLargest(int[] nums, int k) {
    int len = nums.length;
    int left = 0;
    int right = len - 1;

    // 转换一下，第 k 大元素的索引是 len - k
    int target = len - k;

    while (true) {
        int index = partition(nums, left, right);
        if (index == target) {
            return nums[index];
        } else if (index < target) {
            left = index + 1;
        } else {
            right = index - 1;
        }
    }
}


public int partition(int[] nums, int lo, int hi) {
    int i = lo, j = hi + 1;
    int v = nums[lo];
    while(true)
    {
        //这里对快排在算法四中进行一点修改，以便能够通过测试，否则会越界
        while(++i < nums.length && nums[i] < v)	if(i == hi)		break;
        while(nums[--j] > v)	                if(j == lo)	   	break;
        if(i >= j)						       				 break;
        exch(nums, i, j);
    }
    exch(nums, lo, j);
    return j;
}

private void exch(int[] nums, int index1, int index2) {
    int temp = nums[index1];
    nums[index1] = nums[index2];
    nums[index2] = temp;
}
```



# 217 Contains Duplicate

![image-20200713084002208](201-300.assets/image-20200713084002208.png)

![image-20200713084134102](201-300.assets/image-20200713084134102.png)

```java
public boolean containsDuplicate(int[] nums) {
    HashSet<Integer> set = new HashSet<Integer>();
    for(int i = 0; i < nums.length; i++)
        if(set.contains(nums[i]))
            return true;
    else
        set.add(nums[i]);
    return false;
}
```





# 219 Contains Duplicate II  哈希表实现滑动窗口

![image-20200713084247106](201-300.assets/image-20200713084247106.png)

![image-20200713091046808](201-300.assets/image-20200713091046808.png)

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    for(int i = 0; i < nums.length; i++)
        for(int j = i+1; j <= i+k; j++)
            if(j < nums.length && nums[j] == nums[i])
                return true;
    return false;
}
```

![image-20200804160538194](201-300.assets/image-20200804160538194.png)

```java
public boolean containsNearbyDuplicate(int[] nums, int k) {
    HashMap<Integer, List<Integer>> map = new HashMap<>();

    for(int i = 0; i < nums.length; i++)
    {
        if(!map.containsKey(nums[i]))
            map.put(nums[i], new ArrayList<>());
        map.get(nums[i]).add(i);
    }

    for(List<Integer> jar : map.values())
    {
        if(jar.size() <= 1)     continue;

        Collections.sort(jar);
        for(int i = 0; i < jar.size()-1; i++)
            if(jar.get(i+1) - jar.get(i) <= k )
                return true;
    }
    return false;
}
```



# 220 Contains Duplicate III  桶排序的应用

![image-20200713092404290](201-300.assets/image-20200713092404290.png)



```java
//暴力解法
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    long[] numsl = new long[nums.length];
    for(int i = 0; i < nums.length; i++)
        numsl[i] = (long)nums[i];

    for(int i = 0; i < nums.length; i++)
        for(int j = i + 1; j <= i + k && j < nums.length; j++)
            if(Math.abs(numsl[i] - numsl[j]) <= t)
                return true;
    return false;
}
```



```java
public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
    if (t < 0) {
        return false;
    }
    HashMap<Long, Long> map = new HashMap<>();
    int n = nums.length;
    long w = t + 1; // 一个桶里边数字范围的个数是 t + 1
    for (int i = 0; i < n; i++) {
        //删除窗口中第一个数字
        if (i > k) {
            map.remove(getId(nums[i - k - 1], w));
        }
        //得到当前数的桶编号
        long id = getId(nums[i], w);
        if (map.containsKey(id)) {
            return true;
        }
        if (map.containsKey(id + 1) && map.get(id + 1) - nums[i] < w) {
            return true;
        }

        if (map.containsKey(id - 1) && nums[i] - map.get(id - 1) < w) {
            return true;
        }
        map.put(id, (long) nums[i]);
    }
    return false;
}

private long getId(long num, long w) {
    if (num >= 0) {
        return num / w;
    } else {
        return (num + 1) / w - 1;
    }
}

作者：windliang
链接：https://leetcode-cn.com/problems/contains-duplicate-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-46/
```



# 221 Maximal Rectangle



```java
public int maximalSquare(char[][] matrix) {
    int row = matrix.length, column = row == 0 ? 0 :matrix[0].length;
    if(column == 0)     return 0;
    int[][] dp = new int[row][column];

    for(int i = 0; i < row; i++)
        for(int j = 0; j < column; j++)
        {
            if(i == 0)
            {
                if(matrix[i][j] == '1')
                    dp[i][j] = 1;
            }
            else if(j == 0)
            {
                if(matrix[i][j] == '1')
                    dp[i][j] = 1 + dp[i-1][j];
            }
            else
                if(matrix[i][j] == '1')
                    dp[i][j] = 1 + dp[i-1][j];
        }

    int maxArea = 0, curWidth = 0, curHeight = 0;
    for(int i = 0; i < row; i++)
        for(int j = 0; j < column; j++)
        {
            if(dp[i][j] == 0)       continue;

            curHeight = dp[i][j];
            for(int k = j; k >= 0; k--)
            {
                if(dp[i][k] == 0)       break;
                curHeight = Math.min(curHeight, dp[i][k]);
                curWidth = j - k + 1;
                int side = Math.min(curHeight, curWidth);
                maxArea = Math.max(side * side, maxArea);
            }
        }
    return maxArea;
}
```







# 223 Rectangle Area

![image-20200713141709458](201-300.assets/image-20200713141709458.png)



```java
class Solution {
    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {
        int leftTopX = Math.max(A, E);
        int leftTopY = Math.min(D, H);
        int leftBotX = leftTopX;
        int leftBotY = Math.max(B,F);

        int rightTopX = Math.min(C, G);
        int rightTopY = leftTopY;
        int rightBotX = rightTopX;
        int rightBotY = leftBotY;

        int total = Math.abs(A-C) * Math.abs(B - D) + Math.abs(E - G) * Math.abs(F - H);

        if(C <= E || G <= A || D <= F || H <= B)
            return total;

        return total - (rightTopX - leftTopX) * (rightTopY - rightBotY);
    }
}
```



# 224 Basic Calculator简易计算器

![image-20200713143018935](201-300.assets/image-20200713143018935.png)



```java
/*
思路： 中缀转后缀表达式 + 逆波兰计算
	
中缀转后缀
1）如果遇到操作数，我们就直接将其加入到后缀表达式。

2）如果遇到左括号，则我们将其放入到栈中。

3）如果遇到一个右括号，则将栈元素弹出，将弹出的操作符加入到后缀表达式直到遇到左括号为止，接着将左括号弹出，但不加入到结果中。

4）如果遇到其他的操作符，如（“+”， “-”）等，从栈中弹出元素将其加入到后缀表达式，直到栈顶的元素优先级比当前的优先级低（或者遇到左括号或者栈为空）为止。弹出完这些元素后，最后将当前遇到的操作符压入到栈中。

5）如果我们读到了输入的末尾，则将栈中所有元素依次弹出。
*/

public int calculate(String s) {
    String[] polish = getPolish(s); //转后缀表达式
    return evalRPN(polish);
}

//中缀表达式转后缀表达式
private String[] getPolish(String s) {
    List<String> res = new ArrayList<>();
    Stack<String> stack = new Stack<>();
    char[] array = s.toCharArray();
    int n = array.length;
    int temp = -1; //累加数字，-1 表示当前没有数字
    for (int i = 0; i < n; i++) {
        if (array[i] == ' ') {
            continue;
        }
        //遇到数字
        if (isNumber(array[i])) {
            //进行数字的累加
            if (temp == -1) {
                temp = array[i] - '0';
            } else {
                temp = temp * 10 + array[i] - '0';
            }
        } 
        else {
            //遇到其它操作符，将数字加入到结果中
            if (temp != -1) {
                res.add(temp + "");
                temp = -1;
            }
            if (isOperation(array[i] + "")) {
                //遇到操作符将栈中的操作符加入到结果中
                while (!stack.isEmpty()) {
                    //遇到左括号结束
                    if (stack.peek().equals("(")) {
                        break;
                    }
                    res.add(stack.pop());
                }
                //当前操作符入栈
                stack.push(array[i] + "");
            } else {
                //遇到左括号，直接入栈
                if (array[i] == '(') {
                    stack.push(array[i] + "");
                }
                //遇到右括号，将出栈元素加入到结果中，直到遇到左括号
                if (array[i] == ')') {
                    while (!stack.peek().equals("(")) {
                        res.add(stack.pop());
                    }
                    //左括号出栈
                    stack.pop();
                }

            }
        }
    }
    //如果有数字，将数字加入到结果
    if (temp != -1) {
        res.add(temp + "");
    }
    //栈中的其他元素加入到结果
    while (!stack.isEmpty()) {
        res.add(stack.pop());
    }
    String[] sArray = new String[res.size()];
    //List 转为 数组
    for (int i = 0; i < res.size(); i++) {
        sArray[i] = res.get(i);
    }
    return sArray;
}

// 下边是 150 题的代码，求后缀表达式的值
public int evalRPN(String[] tokens) {
    Stack<String> stack = new Stack<>();
    for (String t : tokens) {
        if (isOperation(t)) {
            int a = stringToNumber(stack.pop());
            int b = stringToNumber(stack.pop());
            int ans = eval(b, a, t.charAt(0));
            stack.push(ans + "");
        } else {
            stack.push(t);
        }
    }
    return stringToNumber(stack.pop());
}

private int eval(int a, int b, char op) {
    switch (op) {
        case '+':
            return a + b;
        case '-':
            return a - b;
        case '*':
            return a * b;
        case '/':
            return a / b;
    }
    return 0;
}

private int stringToNumber(String s) {
    int sign = 1;
    int start = 0;
    if (s.charAt(0) == '-') {
        sign = -1;
        start = 1;
    }
    int res = 0;
    for (int i = start; i < s.length(); i++) {
        res = res * 10 + s.charAt(i) - '0';
    }
    return res * sign;
}

private boolean isNumber(char c) {
    return c >= '0' && c <= '9';
}

private boolean isOperation(String t) {
    return t.equals("+") || t.equals("-") || t.equals("*") || t.equals("/");
}
作者：windliang
链接：https://leetcode-cn.com/problems/basic-calculator/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--47/
```



# 225 Implement Stack Using Queues

​                                      ![image-20200713143508936](201-300.assets/image-20200713143508936.png)

![image-20200713143812690](201-300.assets/image-20200713143812690.png)

```java
int num;
Deque<Integer> queue;

/** Initialize your data structure here. */
public MyStack() {
    num = 0;
    queue = new ArrayDeque<>();
}

/** Push element x onto stack. */
public void push(int x) {
    queue.addLast(x);
    num++;
}

/** Removes the element on top of the stack and returns that element. */
public int pop() {
    num--;
    return queue.removeLast();
}

/** Get the top element. */
public int top() {
    return queue.getLast();
}

/** Returns whether the stack is empty. */
public boolean empty() {
    return num == 0;
}

```



# 228 Summary Ranges

![image-20200713144048789](201-300.assets/image-20200713144048789.png)

![image-20200713144733571](201-300.assets/image-20200713144733571.png)

```java
public List<String> summaryRanges(int[] nums) {
    List<String> res = new ArrayList<>();
    for(int i = 0; i < nums.length; )
    {
        int index = i;
        while(index + 1< nums.length && nums[index] + 1 == nums[index+1])
            index++;
        if(index == i)
            res.add(nums[i] + "");
        else
        {
            StringBuilder sb = new StringBuilder();
            sb.append(nums[i]).append("->").append(nums[index]);
            res.add(sb.toString()); 
        }
        i = index + 1;
    }

    return res;
}
```



# 229 Majority Element II  摩尔投票法

![image-20200713145040188](201-300.assets/image-20200713145040188.png)

![image-20200713145554659](201-300.assets/image-20200713145554659.png)

```java
/*
	内存消耗为 O(n) 不符合要求
*/
public List<Integer> majorityElement(int[] nums) {
    List<Integer> res = new ArrayList<>();
    HashMap<Integer, Integer> map = new HashMap<>();
    for(int i = 0; i < nums.length; i++)
    {
        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        if(map.get(nums[i]) > nums.length / 3)
            if(!res.contains(nums[i]))
                res.add(nums[i]);
    } 
    return res;
}
```



```java
/*
	看这个题之前，首先要看一道简单题， 就是求众数 169
	"该元素出现频率 >n / 2"
	之所以摩尔投票法可以成功的原因是因为
		投票法是遇到相同的则票数 + 1， 遇到不同的则票数 - 1
		且"多数元素" 的个数 - 其余元素的个数综合， 结果肯定 >= 1
	
	类似于， "多数元素" - "其余元素" 两两抵消， 抵消到最后， 肯定至少还剩余 1个多数元素
*/

public int majorityElememnt(int[] nums)
{
    int cand_num = nums[0], count = 1;
    for(int i = 1; i < nums.length; i++)
    {
        if(cand_num == nums[i])
            count++;
        else if(--count == 0)
        {
            cand_num = nums[i];
            count = 1;
        }
    }
    return cand_num;
}
```



```java
/*
	KWOK NOTE:
	本题说要找出多个众数，其中众数的出现频率一定是大于n / 3
	那么推论是，数量最多两个，原因是
		如果众数有3个， 每个出现频率大于 n / 3, 那么最后的数组个数为 3 * (more than n /3) > n
		不符合题意，因此众数的个数只可能是k - 1 个， 其中k 为 n / k的k

	算法具体步骤
		if	    如果投A， A++
		else if 如果投B,  B++
		else 如果投其他人， 检查A B 票数是否 == 0， 
			如果是，则当前元素成为新的候选元素
			如果不是， 那么A B 的候选人票数全部减1

		最后的情况是 有两个人大于n/3, 有1个人大于n/3, 没有众数
		同时在最后，还要遍历两个候选人，确保他们满足 > n / 3 条件，找出两个候选人的具体票数
			因为题目并没有保证一定有

*/
class Solution {
    public List<Integer> majorityElement(int[] nums) {
        List<Integer> res = new ArrayList<>();
        if (nums == null || nums.length == 0) 
            return res;

        // 定义两个候选者和它们的票数
        int cand1 = 0,cand2 = 0;    
        int cnt1 = 0, cnt2 = 0;
        // 投票过程
        for (int num : nums) {
            if (num == cand1) {
                cnt1++;
                // 一遍遍历，如果你不想写continue，你写多个else if也可以
                continue;
            }
            else if (num == cand2) {
                cnt2++;
                continue;
            }
            // 既不是cand1也不是cand2，如果cnt1为0，那它就去做cand1
            else if (cnt1 == 0) {
                cand1 = num;
                cnt1++;
                continue;
            }
            // 如果cand1的数量不为0但是cand2的数量为0，那他就去做cand2
            else if (cnt2 == 0) {
                cand2 = num;
                cnt2++;
                continue;
            }
            // 如果cand1和cand2的数量都不为0，那就都-1
            cnt1--;
            cnt2--;
        }

        // 检查两个票数符不符合
        cnt1 = cnt2 = 0;
        for (int num : nums) {
            if (num == cand1) 
                cnt1++;

            else if (num == cand2) 
                // 这里一定要用else if
                // 因为可能出现[0,0,0]这种用例，导致两个cand是一样的，写两个if结果就变为[0,0]了
                cnt2++;

        }
        int n = nums.length;
        if (cnt1 > n / 3) 
            res.add(cand1);

        if (cnt2 > n / 3) 
            res.add(cand2);

        return res;
    }
}

作者：jerry_nju
    链接：https://leetcode-cn.com/problems/majority-element-ii/solution/169ti-sheng-ji-ban-xiang-jie-zhu-xing-jie-shi-tong/

//revised version
public List<Integer> majorityElement(int[] nums) {
    ArrayList<Integer> res = new ArrayList<>();

    if(nums.length == 0 || nums == null)        return res;
    if(nums.length == 1){
        res.add(nums[0]);
        return res;
    }

    int cand_1 = 0, cand_2 = 0;
    int cnt_1 = 0, cnt_2 = 0;

    for(int i = 0; i < nums.length; i++)
    {
        if      (cand_1 == nums[i])   cnt_1++;
        else if (cand_2 == nums[i])   cnt_2++;
        else if (cnt_1 == 0)          {cand_1 = nums[i];    cnt_1++;}
        else if (cnt_2 == 0)          {cand_2 = nums[i];    cnt_2++;}
        else    {cnt_1--;   cnt_2--;}
    }

    cnt_1 = 0;  cnt_2 = 0;
    for(int num : nums)
        if(cand_1 == num)
            cnt_1++;
        else if(cand_2 == num)
            cnt_2++;
    
    if(cnt_1 > nums.length / 3)     res.add(cand_1);
    if(cnt_2 > nums.length / 3)     res.add(cand_2);

    return res;
}
```



# 231 Power of Two

![image-20200713150718885](201-300.assets/image-20200713150718885.png)



```java
//通过全部测试案例，就是一个位运算
public boolean isPowerOfTwo(int n) {
    long nn = n;
    if(n == 0)      return false;
    if(n == Integer.MIN_VALUE)      return false;
    int count = 0;
    for(int i = 0; i < 32; i++)
    {
        long res = (n & 1);
        if(res == 0)    {}
        else            count++;

        if(count >= 2)      return false;
        n >>= 1;
    }
    return true;
}
```





# 232 Implement Queue using Stacks

![image-20200713152203196](201-300.assets/image-20200713152203196.png)

```java
import java.util.Stack;

public class MyQueue {

    private Stack<Integer> stackPush;
    private Stack<Integer> stackPop;

    /**
     * Initialize your data structure here.
     */
    public MyQueue() {
        stackPush = new Stack<>();
        stackPop = new Stack<>();
    }

    /**
     * Push element x to the back of queue.
     */
    public void push(int x) {
        stackPush.push(x);
    }

    /**
     * 辅助方法：一次性将 stackPush 里的所有元素倒入 stackPop
     * 注意：1、该操作只在 stackPop 里为空的时候才操作，否则会破坏出队入队的顺序
     * 2、在 peek 和 pop 操作之前调用该方法
     */
    private void shift() {
        if (stackPop.isEmpty()) {
            while (!stackPush.isEmpty()) {
                stackPop.push(stackPush.pop());
            }
        }
    }

    /**
     * Removes the element from in front of queue and returns that element.
     */
    public int pop() {
        shift();
        if (!stackPop.isEmpty()) {
            return stackPop.pop();
        }
        throw new RuntimeException("队列里没有元素");
    }

    /**
     * Get the front element.
     */
    public int peek() {
        shift();
        if (!stackPop.isEmpty()) {
            return stackPop.peek();
        }
        throw new RuntimeException("队列里没有元素");
    }

    /**
     * Returns whether the queue is empty.
     */
    public boolean empty() {
        return stackPush.isEmpty() && stackPop.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/implement-queue-using-stacks/solution/shi-yong-liang-ge-zhan-yi-ge-zhuan-men-ru-dui-yi-g/
```



# 233 Number of Digit One 未完成

![image-20200713180323653](201-300.assets/image-20200713180323653.png)



```java
class Solution {
    public int countDigitOne(int n) {
        //求每个位的数字所用
        int index = 1;
        //记录1的个数
        int count = 0;
        int high = n,cur = 0,low = 0;
        //由于high = n /(index*10) 中index *10 很容易越位
        //特修改如下
        while(high > 0){
            high /= 10;
            cur = (n / index) % 10;
            low = n - (n / index) * index;
            //以下是计算的公式
            if(cur == 0) count += high * index;
            if(cur == 1) count += high * index + low + 1;
            if(cur > 1) count += (high+1) * index;
            index *= 10;
        }
        return count;
    }
}

作者：xyx1273930793
链接：https://leetcode-cn.com/problems/number-of-digit-one/solution/java100fu-si-lu-shuo-ming-by-xyx1273930793/
```





# 234 Palindrome Linked List

![image-20200713183653809](201-300.assets/image-20200713183653809.png)

![image-20200713183646554](201-300.assets/image-20200713183646554.png)

```java
/*
	不足点是用了O(n)的额外空间
*/
public boolean isPalindrome(ListNode head) {
    List<Integer> list = new ArrayList<>();
    ListNode cur = head;
    if(head == null)        return true;
    while(cur != null)
    {
        list.add(cur.val);
        cur = cur.next;
    }
    int left = 0, right = list.size()-1;
    while(left < right)
    {
        if(!list.get(left).equals(list.get(right)))
            return false;
        left++;
        right--;
    }
    return true;

}
```

![image-20200713184839900](201-300.assets/image-20200713184839900.png)

```java
/*
	快慢指针走到一半，然后反转后半段链表进行判断
	O(1) space
*/
public boolean isPalindrome(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    if(head == null)        return true;
    
    //拿到中间位置
    while(fast != null && fast.next != null)
    {
        slow = slow.next;
        fast = fast.next.next;
    }
	//slow 此时指向的位置，就是链表的中间部分
    
    //-----------反转链表开始------------------
    ListNode cur = slow;
    ListNode temp = null, pre = null;

    while(cur != null)
    {
        temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
    }
   //-----------反转链表结束------------------
    
    //开始判断
    while(pre != null)
    {
        if(pre.val != head.val)
            return false;
        pre = pre.next;
        head = head.next;
    }
    return true;
}
```



# 236 Lowest Common Ancestor of a Binary Tree 未完成

![image-20200713194751944](201-300.assets/image-20200713194751944.png)





# 237 Delete Node in a Linked List

![image-20200713195743193](201-300.assets/image-20200713195743193.png)

![image-20200713195724023](201-300.assets/image-20200713195724023.png)

```java
public void deleteNode(ListNode node) {
    if(node == null)        return;

    ListNode cur = node;
    while(cur != null && cur.next != null)
    {
        if(cur.next.next == null)
        {
            cur.val = cur.next.val;
            cur.next = null;
            return;
        }

        cur.val = cur.next.val;
        cur = cur.next;

    }
```



```java
/*
	更加简洁的办法
*/
class Solution {
    public void deleteNode(ListNode node) {
        
        node.val = node.next.val;
        
        node.next = node.next.next;

    }
}
```





# 238 Product of Array Except Self

![image-20200713200104085](201-300.assets/image-20200713200104085.png)

![image-20200713201708982](201-300.assets/image-20200713201708982.png)

```java
/*
	讲个题外话，看到题目描述中说prefix 和suffix 就算是提示了
	所以才能解出这个题
*/
public int[] productExceptSelf(int[] nums) {
    int[] prefix = new int[nums.length];
    int[] suffix = new int[nums.length];

    for(int i = 0; i < nums.length; i++)
    {
        if(i == 0)      prefix[i] = nums[0];
        else            prefix[i] = prefix[i-1] * nums[i];
    }
    for(int i = nums.length - 1; i >= 0; i--)
    {
        if(i == nums.length -1)      suffix[i] = nums[nums.length-1];
        else                        suffix[i] = suffix[i+1] * nums[i];    
    }

    int[] Output = new int[nums.length];
    for(int i = 0; i < nums.length; i++)
    {
        if      (i == 0)              Output[i] = suffix[1];
        else if (i == nums.length-1)  Output[i] = prefix[nums.length-2];
        else                          Output[i] = prefix[i-1] * suffix[i+1];
    }
    return Output;

}
```



```java
//符合空间复杂度的方法
public int[] productExceptSelf(int[] nums) {
    int[] res   = new int[nums.length];

    for(int i = 0; i < nums.length; i++)
    {
        if(i == 0)
            res[0] = 1;
        else
            res[i] = res[i-1] * nums[i-1];
    }

    int right = 1;
    for(int i = nums.length - 1; i >= 0; i --)
    {
        res[i] = res[i] * right;
        right *= nums[i];
    }    
    return res;

}
```



# 239 Sliding Window Maximum

![image-20200813090813488](201-300.assets/image-20200813090813488.png)

```java
//单调队列解法

/*
	郭郭版本的单调队列解法
*/
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> queue = new ArrayDeque<>();
        int index = 0;
        int[] res = new int[nums.length - k + 1];
        for(int i = 0; i < nums.length; i++){
            while(!queue.isEmpty() && nums[i] > queue.peekLast()){
                queue.pollLast();
            }
            queue.addLast(nums[i]);


            if(i >= k - 1) {
                res[index++] = queue.peekFirst();
                if(i >= k - 1 && nums[i - k + 1] == queue.peekFirst())
                    queue.removeFirst();
            }
        }

        return res;
    }


//用pq 的话，时间复杂度太高，超不过一个案例
public int[] maxSlidingWindow(int[] nums, int k) {
    PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> o2- o1);
    int[] output = new int[nums.length - k + 1];

    for(int i = 0; i < k - 1; i++)
        pq.add(nums[i]);

    for(int i = k - 1; i < nums.length; i++)
    {
        pq.add(nums[i]);
        output[i - k + 1] = pq.peek();
        pq.remove(nums[i - (k - 1)]);
    }

    return output;
}
```



# 240 Search a 2D Matrix II



![image-20200714071828760](201-300.assets/image-20200714071828760.png)



```java
public boolean searchMatrix(int[][] matrix, int target) {
    if(matrix.length == 0 || matrix[0].length == 0)      return false;
    for(int i = 0; i < matrix.length; i++)
    {
        if(matrix[i][0] > target)   break;

        if(matrix[i][matrix[i].length-1] < target) continue;

        int col = binarySearch(matrix[i], target);

        if(col != -1)       return true;
    }
    return false;
}

//单独对一行进行二分查找
private int binarySearch(int[] nums, int target)
{
    int left = 0; 
    int right = nums.length -1;

    while(left <= right)
    {
        int mid = (left + right)/ 2;
        if(nums[mid] == target)
            return mid;
        else if (nums[mid] > target)
            right = mid - 1;
        else
            left = mid + 1;
    }
    return -1;
}
参考
    作者：windliang
    链接：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-4/
```



```java
/*
	解法二：
	注意题目条件，每一行被sorted， 每一列被sorted
	我们从右上角开始搜索
		如果target > 当前元素 ，那么这一行就被排除掉
		如果target < 当前元素， 那么这一列都被排除掉，因为列也被sorted
	时间复杂度为O(M+N), 十分类似BST where 往左变小，往右变大
*/
public boolean searchMatrix(int[][] matrix, int target) {
    if(matrix.length == 0 || matrix[0].length == 0)		return false;
    int row = matrix.length;
    int column = matrix[0].length;
    int curRow = 0, curCol = column-1;
    while(curRow != row && curCol != -1)
    {
        if     (matrix[curRow][curCol] == target)        return true;
        else if(matrix[curRow][curCol] > target)         curCol--;
        else if(matrix[curRow][curCol] < target)         curRow++;
    }

    return false;
}
```

![image-20200714080502241](201-300.assets/image-20200714080502241.png)



# 241 Different Ways to Add Parentheses 递归的又一应用

![image-20200714081123687](201-300.assets/image-20200714081123687.png)



```java
/*
	整体思路：
		* 先对全是数字的进行处理
		* 对每一个运算符的左右两边进行处理
*/
public List<Integer> diffWaysToCompute(String input) {
    if (input.length() == 0) 
        return new ArrayList<>();

    List<Integer> result = new ArrayList<>();

    //----------------如果该字符串是数字的处理---------------------------------------
    int index = 0;
    int num = 0;
    while (index < input.length() && !isOperation(input.charAt(index))) 
        num = num * 10 + input.charAt(index++) - '0';

    //将全数字的情况直接返回
    if (index == input.length()) {
        result.add(num);
        return result;
    }
    //---------------结束全是数字的处理阶段------------------------------

    for (int i = 0; i < input.length(); i++) {
        //通过运算符将字符串分成两部分
        if (isOperation(input.charAt(i))) {
            List<Integer> result1 = diffWaysToCompute(input.substring(0, i));
            List<Integer> result2 = diffWaysToCompute(input.substring(i + 1));
            //将两个结果依次运算
            for (int j = 0; j < result1.size(); j++) {
                for (int k = 0; k < result2.size(); k++) {
                    char op = input.charAt(i);
                    result.add(caculate(result1.get(j), op, result2.get(k)));
                }
            }
        }
    }
    return result;
}

private int caculate(int num1, char c, int num2) {
    switch (c) {
        case '+':
            return num1 + num2;
        case '-':
            return num1 - num2;
        case '*':
            return num1 * num2;
    }
    return -1;
}

private boolean isOperation(char c) {
    return c == '+' || c == '-' || c == '*';
}

作者：windliang
链接：https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-5/
```



```java
/*
	优化递归， 使用备忘录
*/
//添加一个 map
HashMap<String,List<Integer>> map = new HashMap<>();
public List<Integer> diffWaysToCompute(String input) {
    if (input.length() == 0) {
        return new ArrayList<>();
    }
    //如果已经有当前解了，直接返回
    if(map.containsKey(input)){
        return map.get(input);
    }
    List<Integer> result = new ArrayList<>();
    
    int num = 0;
    int index = 0;
    while (index < input.length() && !isOperation(input.charAt(index))) {
        num = num * 10 + input.charAt(index) - '0';
        index++;
    }
    if (index == input.length()) {
        result.add(num);
        //存到 map
        map.put(input, result);
        return result;
    }
    for (int i = 0; i < input.length(); i++) {
        if (isOperation(input.charAt(i))) {
            List<Integer> result1 = diffWaysToCompute(input.substring(0, i));
            List<Integer> result2 = diffWaysToCompute(input.substring(i + 1));
            for (int j = 0; j < result1.size(); j++) {
                for (int k = 0; k < result2.size(); k++) {
                    char op = input.charAt(i);
                    result.add(caculate(result1.get(j), op, result2.get(k)));
                }
            }
        }
    }
     //存到 map
    map.put(input, result);
    return result;
}

private int caculate(int num1, char c, int num2);
    //same
private boolean isOperation(char c) ;
   //SAME


作者：windliang
链接：https://leetcode-cn.com/problems/different-ways-to-add-parentheses/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-5/
```



# 242 Valid Anagram

![image-20200714084825265](201-300.assets/image-20200714084825265.png)

![image-20200714085054906](201-300.assets/image-20200714085054906.png)

```java
public boolean isAnagram(String s, String t) {
    if(s.length() != t.length())        return false;
    HashMap<Character, Integer> mapS = new HashMap<>();
    HashMap<Character, Integer> mapT = new HashMap<>();

    for(int i = 0; i < s.length(); i++)
    {
        mapS.put(s.charAt(i), mapS.getOrDefault(s.charAt(i), 0) + 1);
        mapT.put(t.charAt(i), mapT.getOrDefault(t.charAt(i), 0) + 1);
    }

    if(mapS.equals(mapT))       return true;
    else                        return false;
}
```



# 243 Shortest Word Distance

![image-20200714085213658](201-300.assets/image-20200714085213658.png)

![image-20200714091252873](201-300.assets/image-20200714091252873.png)

```java
/*
	典型的滑动窗口题目
*/
public int shortestDistance(String[] words, String word1, String word2) {
    int left = 0, right = 0;
    int res = Integer.MAX_VALUE;
    while(left < words.length && right < words.length)
    {
        while(left < words.length && !words[left].equals(word1))
            left++;
        while(right < words.length && !words[right].equals(word2))
            right++;
        if(left == words.length || right == words.length)    break;

        if(right - left == 0)       continue;
        else
            res = Math.min(res, Math.abs(right - left));
        if(left < right)    left++;
        else                right++;
    }

    return res;
}
```



# 244 Shortest Word Distance II 

![image-20200714091322066](201-300.assets/image-20200714091322066.png)

![image-20200714092509774](201-300.assets/image-20200714092509774.png)

```java
private HashMap<String, List<Integer>> map;
public WordDistance(String[] words) {
    map = new HashMap<>();
    for(int i = 0; i < words.length; i++)
    {
        if(!map.containsKey(words[i]))
            map.put(words[i], new ArrayList<>());

        map.get(words[i]).add(i);
    }
}

public int shortest(String word1, String word2) {
    int res = Integer.MAX_VALUE;
    List<Integer> jar1 = map.get(word1);
    List<Integer> jar2 = map.get(word2);
    for(Integer i : jar1)
        for(Integer j : jar2)
            res = Math.min(res, Math.abs(i-j));

    return res;
}
```





# 245 Shortest word distanceIII

![image-20200714092952086](201-300.assets/image-20200714092952086.png)

![image-20200714092946270](201-300.assets/image-20200714092946270.png)

```java
public int shortestWordDistance(String[] words, String word1, String word2) {
    int left = 0, right = 0;
    int res = Integer.MAX_VALUE;
    while(left < words.length && right < words.length)
    {
        while(left < words.length && !words[left].equals(word1))
            left++;
        while(right < words.length && !words[right].equals(word2))
            right++;
        if(left == words.length || right == words.length)    break;

        if(right - left == 0)       {}
        else
            res = Math.min(res, Math.abs(right - left));

        if(left < right)    left++;
        else                right++;
    }

    return res;

}
```





# 246 Strobogrammatic number 

![image-20200714095843747](201-300.assets/image-20200714095843747.png)

![image-20200714095833181](201-300.assets/image-20200714095833181.png)



```java
public boolean isStrobogrammatic(String num) {
    HashMap<Integer, Integer> map = new HashMap<>();
    map.put(6,9);
    map.put(9,6);
    map.put(8,8);
    map.put(1,1);
    map.put(0,0);

    StringBuilder sb = new StringBuilder();
    for(int i = 0; i < num.length(); i++)
    {
        if(map.containsKey(num.charAt(i) - '0'))
            sb.append(map.get(num.charAt(i)- '0'));
        else
            return false;
    }

    return sb.reverse().toString().equals(num);
}
```





# 247 Strobogrammatic Number II 递归的应用

![image-20200714135727750](201-300.assets/image-20200714135727750.png)





```java
## 代码实现 
class Solution{
    public List<String> findStrobogrammatic(int n) {
        return helper(n,n);
    }
    // n表示，当前循环中，求得字符串长度； m表示题目中要求的字符串长度
    public List<String> helper(int n, int m){
        // 第一步：判断输入或者状态是否合法
        if(n<0 || m<0 || n>m){
            throw  new IllegalArgumentException("invalid input");
        }
        // 第二步：判断递归是否应当结束
        if (n==0)
            return new ArrayList<>(Arrays.asList(""));
        if (n==1)
            return new ArrayList<>(Arrays.asList("0","1","8"));

        // 第三步：缩小问题规模
        List<String> list = helper(n-2, m);

        // 第四步：整合结果
        List<String> res = new ArrayList<>();
        for (String s : list){
            if (n!=m)
                // n=m时，表示最外层处理。
                // 例如：原始需求n=m=2, '00'不合法
                // 若原始需求n=m=4, 内层循环n=2,m=4,'00';最外层循环，n=m=4时，'1001'
                res.add("0"+s+"0");
            res.add("1"+s+"1");
            res.add("6"+s+"9");
            res.add("8"+s+"8");
            res.add("9"+s+"6");
        }
        return res;
    }
}

作者：tang-yuan-27
链接：https://leetcode-cn.com/problems/strobogrammatic-number-ii/solution/zhong-xin-dui-cheng-shu-ii-247-by-tang-yuan-27/
```





# 248 Strobogrammatic Number III  未完成

![image-20200714143116626](201-300.assets/image-20200714143116626.png)



```c++
class Solution {
public:
    char dl[5] = {'0','1','6','8','9'};
    char dr[5] = {'0','1','9','8','6'};
    
    bool compare(string & a,string & b){
        if(a.size() != b.size()){return a.size() > b.size();}
        return a >= b;
    }
    
    bool checkValid(string & num,string & low, string & high){
        return compare(num,low)&&compare(high,num);
    }
    
    int strobogrammaticInRange(string low, string high) {
        int res = 0;
        queue<string> qu;
        
        /*intial*/
        qu.push("");
        qu.push("0");
        qu.push("1");
        qu.push("8");
        
        /*BFS*/
        while(!qu.empty()){
            string curr = qu.front();
            qu.pop();
            
            if(curr.size() >= low.size() && curr.size() <= high.size()){
                /*skip the num which start with zero*/
                if(!(curr[0] == '0' && curr.size() > 1)){
                    if(checkValid(curr,low,high)){
                        res++;
                    }
                }
            }
            
            if(curr.size() > high.size()){ continue;}
            
            for(int i = 0 ; i < 5; ++i){
                string next = dl[i] + curr + dr[i];
                if(next.size() <= high.size()){
                    qu.push(next);
                }
            }
        }
        
        return res;
    }
};

作者：mike-meng
链接：https://leetcode-cn.com/problems/strobogrammatic-number-iii/solution/fei-chang-jian-dan-qing-xi-de-bfs-by-mike-meng/
```





# 249 Group Shifted Strings

![image-20200714144822874](201-300.assets/image-20200714144822874.png)

![image-20200714150856997](201-300.assets/image-20200714150856997.png)

```java
public List<List<String>> groupStrings(String[] strings) {
    List<List<String>> res = new ArrayList<>();
    boolean[] isAdded   = new boolean[strings.length];
    for(int i = 0; i < strings.length; i++)
    {
        List<String> path = new ArrayList<>();
        if(isAdded[i])  continue;
        else            path.add(strings[i]);

        for(int j = i+1; j < strings.length; j++)
        {
            if(!isAdded[j] && isShifted(strings[i], strings[j]))
            {
                path.add(strings[j]);
                isAdded[j] = true;
            }

        }
        
        res.add(path);
    }

    return res;
}
//helper function
private boolean isShifted(String s, String t)
{
    if(s.length() != t.length())        return false;
    if(s.length() == 1)                 return true;

    int gap = 0;
    //z a 
    if(t.charAt(0) - s.charAt(0) < 0)
        gap = 26 + t.charAt(0) - s.charAt(0);
    else
        gap = t.charAt(0) - s.charAt(0);
    for(int i = 0; i < s.length(); i++)
    {
        int curgap =  0;
        if(t.charAt(i) - s.charAt(i) < 0)
            curgap = 26 + t.charAt(i) - s.charAt(i);
        else
            curgap = t.charAt(i) - s.charAt(i);

        if(curgap != gap)       return false;
    }
    return true;
}
```



# 250 Count Univalue Subtrees 递归的典型应用

![image-20200714152305148](201-300.assets/image-20200714152305148.png)

<img src="201-300.assets/image-20200927150524804.png" alt="image-20200927150524804" style="zoom:50%;" />

```java
int res = 0;
public int countUnivalSubtrees(TreeNode root) {
  dfs(root);

  return res;
}

//to justify the given root is a univalue subtree;
private boolean dfs(TreeNode root){
  boolean status = false;
  if(root == null)        return !status;

  boolean isOkLeft  = dfs(root.left);
  boolean isOkRight = dfs(root.right);

  if(isOkLeft && isOkRight){
    boolean statusL = (root.left != null && root.val == root.left.val) || (root.left == null);
    boolean statusR = (root.right != null && root.val == root.right.val) || (root.right == null);
    status = statusL && statusR;
    if(status)		res += 1;
  }

  return status && isOkLeft && isOkRight;
}
```





# leecode 251-300



# 251 Flatten 2D Vector

```java
class Vector2D {
    Deque<Integer> queue;
    public Vector2D(int[][] v) {
        queue = new ArrayDeque<Integer>();
        for(int i= 0; i <v.length; i++)
            for(int j = 0; j < v[i].length; j++)
                queue.addLast(v[i][j]);
    }
    
    public int next() {
        return queue.removeFirst();
    }
    
    public boolean hasNext() {
        return queue.size() >= 1;
    }
}
```





# 252 Meeting Rooms 数组的排列

![image-20200714180429906](201-300.assets/image-20200714180429906.png)

```java
public boolean canAttendMeetings(int[][] intervals) {
    List<int[]> list = Arrays.asList(intervals);
    list.sort((o1, o2) -> o1[0] - o2[0]);
    for(int i = 0; i < list.size()-1; i++)
        if(list.get(i)[1] > list.get(i+1)[0])
            return false;
    return true;
}
```



# 253 Meeting Rooms II 堆排序

```java
/*
	一个显而易见的思路是，每当有新会议时，就遍历所有房间，查看是否有空闲房间。
	
	把第一个数组的结束时间加入优先队列中
		-如果下一个的开始时间早于优先队列的最早结束时间，那就加一个房间
		-如果下一个的开始时间晚于头元素的最早结束时间，那就不用加了，直接把他替换出去
		
    Amazing!!!!
*/
class Solution {
    public int minMeetingRooms(int[][] intervals) {

    // Check for the base case. If there are no intervals, return 0
    if (intervals.length == 0) 
      return 0;

    // Min heap
    PriorityQueue<Integer> allocator = new PriorityQueue<Integer>(intervals.length, (a,b) -> a-b);

    // Sort the intervals by start time
    Arrays.sort(intervals,(a,b) -> a[0]- b[0]);

    // Add the first meeting
    allocator.add(intervals[0][1]);

    // Iterate over remaining intervals
    for (int i = 1; i < intervals.length; i++) {
      // If the room due to free up the earliest is free, assign that room to this meeting.
      if (intervals[i][0] >= allocator.peek()) 
        allocator.poll();
      

      // If a new room is to be assigned, then also we add to the heap,
      // If an old room is allocated, then also we have to add to the heap with updated end time.
      allocator.add(intervals[i][1]);
    }

    // The size of the heap tells us the minimum rooms required for all the meetings.
    return allocator.size();
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/meeting-rooms-ii/solution/hui-yi-shi-ii-by-leetcode/
```





# 255 Verify Preorder Sequence in Binary Serach Tree 单调栈



```java
/*
	暴力法
*/

public boolean verifyPreorder(int[] preorder) {
    // 遍历每个元素，右侧发现比这个元素大之后，后面必须都要比这个元素大
    int len = preorder.length;
    for (int i = 0; i < len; i++) {
        boolean isBeginBigger = false;
        for (int j = i+1; j < len; j++) {
            if (isBeginBigger && preorder[j] < preorder[i]) {
                return false;
            }
            if (preorder[j] > preorder[i]) {
                isBeginBigger = true;
            }
        }
    }

    return true;
}

作者：yuruiyin
链接：https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/solution/java-liang-chong-jie-fa-by-npe_tle/
```



```java
 // 用单调栈的方式，递减栈，当碰到一个数比栈顶元素大的时候，说明从左子树到了右子树。
 // 此时要删掉左子树的所有节点，并且保留子树的根为最小值，此时遍历的所有右子树的节点都必须大于这个根，否则非法
    public boolean verifyPreorder(int[] preorder) {
        int len = preorder.length;
        int[] stack = new int[len];
        int top = -1;
        int min = Integer.MIN_VALUE;

        for (int value : preorder) {
            if (value < min) return false;
            
            while (top > -1 && value > stack[top]) {
                min = stack[top];
                top--;
            }

            stack[++top] = value;
        }

        return true;
    }

作者：yuruiyin
链接：https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree/solution/java-liang-chong-jie-fa-by-npe_tle/
```





# 257 Binayr Tree paths





![image-20201224213512397](201-300.assets/image-20201224213512397.png)

```java
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> binaryTreePaths(TreeNode root) {
        if(root == null)
            return res;
        dfs(root, new StringBuilder());
        return res;
    }


    public void dfs(TreeNode root, StringBuilder path){
        if(root == null)    return;

        if(root.left == null && root.right == null){
            path.append(root.val);
            res.add(path.toString());
            return;
        }

        path.append(root.val).append("->");

      	//这里最好new 个新的
        dfs(root.left, new StringBuilder(path));
        dfs(root.right, new StringBuilder(path));
    }
}

```











# 258 Add Digits

![image-20200714193930606](201-300.assets/image-20200714193930606.png)

```java
public int addDigits(int num) {
    while((num+"").length() != 1)
    {
        int sum = 0;
        char[] chars = (num + "").toCharArray();
        for(char ch : chars)
            sum += ch-'0';
        num = sum;
    }
    return num;
}
```





# 259 3Sum Smaller  双指针解法



![image-20200714195256503](201-300.assets/image-20200714195256503.png)

```java
/*
	暴力解法， O(n3)
*/
public int threeSumSmaller(int[] nums, int target) {
    Arrays.sort(nums);

    int count = 0;
    for(int i = 0; i < nums.length-2; i++)
        for(int j = i+1; j < nums.length-1;j++)
            for(int k = j+1; k < nums.length; k++)
                if(nums[i] + nums[j] + nums[k] < target)
                    count++;
    return count;

}
```



```java
/*
	双指针的解法
*/
public int threeSumSmaller(int[] nums, int target) {
    int count = 0;
    if(nums.length < 3)     return count;
    Arrays.sort(nums);
    int left = 0; int right = 0;

    for(int i = 0; i < nums.length-2; i++)
    {
        left = i+1;
        right = nums.length - 1;

        while(left < right)
        {
            int total = nums[i] + nums[left] + nums[right];

            if(total < target)
            {
                int slots = right - left;
                count += slots;
                left++;
            }
            else
                right--;
        }
    }
    return count;
}
```







# 260 Single Number III 

![image-20200715093531624](201-300.assets/image-20200715093531624.png)

```java
public int[] singleNumber(int[] nums) {
    int[] res = new int[2];
    int index = 0;
    HashMap<Integer, Integer> map = new HashMap<>();
    for(int i = 0;i < nums.length; i++)
        map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
    for(Integer i : map.keySet())
        if(map.get(i) == 1)
            res[index++] = i;

    return res;
}
```



```java
/*
	采用O(1)的空间复杂度
	其中思路参考136题，找到落单的数字
	算法思路：
		- 将原数组分成两组，只出现过一次的两个数字分别放到两个组里面
		- 因为要找的两个数组不同，至少有一位二进制不同，将这一位作为分类标准
		- 最后异或的结果实质上就是两个数字的异或，那么出现了1就证明是不同位
		- 构造一个数，恰好就是不同的那一位写成1，其他位写成0
		- 之后分组异或
*/
public int[] singleNumber(int[] nums) {
    int diff = 0;
    for (int n : nums) {
        diff ^= n;
    }
    diff = Integer.highestOneBit(diff);
    int[] result = { 0, 0 };
    for (int n : nums) {
        //当前位是 0 的组, 然后组内异或
        if ((diff & n) == 0) {
            result[0] ^= n;
        //当前位是 1 的组
        } else {
            result[1] ^= n;
        }
    }
    return result;
}

作者：windliang
链接：https://leetcode-cn.com/problems/single-number-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-8/
```



# 261 Graphic Valid Tree





<img src="201-300.assets/image-20201225202314542.png" alt="image-20201225202314542" style="zoom:50%;" />

```java
    public boolean validTree(int n, int[][] edges) {
        if(n != edges.length + 1)      return false;

        HashSet<Integer> visited = new HashSet<>();
        List<List<Integer>> adj = new ArrayList<>();
        for(int i = 0; i < n; i++)
            adj.add(new ArrayList<>());
        
        for(int[] edge : edges){
            adj.get(edge[0]).add(edge[1]);
            adj.get(edge[1]).add(edge[0]);
        }

        Deque<Integer> queue = new ArrayDeque<>();
        queue.addLast(0);
        while(!queue.isEmpty()){
            int cur = queue.pollFirst();
            visited.add(cur);
            for(int num : adj.get(cur)){
                if(!visited.contains(num))
                    queue.addLast(num);
            }
        }

        return visited.size() == n;
    }
```





<img src="201-300.assets/image-20201225203217125.png" alt="image-20201225203217125" style="zoom:50%;" />

```cpp
public class Solution {
    public boolean validTree(int n, int[][] edges) {
        if(n != edges.length + 1)      return false;
            
        WeighedUnionFind wuf = new WeighedUnionFind(n);
        
        for(int[] edge : edges){
            wuf.union(edge[0], edge[1]);
        }
        
        return wuf.count() == 1;
    }
}

class WeighedUnionFind{
    private int[] id;
    private int[] sz;
    private int count;
    
    public WeighedUnionFind(int N){
        id = new int[N];
        sz = new int[N];
        count = N;
        
        for(int i = 0; i < N; i++){
            id[i] = i;
            sz[i] = 1;
        }
    }
    
    public int find(int p){
        while(p != id[p]){
            id[p] = id[id[p]];
            p = id[p];
        }
        
        return p;
    }
    
    public void union(int p, int q){
        int pRoot = find(p);
        int qRoot = find(q);
        
        if(pRoot == qRoot)  return;
        
        if(sz[pRoot] > sz[qRoot]){
            sz[pRoot] += sz[qRoot];
            id[qRoot] = pRoot;
        }else{
            sz[qRoot] += sz[pRoot];
            id[pRoot] = qRoot;
        }
        
        count--;
    }
    
    public boolean connected(int p, int q){return find(p) == find(q);}
    
    public int count(){return count;}
    
}
```





```cpp
class Solution {
public:
    bool validTree(int n, vector<vector<int>>& edges) {
        /**1. 节点数==变数+1*/
        if(edges.size() +1 != n) return false;
        /**2. 连通性*/
        vector<vector<int>> Graph(n,vector<int>());
        //构造邻接表
        for(auto edge: edges){
            Graph[edge[0]].push_back(edge[1]);
            Graph[edge[1]].push_back(edge[0]);
        }
        set<int> visited;//访问过的节点放在visited数组中
        //广度优先,看是否连通
        queue<int> q;
        q.push(0);
        visited.insert(0);
        while(!q.empty()){
            int sz = q.size();
            while(sz){
                int v = q.front();
                q.pop();
                for(auto v_a : Graph[v]){
                    if(visited.find(v_a) != visited.end())//访问过了
                        continue;
                    visited.insert(v_a);
                    q.push(v_a);
                }
                sz--;
            }
        }
        return visited.size() == n;  //访问过的节点数<n,则不连通
    }
};

作者：shubulan
链接：https://leetcode-cn.com/problems/graph-valid-tree/solution/shen-du-you-xian-yan-du-you-xian-bing-cha-ji-de-zo/
```







# 266 Palindrome Permutation

![image-20200715095858821](201-300.assets/image-20200715095858821.png)

```java
public boolean canPermutePalindrome(String s) {
    int index = 0;
    HashMap<Character, Integer> map = new HashMap<>();
    while(index < s.length())
    {
        map.put(s.charAt(index), map.getOrDefault(s.charAt(index), 0) + 1); 
        index++;
    }

    int count = 0;
    for(char ch : map.keySet())
    {
        if(map.get(ch) % 2 != 0)
            count++;
        if(count > 1)       return false;
    }
    return true;
}
```





# 263 Ugly Number 



```java
public boolean isUgly(int num) {
    if(num < 1)     return false;
    if(num == 1)    return true;

    while(num > 1)
    {
        if(num % 2 == 0)    num /= 2;
        else if(num % 3 == 0)    num /= 3;
        else if(num % 5 == 0)    num /= 5;
        else    
            return false;
    }

    return true;
}
```



# 268 Missing Number



![image-20200715100344463](201-300.assets/image-20200715100344463.png)

```java
public int missingNumber(int[] nums) {
    HashSet<Integer> set = new HashSet<>();
    for(int num : nums)
        set.add(num);

    for(int i=0;;i++)
        if(!set.contains(i))
            return i;

}
```



# 269 Alien Dictionary 拓扑排序



```java
/*
	将字符串的优先级构建为图，然后进行拓扑排序。
	如果图中无环，则将拓扑排序输出，否则顺序是非法的。
*/
class Solution {
    public String alienOrder(String[] words) {
        //1.构建图
        Map<Character, Set<Character>> map = new HashMap<>();
        for (int i = 0; i < words.length - 1; i++) {
            for (int j = 0; j < words[i].length() && j < words[i + 1].length(); j++) {
                //如果字符相同，比较下一个
                if (words[i].charAt(j) == words[i + 1].charAt(j)) continue;
                //保存第一个不同的字符顺序
                Set<Character> set = map.getOrDefault(words[i].charAt(j), new HashSet<>());
                set.add(words[i + 1].charAt(j));
                map.put(words[i].charAt(j), set);
                break;
            }
        }

        //2.拓扑排序
        //创建保存入度的数组
        int[] degrees = new int[26];
        Arrays.fill(degrees, -1);
        //注意，不是26字母都在words中出现，所以出度分为两种情况：没有出现的字母出度为-1，出现了的字母的出度为非负数
        for (String str : words) 
            //将出现过的字符的出度设定为0
            for (char c : str.toCharArray())
                degrees[c - 'a'] = 0;
        
        for (char key : map.keySet()) 
            for (char val : map.get(key)) 
                degrees[val - 'a']++;
            
        
        //创建StringBuilder保存拓扑排序
        StringBuilder sb = new StringBuilder();
        //创建一个Queue保存入度为0的节点
        Queue<Character> list = new LinkedList<>();

        int count = 0;//计算图中节点数
        for (int i = 0; i < 26; i++) {
            if (degrees[i] != -1) count++;
            if (degrees[i] == 0) {
                list.add((char) ('a' + i));
            }
        }

        while (!list.isEmpty()) {
            Character cur = list.poll();
            sb.append(cur);
            //将邻接点出度-1
            if (map.containsKey(cur)) {
                Set<Character> set = map.get(cur);
                for (Character c : set) {
                    degrees[c - 'a']--;
                    if (degrees[c - 'a'] == 0) list.add(c);
                }
            }
        }

        //判断是否有环
        if (sb.length() != count) return "";
        else return sb.toString();

    }
}

作者：mmmmmJCY
链接：https://leetcode-cn.com/problems/alien-dictionary/solution/java-tuo-bu-pai-xu-by-zxy0917/
```





# 270 Closest Binary Search Tree Value



```java
//二分查找
class Solution {
  public int closestValue(TreeNode root, double target) {
    int val, closest = root.val;
    while (root != null) {
      val = root.val;
      closest = Math.abs(val - target) < Math.abs(closest - target) ? val : closest;
      root =  target < root.val ? root.left : root.right;
    }
    return closest;
  }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/closest-binary-search-tree-value/solution/zui-jie-jin-de-er-cha-sou-suo-shu-zhi-by-leetcode/
```



```JAVA
/*
	暴力法，写的行云流水
*/
public void inorder(TreeNode root, List<Integer> nums) {
    if (root == null) return;
    inorder(root.left, nums);
    nums.add(root.val);a
    inorder(root.right, nums);
}

public int closestValue(TreeNode root, double target) {
    List<Integer> nums = new ArrayList();
    inorder(root, nums);
    return Collections.min(nums, new Comparator<Integer>() {
        @Override
        public int compare(Integer o1, Integer o2) {
            return Math.abs(o1 - target) < Math.abs(o2 - target) ? -1 : 1;
        }
    });
}
```



# 272 Closet Binary Search Tree Value II



```java
/*
		采用优先队列，比较牛逼

 */
class Solution {
    double t;
    int n;
    Queue<Integer> queue;
    public List<Integer> closestKValues(TreeNode root, double target, int k) {
        // 用一个优先队列来保存值，然后遍历树，找到
        t=target;
        n=k;
        queue = new PriorityQueue<>((o1, o2) -> Double.compare(Math.abs(o2 - t), Math.abs(o1 - t)));
        inOrder(root);
        return new ArrayList<>(queue);
    }

    private void inOrder(TreeNode root) {
        if (root==null) return;
        inOrder(root.left);
        int val=root.val;
        if (queue.size()<n){
            queue.add(val);
        }else {
            double t1=Math.abs(val-t);
            Integer peek = queue.peek();
            double t2=Math.abs(peek-t);
            if (t2>t1){
                queue.poll();
                queue.add(val);
            }
        }
        inOrder(root.right);
    }
}


作者：lifengcai_fans
链接：https://leetcode-cn.com/problems/closest-binary-search-tree-value-ii/solution/qing-xi-jian-dan-by-xiaoweixiang/
```



# 275 H-index || 实际上我还不清楚这是什么玩意



```java
public int hIndex(int[] citations) {
    int H_index = 0;
    int n = 1;
    for(int i = citations.length - 1; i >= 0; i--)
        if(n > citations[i])
            break;
    else
        n++;

    return n-1;
}
```



# 278 First Bad Version

![image-20200716134552826](201-300.assets/image-20200716134552826.png)

```java
/*
	典型二分
*/
public int firstBadVersion(int n) {
    long left = 1;
    long right = n;

    while(left < right)
    {
        long mid = (left + right) /2;

        if(isBadVersion((int)mid))
            right = mid;
        else
            left = mid + 1;
    }
    return (int)left;
}
```





# 280 Wiggle Sort





# 282 Expression Add Operations 未解决









# 283 Move Zeroes  快排



```java
/*
	每次遍历，看看有几个零，非零的赋值
	最后把末尾附上0
*/
public void moveZeroes(int[] nums) {
    int j = 0;

    for(int i = 0; i < nums.length; i++)
        if(nums[i] != 0)
            nums[j++] = nums[i];

    for(int i = j; i < nums.length; i++)
        nums[i] = 0;
}
```



```java
// 快速排序的又一另类应用
class Solution {
	public void moveZeroes(int[] nums) {
		if(nums==null) {
			return;
		}
		//两个指针i和j
		int j = 0;
		for(int i=0;i<nums.length;i++) {
			//当前元素!=0，就把其交换到左边，等于0的交换到右边
			if(nums[i]!=0) {
				int tmp = nums[i];
				nums[i] = nums[j];
				nums[j++] = tmp;
			}
		}
	}
}	

作者：wang_ni_ma
链接：https://leetcode-cn.com/problems/move-zeroes/solution/dong-hua-yan-shi-283yi-dong-ling-by-wang_ni_ma/
```



# 284 Peeking Iterator



![image-20200716082839236](201-300.assets/image-20200716082839236.png)

```java
// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html

class PeekingIterator implements Iterator<Integer> {
    private Deque<Integer> queue;

	public PeekingIterator(Iterator<Integer> iterator) {
	    // initialize any member here.
	    queue = new ArrayDeque<>();
        while(iterator.hasNext())
            queue.addLast(iterator.next());
	}
	
    // Returns the next element in the iteration without advancing the iterator.
	public Integer peek() {
        return queue.peek();
	}
	
	// hasNext() and next() should behave the same as in the Iterator interface.
	// Override them if needed.
	@Override
	public Integer next() {
	    return queue.poll();
	}
	
	@Override
	public boolean hasNext() {
	    return queue.size() > 0;
	}
}
```



# 285 Inorder Successor in BST



![image-20200716081552151](201-300.assets/image-20200716081552151.png)

```java
/*
	笨办法
*/
public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
    List<Integer> list = new ArrayList<>();
    inOrder(root, list);
    for(int i = 0; i < list.size()-1; i++)
        if(list.get(i) == p.val)
            return new TreeNode(list.get(i+1));
    return null;
}

private void inOrder(TreeNode root, List<Integer> list)
{
    if(root == null)        return;
    inOrder(root.left, list);
    list.add(root.val);
    inOrder(root.right, list);
}
```



<img src="201-300.assets/image-20200929090556561.png" alt="image-20200929090556561" style="zoom:50%;" />

```java
//套用框架， 中序遍历
//Author by Wenchao Guo
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        Deque<TreeNode> stack = new ArrayDeque<>();
        
        TreeNode pre = null;
        while(root != null || !stack.isEmpty()){
            while(root != null){
                stack.push(root);
                root = root.left;
            }

            TreeNode cur = stack.pop();
            if(pre != null && pre.val <= p.val && cur.val > p.val)
                return cur;
            else
                pre = cur;
            root = cur.right;

        }

        return null;
    }
```



# 286 Walls and Gates

<img src="201-300.assets/image-20201226181718625.png" alt="image-20201226181718625" style="zoom:50%;" />



```java

/*
		记得利用好 单点BFS 最短的特性
*/
class Solution {
    int[][] dir = {{-1, 0},{1, 0},{0, 1},{0, -1}};
    int row;
    int column;
    public void wallsAndGates(int[][] rooms) {
        row    = rooms.length;
        column = row == 0 ? 0 : rooms[0].length;

        if(column == 0)     return;
        Deque<int[]> queue = new ArrayDeque<>();
        HashSet<int[]> visited = new HashSet<>();
        
        for(int i = 0; i < row; i++)
            for(int j = 0; j < column; j++) 
                if(rooms[i][j] == 0){
                    queue.addLast(new int[]{i, j});
                    visited.add(new int[]{i, j});
                }
        int record = 1;
        while(!queue.isEmpty()){
            int size = queue.size();
            for(int i = 0; i < size; i++){
                int[] cur = queue.pollFirst();

                for(int k = 0 ; k < 4; k++){
                    int newX = cur[0] + dir[k][0];
                    int newY = cur[1] + dir[k][1];

                    if(!isInRange(newX, newY) 
                        || rooms[newX][newY] == -1 || rooms[newX][newY] != Integer.MAX_VALUE ||
                        visited.contains(new int[]{newX, newY}))
                        continue;
                    
                    rooms[newX][newY] = record;
                    queue.add(new int[]{newX, newY});
                    visited.add(new int[]{newX, newY});
                }
            }

            record++;
        }
    }

    private boolean isInRange(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < column;
    }
}
```













# 287 Find the Duplicate Number 另类的二分法运用 + 牛逼双指针





```java
/*
	典型的时间换空间的想法
	
	采用二分法， 思路是
	每次拿到中间数 mid 
	然后在所有元素遍历一遍，看看数量少于mid的元素个数
	如果多，说明在区间[1,mid]一定有重复的
	反之就在另一半
	
	属实是二分法的另类应用
*/
public int findDuplicate(int[] nums) {
    int len = nums.length;
    int left = 1;	//这里left == 1 是因为数组元素从1-n的限制
    int right = len - 1;
    while(left < right)
    {
        int mid = (left + right) >>> 1;

        int cnt = 0;
        for(int num : nums)
            if(num <= mid)
                cnt++; 
        if(cnt > mid)
            right = mid;
        else
            left = mid + 1;
    }
    return left;
}
```



```java
//对比链表找环的题
public int findDuplicate(int[] nums) {
    int slow = nums[0], fast = nums[nums[0]];

    while(slow != fast)
    {
        slow = nums[slow];
        fast = nums[nums[fast]];
    }

    slow = 0;

    while(slow != fast)
    {
        slow = nums[slow];
        fast = nums[fast];
    }
    return slow;
}
```



# 289 Game of Life

![image-20200715194554024](201-300.assets/image-20200715194554024.png)

```java
/*
	不太符合题目的follow up 属于 non in-place
*/
public void gameOfLife(int[][] board) {
    if(board.length == 0 || board[0].length == 0)       return;
    int[][] newBoard = new int[board.length][board[0].length];
    for(int i = 0; i < board.length; i++)
        for(int j = 0; j < board[0].length; j++)
            newBoard[i][j] = board[i][j];

    for(int i = 0; i < board.length; i++)
        for(int j = 0; j < board[0].length; j++)
        {
            int ln = getNumber(board, i, j);
            if      (board[i][j] == 1 && ln < 2)              newBoard[i][j] = 0;
            else if (board[i][j] == 1 && ln >= 2 && ln <= 3)  newBoard[i][j] = 1;
            else if (board[i][j] == 1 && ln > 3)              newBoard[i][j] = 0;
            else if (board[i][j] == 0 && ln == 3)             newBoard[i][j] = 1;

        }

    for(int i = 0; i < board.length; i++)
        for(int j = 0; j < board[0].length; j++)
            board[i][j] = newBoard[i][j];
}

private int getNumber(int[][] board, int i, int j)
{
    int count = 0;
    if(i+1 < board.length)                             count += board[i+1][j] == 1? 1 : 0;
    if(i-1 >= 0)                                       count += board[i-1][j] == 1? 1 : 0;
    if(j + 1 < board[0].length)                        count += board[i][j+1] == 1? 1 : 0;
    if(j - 1>= 0)                                      count += board[i][j-1] == 1? 1 : 0;
    if(i+1 < board.length && j + 1 < board[0].length)  count += board[i+1][j+1] == 1? 1 : 0;
    if(i+1 < board.length && j - 1>= 0 )               count += board[i+1][j-1] == 1? 1 : 0;
    if(i-1 >= 0 && j + 1 < board[0].length)            count += board[i-1][j+1] == 1? 1 : 0;
    if(i-1 >= 0 && j - 1>= 0)                          count += board[i-1][j-1] == 1? 1 : 0;
    return count;
}

private void copyBoard(int[][] oldBoard, int[][] newBoard)
{
    for(int i = 0; i < oldBoard.length; i++)
        for(int j = 0; j < oldBoard[0].length; j++)
            newBoard[i][j] = oldBoard[i][j];
}
```



```java
/*
	in-place 的算法
	用10作为一个测量周围有没有1的方案，实现拿到周围到底有几个1
	相当于 立了一个flag = 10
	并且，相较于上面一个方法，找到该cell中的1的个数
	我们这种方法是找1，然后从1这个cell扩散周围8个格子
*/
public void gameOfLife(int[][] board)
{
    if(board.length == 0 || board[0].length==0) return;
    int m = board.length, n = board[0].length;

    int[] neighbor = {0, 1, -1};
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            if(board[i][j] % 10 == 1)
                for(int k = 0; k < 3; k++)
                    for(int l = 0; l < 3; l++)
                    {
                        int left = i + neighbor[k];
                        int right = j + neighbor[l];
                        if(neighbor[k] == 0 && neighbor[l] == 0)
                            continue;
                        if(left >= 0 && right >= 0 && left < m && right < n)
                            board[left][right] += 10;
                    }
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            if(board[i][j] == 21 || board[i][j] == 31)
                board[i][j] = 1;
            else if(board[i][j] == 30)
                board[i][j] = 1;
            else
                board[i][j] = 0;


}
```



# 290 Word Pattern



![image-20200715165041864](201-300.assets/image-20200715165041864.png)

```java
public boolean wordPattern(String pattern, String str) {
    String[] words = str.split(" ");
    HashMap<Character, String> map = new HashMap<>();
    if(pattern.length() != words.length)        return false;
    
    for(int i = 0; i < pattern.length(); i++)
    {
        if(!map.containsKey(pattern.charAt(i)))
            if(map.values().contains(words[i]))
                return false;
            else
                map.put(pattern.charAt(i), words[i]);

        if(!(map.get(pattern.charAt(i)).equals(words[i])))
            return false;  
    }
    return true;
}
```



# 291 Word Pattern II





# 292 Nim Game

```java
/*
	通过50/60个案例， 卡在1348820612这个数字
*/
private HashMap<Integer, Boolean> map = new HashMap<>();

public boolean canWinNim(int n) {
    if(n <= 3)      return true;
    if(map.containsKey(n))      return map.get(n);
    map.put(1, true);
    map.put(2, true);
    map.put(3, true);

    boolean a = map.containsKey(n-1) ? !map.get(n-1) : !canWinNim(n-1);
    boolean b = map.containsKey(n-2) ? !map.get(n-2) : !canWinNim(n-2);
    boolean c = map.containsKey(n-3) ? !map.get(n-3) : !canWinNim(n-3);

    map.put(n, a || b || c);
    return map.get(n);
}
```



```java
//无法通过 通过50/60个案例， 卡在1348820612这个数字
public boolean canWinNim(int n) {
    if(n <= 3)      return true;
    boolean[] canWin = new boolean[n+1];
    canWin[1] = true;
    canWin[2] = true;
    canWin[3] = true;

    for(int i = 4; i <= n; i++)
        canWin[i] = !canWin[i-1] || !canWin[i-2] || !canWin[i-3];
    return canWin[n];
}
```



```java
//52/60个案例， 卡在730530679这个数字
public boolean canWinNim(int n) {
    if(n <= 3)      return true;
    boolean canWin = false;
    boolean a = true;
    boolean b = true;
    boolean c = true;

    for(int i = 4; i <= n; i++)
    {
        canWin = !a || !b || !c;
        a = b;
        b = c;
        c = canWin;
    }
    return canWin;
}
```

![image-20200715154632332](201-300.assets/image-20200715154632332.png)

```java
   public boolean canWinNim(int n) {
        if(n <= 3)      return true;
        return !(n % 4 == 0);
    }
```



# 293 Flip Game 1

![image-20200715180441510](201-300.assets/image-20200715180441510.png)

```java
public List<String> generatePossibleNextMoves(String s) {
    List<String> res = new ArrayList<>();
    int index = 0;

    while(index < s.length())
    {
        char[] chars = s.toCharArray();
        while((index + 1 < chars.length) && (chars[index] != '+' || chars[index+1] != '+'))
            index++;
        if(index >= s.length() -1)      break;
        chars[index] = '-'; 
        chars[index + 1] = '-';
        res.add(String.valueOf(chars));
        index++;
    }
    return res;
}
```





# 298 Binary Tree longest Consecutive Sequence



```java
/*
	方法一：自顶向下DFS
	注意，之所以在参数中引入多一个parent的argument
	主要是为了方便判断连续性
*/
private int maxLength = 0;
public int longestConsecutive(TreeNode root)
{
    dfs(root, null, 0);
    return maxLength;
}

private void dfs(TreeNode p, TreeNode parent, int length)
{
    if(p == null)		return;
    length = (parent != null && p.val == parent.val + 1) ? length + 1: 1;
    maxLength = Math.max(maxLength, length);
    dfs(p.left, p, length);
    dfs(p.right, p, length);
}
```



```java
/*
	自底向上，类似后序遍历
*/

private int maxLength = 0;
public int longestConsecutive(TreeNode root)
{
    dfs(root);
    return maxLength;
}

private int dfs(TreeNode p)
{
    if(p == null)	return 0;
    int L = dfs(p.left) + 1;
    int R = dfs(p.right) + 1;
    if(p.left != null && p.val + 1 != p.left.val)
        L = 1;
    if(p.right != null && p.val + 1 != p.right.val)
        R = 1;
    
    int length = Math.max(L, R);
    maxLength = Math.max(maxLength, length);
    return length;
}
```





<img src="201-300.assets/image-20200928170408719.png" alt="image-20200928170408719" style="zoom:50%;" />

```java
  //Author: WenchaoGuo
  int res = 0;
  public int longestConsecutive(TreeNode root) {
    dfs(root, 0);
    return res;
  }

  private void dfs(TreeNode root, int sum){
    if(root == null)      return;
    res = Math.max(res, sum + 1);

    if(root.left != null && root.val + 1 == root.left.val)
      dfs(root.left, sum + 1);
    else
      dfs(root.left, 0);

    if(root.right != null && root.val + 1 == root.right.val)
      dfs(root.right, sum + 1);
    else    
      dfs(root.right, 0);

    return;
  }

```





# 299 Bulls And Cows

![image-20200715141848235](201-300.assets/image-20200715141848235.png)

```java
public String getHint(String secret, String guess) {
    int A = 0, B = 0;
    HashMap<Character, Integer> mapA = new HashMap<>();
    HashMap<Character, Integer> mapB = new HashMap<>();

    for(int i = 0; i < secret.length(); i++)
        if(secret.charAt(i) == guess.charAt(i))
            A++;
        else
        {
            mapA.put(secret.charAt(i), mapA.getOrDefault(secret.charAt(i),0)+1);
            mapB.put(guess.charAt(i), mapB.getOrDefault(guess.charAt(i),0)+1);
        }
    for(char ch : mapA.keySet())
        if(mapA.get(ch) <= mapB.getOrDefault(ch,0))
            B += mapA.get(ch);
        else    
            B += mapB.getOrDefault(ch,0);

    return A + "A" + B + "B"; 
}
```

