





# 1108 Invalid IP Address

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210513161353830.png" alt="image-20210513161353830" style="zoom:50%;" />

```go

func defangIPaddr(address string) string {
	res := strings.Replace(address, ".", "[.]", -1)
	return res
}

```









# 1123 Lowest Common Ancestor of Deepest Leaves



![image-20210514155829826](1101-1200.assets/image-20210514155829826.png)

```go
/*
	朴素的想法，求出左右的最大深度，如果一致，那就是它了！
	but still duplicated process, needs to improve on that
*/
func lcaDeepestLeaves(root *TreeNode) *TreeNode {
	if root == nil || (root.Left == nil && root.Right == nil){
		return root
	}

	left  := getMaxDepth(root.Left)
	right := getMaxDepth(root.Right)
	
	if left == right{
		return root
	}else{
		if left > right{
			return lcaDeepestLeaves(root.Left)
		}else{
			return lcaDeepestLeaves(root.Right)
		}
	}
}

func getMaxDepth(root *TreeNode) int{
	if root == nil{
		return 0
	}
	
	return 1 + max(getMaxDepth(root.Left), getMaxDepth(root.Right))
}

func max(a int, b int) int{
	if a < b{
		return b
	}

	return a
}
```











# 1162 As far From Land As Possible



<img src="1101-1200.assets/image-20210607214955513.png" alt="image-20210607214955513" style="zoom:50%;" />



<img src="1101-1200.assets/image-20210608084043456.png" alt="image-20210608084043456" style="zoom:50%;" />

```java
    int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int row;
    int col;
    public int maxDistance(int[][] grid) {
        row = grid.length;
        col = grid[0].length;
        int ones = 0;
        int zeros = 0;

        Deque<int[]> queue = new ArrayDeque<>();
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 1) {
                    queue.add(new int[]{i, j});
                    ones++;
                }
            }
        }

        zeros = row * col - ones;
        int maxDistance = 0;

        while(!queue.isEmpty()){
            int size= queue.size();
            for(int i = 0; i < size; i++){
                int[] cur = queue.removeFirst();

                for(int k = 0; k < 4; k++){
                    int newX = cur[0] + dir[k][0];
                    int newY = cur[1] + dir[k][1];

                    if(isInRange(newX, newY)  && grid[newX][newY] == 0){
                        grid[newX][newY] = grid[cur[0]][cur[1]] + 10;
                        zeros--;

                        if(zeros == 0)
                            break ;

                        queue.addLast(new int[]{newX, newY});
                    }
                }

                if(zeros == 0)
                    break;
            }

            if(zeros == 0)
                break;
        }

        for(int i = 0; i < row; i++){
            for(int j =0; j < col; j++){
                if(grid[i][j] > 1)
                    maxDistance = Math.max(maxDistance, grid[i][j] / 10);
            }
        }

        return maxDistance == 0 ? -1 : maxDistance;
    }

    private boolean isInRange(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < col;
    }
```









```java
    public int maxDistance(int[][] grid) {
        int row = grid.length;
        int col = grid[0].length;
        
        List<int[]> list = new ArrayList<>();
        
        for(int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if(grid[i][j] == 1)
                    list.add(new int[]{i, j});
            }
        }
        
        
        int maxDistance = 0;
        for(int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (grid[i][j] == 0) {
                    int distance = Integer.MAX_VALUE;
                    for (int[] arr : list) {
                        distance = Math.min(distance, Math.abs(arr[0] - i) + Math.abs(arr[1] - j));
                    }
                    
                    if(distance != Integer.MAX_VALUE)
                        maxDistance = Math.max(maxDistance, distance);
                }
            }
        }
        
        return maxDistance == 0 ? -1 : maxDistance;
    }
    
```

















