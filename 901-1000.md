

# 901 Online Stock Span

<img src="901-1000.assets/image-20210530150134879.png" alt="image-20210530150134879" style="zoom:50%;" />

```java
    public int[] dp;
    public int[] nums;
    public int index;
    public StockSpanner() {
        dp = new int[110000];
        Arrays.fill(dp, 1);
        nums = new int[110000];
        index = 0;
    }

    public int next(int price) {
        nums[index] = price;

        //get res from dp
        int i = index - 1;
        while(i >= 0){
            if(nums[i] <= nums[index]){
                dp[index] += dp[i];
                i = i - dp[i];
            }else{
                break;
            }
        }

        index++;
        return dp[index - 1];
    }

```







# 905 Sort Array By Parity



<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210511155558206.png" alt="image-20210511155558206" style="zoom:50%;" />

```go
func sortArrayByParity(A []int) []int {
	left := 0
	right := len(A) - 1
	
	for ; left < right; {
		for ; left < right && A[left] % 2 == 0 ; left++{}
		
		if left >= right{
			break
		}
		
		for ; left < right && A[right] % 2 != 0 ; right--{}
		
		if left >= right{
			break
		}
		
		A[left], A[right] = A[right], A[left]
		left++
		right--
	}
	
	return A
}
```



<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210511155239494.png" alt="image-20210511155239494" style="zoom:50%;" />

```java
   public int[] sortArrayByParity(int[] A) {
        int len = A.length;
        int left = 0, right = len - 1;
        while(left < right){
            while(left < len && A[left] % 2 == 0)
                left++;
            
            if(left >= right)
                break;
            
            while(right >= 0 && A[right] % 2 != 0)
                right--;
            
            if(left >= right)
                break;

            int temp = A[left];
            A[left]  = A[right];
            A[right] = temp;

            left++;
            right--;
        }

        return A;
    }
```





# 907 Sum of Subarray Minimum

<img src="901-1000.assets/image-20210805081017407.png" alt="image-20210805081017407" style="zoom:50%;" />

```cpp
/*
		author: guoguo
		
		本质上这道题目， 就是采用单调栈， 拿到 当前位置 i， 往左能扩展到哪里，往右能扩展到哪里
		如果采用 ON2 遍历 比较费时间
		因此 这里采用 单调栈， 找到左边最近的 不小于自己的
												找到右边最近的，不小于自己的
*/
class Solution {
public:
    int sumSubarrayMins(vector<int>& arr) {
        int size = arr.size();
        long long res = 0;
        int mod = 1e9 + 7;

        vector<int> leftMin(size, -1);
        vector<int> rightMin(size, -1);
        stack<int> monoStack;

        for(int i = 0; i < size; i++){
            if(i == 0)
                monoStack.push(i);
            else{
                if(monoStack.empty() || arr[monoStack.top()] <= arr[i])
                    monoStack.push(i);
                else{
                    while(!monoStack.empty() && arr[monoStack.top()] > arr[i]){
                        leftMin[i] = monoStack.top();
                        if(leftMin[monoStack.top()] != -1)
                            leftMin[i] = leftMin[monoStack.top()];
                        monoStack.pop();
                    }

                    monoStack.push(i);
                }
            }
        }

        monoStack = stack<int>();

        for(int i = size - 1; i >= 0; i--){
            if(i == size - 1)
                monoStack.push(i);
            else{
                if(monoStack.empty() || arr[monoStack.top()] < arr[i])
                    monoStack.push(i);
                else{
                    while(!monoStack.empty() && arr[monoStack.top()] >= arr[i]){
                        rightMin[i] = monoStack.top();
                        if(rightMin[monoStack.top()] != -1)
                            rightMin[i] = rightMin[monoStack.top()];
                        monoStack.pop();
                    }


                    monoStack.push(i);
                }
            }
        }

        for(int i = 0; i < size; i++){
            int left;
            if(leftMin[i] == -1)
                left = 1;
            else
                left = i - leftMin[i] + 1;
            int right;

            if(rightMin[i] == -1)
                right = 1;
            else
                right= rightMin[i] - i + 1;

            res += ((long)left * (long)right) * (long)arr[i];
        }

        return res % mod;
    }
};
```





# 909 Snakes and Lakes



<img src="901-1000.assets/image-20210613202722026.png" alt="image-20210613202722026" style="zoom:50%;" />

```java

```







# 918  Maximum Sum Circular Subarray

<img src="901-1000.assets/image-20210729164946561.png" alt="image-20210729164946561" style="zoom:50%;" />

```cpp

class Solution {
public:
    int maxSubarraySumCircular(vector<int>& nums) {
        int size= nums.size();
        int doubleSize = 2 * size;
        int temp = nums[0];

        vector<int> prefixSum(doubleSize, 0);
        for(int i = 0; i < doubleSize; i++){
            int pos = i % size;
            if(i == 0)
                prefixSum[i] = nums[i];
            else
                prefixSum[i] += prefixSum[i - 1] + nums[pos];

            temp = nums[pos] > temp ? nums[pos] : temp;
        }

        int index = doubleSize - 1;
        deque<pair<int, int>> maxStack;
        vector<int> lenMax(size + 1, 0);
        while(index >= 0){
            if(index >= size){
                while(!maxStack.empty() && maxStack.back().first < prefixSum[index])
                    maxStack.pop_back();

                if(maxStack.empty() || maxStack.back().first >= prefixSum[index])
                    maxStack.emplace_back(prefixSum[index], index);

                index--;
            }else{
                if(!maxStack.empty() && maxStack.front().second == index + size)
                    maxStack.pop_front();

                int curMax = maxStack.front().first;
                lenMax[index] = curMax;

                while(!maxStack.empty() && maxStack.back().first < prefixSum[index])
                    maxStack.pop_back();

                maxStack.emplace_back(prefixSum[index], index);

                index--;
            }
        }

        int res = prefixSum[size - 1];
        for(int i = 0; i < size; i++){
            if(res < lenMax[i] - prefixSum[i])
                res = lenMax[i] - prefixSum[i];
        }



        return res > temp ? res : temp;
    }
};
```



# 919 Complete Binary Tree Insert

<img src="901-1000.assets/image-20210930172914877.png" alt="image-20210930172914877" style="zoom:50%;" />

```cpp
/**
	实际上就是计算路径， lgn 的时间复杂度
 */
class CBTInserter {
public:
    TreeNode* r;
    int counter;
    CBTInserter(TreeNode* root) : r(root), counter(0){
        inorder(root);
        counter++;
    }
    
    void inorder(TreeNode* root){
        if(root == nullptr)
            return;
        counter++;
        inorder(root->left);
        inorder(root->right);
    }
    
    int insert(int val) {
        if(r == nullptr){
            r = new TreeNode(val);
            counter++;
            return 0;
        }
        
        vector<char> vec;
        int v = val;
        val = counter;
//        cout << val << endl;
        while(val != 1){
            if(val % 2 == 0){
                vec.push_back('l');
                val /= 2;
            }else{
                val -= 1;
                val /= 2;
                vec.push_back('r');
            }
        }
        
        TreeNode* cur = r;
        reverse(vec.begin(), vec.end());
        
        for(int i = 0;  i < vec.size() - 1; i++){
            if(vec[i] == 'l')
                cur = cur->left;
            else
                cur = cur->right;
        }
        
        if(vec[vec.size() - 1] == 'l')
            cur->left = new TreeNode(v);
        else
            cur->right = new TreeNode(v);
    
        counter++;
        return cur->val;
    }
    
    TreeNode* get_root() {
        return r;
    }
};

/**
 * Your CBTInserter object will be instantiated and called as such:
 * CBTInserter* obj = new CBTInserter(root);
 * int param_1 = obj->insert(val);
 * TreeNode* param_2 = obj->get_root();
 */
```







# 921 Minimum Add to Make Parentheses Valid



<img src="901-1000.assets/image-20210916151953888.png" alt="image-20210916151953888" style="zoom:50%;" />

```cpp
class Solution {
public:
    int minAddToMakeValid(string s) {
        int size = s.size();
        int moves = 0;
        int left = 0;
        
        for(int i = 0; i < size; i++){
            if(s[i] == '('){
                left++;
            }else if(s[i] == ')'){
                if(left == 0)
                    moves++;
                else
                    left--;
            }
        }
        
        return moves + left;
    }
};
```







# 922 Sort Array By Parity II

<img src="901-1000.assets/image-20210522205724866.png" alt="image-20210522205724866" style="zoom:50%;" />

```go
func sortArrayByParityII(nums []int) []int {
	even, odd := 0, 1

	for ;odd < len(nums) && even < len(nums);{
		for;odd < len(nums) && nums[odd] % 2 != 0;{
			odd += 2
		}

		for ;even < len(nums) && nums[even] % 2 == 0;{
			even += 2
		}

		if odd >= len(nums) || even >= len(nums){
			break
		}

		nums[odd],nums[even] = nums[even], nums[odd]
		odd  += 2
		even += 2
	}

	return nums
}
```







# 937 Reorder Data in Log Files





<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210511154500700.png" alt="image-20210511154500700" style="zoom:50%;" />

```go
    public String[] reorderLogFiles(String[] logs) {
        List<String> nums = new ArrayList<>();
        List<String> alpha = new ArrayList<>();

        for(int i = 0 ; i < logs.length; i++){
            String log = logs[i];

            int pos = log.indexOf(" ");
            char ch  = log.charAt(pos + 1);
            if('0' <= ch && ch <= '9')
                nums.add(log);
            else
                alpha.add(log);
        }

        alpha.sort(new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                int pos1 = o1.indexOf(" ");
                int pos2 = o2.indexOf(" ");

                String sub1 = o1.substring(pos1 + 1);
                String sub2 = o2.substring(pos2 + 1);

                if (sub1.compareTo(sub2) == 0) {
                    return o1.substring(0, pos1).compareTo(o2.substring(0, pos2));
                } else {
                    return sub1.compareTo(sub2);
                }
            }
        });
        
        String[] res = new String[logs.length];
        for(int i = 0; i < logs.length; i++){
            if(i < alpha.size())
                res[i] = alpha.get(i);
            else
                res[i] = nums.get(i - alpha.size());
        }
        
        return res;
    }
```





# 934 Shortest Bridge

<img src="901-1000.assets/image-20210730213049084.png" alt="image-20210730213049084" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int row, col;
    int shortestBridge(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();

        queue<pair<int, int>> myQueue1;
        queue<pair<int, int>> myQueue2;

        unordered_set<string> set1;
        unordered_set<string> set2;
        bool jump = false;

        for(int i = 0; i < row && !jump; i++){
            for(int j = 0; j < col && !jump; j++){
                if(grid[i][j] == 1){
                    dfs(grid, i, j);
                    jump = !jump;
                }
            }
        }

        // island 1 and island 2
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 1){
                    myQueue1.push({i, j});
                    set1.insert(to_string(i) + "@" + to_string(j));
                }else if(grid[i][j] == 2){
                    myQueue2.push({i, j});
                    set2.insert(to_string(i) + "@" + to_string(j));
                }
            }
        }

        if(myQueue2.size() == 0 || myQueue1.size() == 0)
            return 0;

        int count = 0;
        while(true){
            int size1 = myQueue1.size();
            for(int i = 0; i < size1; i++){
                pair<int, int> curPos1 = myQueue1.front(); myQueue1.pop();

                for(int k = 0; k < 4; k++){
                    int newX = curPos1.first + dir[k][0];
                    int newY = curPos1.second + dir[k][1];
                    string symbol = to_string(newX) + "@" + to_string(newY);

                    if(set2.count(symbol) != 0)
                        return 2 * count;

                    if(isInRange(newX, newY) && set1.count(symbol) == 0){
                        myQueue1.push({newX, newY});
                        set1.insert(symbol);
                    }
                }
            }

            int size2 = myQueue2.size();
            for(int i = 0; i < size2; i++){
                pair<int, int> curPos2 = myQueue2.front(); myQueue2.pop();

                for(int k = 0; k < 4; k++){
                    int newX = curPos2.first  + dir[k][0];
                    int newY = curPos2.second + dir[k][1];
                    string symbol = to_string(newX) + "@" + to_string(newY);

                    if(set1.count(symbol) != 0)
                        return 2 * count + 1;

                    if(isInRange(newX, newY) && set2.count(symbol) == 0){
                        myQueue2.push({newX, newY});
                        set2.insert(symbol);
                    }
                }
            }

            count++;
        }

        return -1;
    }

    inline bool isInRange(int i ,int j){
        return i >= 0 && j >= 0 && i < row && j < col;
    }

    void dfs(vector<vector<int>>& grid, int i, int j){
        grid[i][j] = 2;

        for(int k = 0; k < 4; k++){
            int newX = i + dir[k][0];
            int newY = j + dir[k][1];

            if(isInRange(newX, newY) && grid[newX][newY] == 1){
                dfs(grid, newX, newY);
            }
        }
    }
};

```





# 935 Knight Dialer

```cpp
/*
		有一个更好理解的 DP方法
		
		首先可以分类为 A B C D
		
		A = 1 3 7 9
		B = 2 8
		C = 4 6
		D = 0
		
		1个A 可以转换为  1个 B and 1个C
			A -> B, C
			B -> 2A
			C -> 2 * A + D
			D -> 2 * C
			
			所以下一轮的 DP 可以基于上一轮的结果
			next[B] += this[A]
			next[C] += this[A]
			
			next[A] += 2 * this[B]
			
			next[A] += 2 * this[C]
			next[D] += this[C]
			
			next[C] += 2 * this[D]
		
*/
class Solution {
public:
    int knightDialer(int n) {
        if(n == 1)
            return 10;
        int mod = 1e9 + 7;
        
        /*
            0
                1 3 7 9
            1
                2 8
            2
                4 6
            3
                0
                
            0 -> B,C
            1 -> 2A
            
            2 -> 2 * A + D
            3 -> 2 -> 2
        */
        
        vector<long> res(4, 0);
        res[0] = 4;
        res[1] = 2;
        res[2] = 2;
        res[3] = 1;
        
        for(int i = 2; i <= n; i++){
            vector<long> temp(4, 0);
            
            temp[1] += (res[0]) % mod;
            temp[2] += (res[0]) % mod;
            
            temp[0] += (2 * res[1]) % mod;
            
            temp[0] += (2 * res[2]) % mod;
            temp[3] += (res[2]) % mod;
            temp[2] += (2 * res[3]) % mod;
 /*
 			next[B] += this[A]
			next[C] += this[A]
			
			next[A] += 2 * this[B]
			
			next[A] += 2 * this[C]
			next[D] += this[C]
			
			next[C] += 2 * this[D]
		
 */           
            swap(temp, res);
        }
        
        return (res[0] + res[1] + res[2] + res[3]) % mod;
    }
};
```



```cpp
ref : https://leetcode-cn.com/problems/knight-dialer/solution/4zhuang-tai-dong-tai-gui-hua-pythonjie-kong-jian-f/
class Solution {
public:
    int mod = 1e9 + 7;
    int knightDialer(int n) {
        if(n == 1)
            return 10;
        vector<long> dp(4, 1);
        for(int i = 2; i <= n; i++){
            vector<long> newDP(4, 0);
            newDP[0] = (dp[1] % mod + dp[2] % mod) % mod;
            newDP[1] = (2 * dp[0]) % mod;
            newDP[2] = ((2 * dp[0]) % mod + dp[3] % mod) % mod;
            newDP[3] = (2 * dp[2]) % mod;

            swap(dp, newDP);
        }

        return (4 * dp[0] + 2 * dp[1] + 2 * dp[2] + dp[3]) % mod;
    }
};
```





<img src="901-1000.assets/image-20210731152145979.png" alt="image-20210731152145979" style="zoom:50%;" />



```cpp
class Solution {
public:
    int mod = 1000000007;
    int knightDialer(int n) {
        unordered_map<int, vector<int>> lookup;
        lookup[1] = {6, 8};
        lookup[2] = {7, 9};
        lookup[3] = {4, 8};
        lookup[4] = {3, 9, 0};
        lookup[5] = {};
        lookup[6] = {0, 1, 7};
        lookup[7] = {2, 6};
        lookup[8] = {1, 3};
        lookup[9] = {2, 4};
        lookup[0] = {4, 6};

        unordered_map<int, long> map;
        for(int i = 0; i < 10; i++)
            map[i] = 1;

        for(int i = 2; i <= n; i++){
            unordered_map<int, long> temp;

            for(int j = 0; j < 10; j++){
                for(int nextDest : lookup[j]){
//                    cout << "in j " << j  << " next dest" << nextDest << "map -> " << map[j] << endl;
                    temp[nextDest] += map[j];
                    temp[nextDest] %= mod;
                }
            }

            map = temp;
        }

        long res = 0;
        for(int i = 0; i < 10; i++)
            res += map[i];
        
        return (int)(res % mod);
    }
};
```







# 938 Range Sum of BST

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210510171201951.png" alt="image-20210510171201951" style="zoom:50%;" />

<img src="/Users/admin/Library/Application Support/typora-user-images/image-20210510171151429.png" alt="image-20210510171151429" style="zoom:50%;" />

```java
    int sum = 0;
    public int rangeSumBST(TreeNode root, int low, int high) {
        preorder(root, low, high);
        return sum;
    }
    
    private void preorder(TreeNode root, int low, int high){
        if(root == null)
            return;
        
        if(root.val >= low && root.val <= high)
            sum += root.val;
        
        preorder(root.left, low, high);
        preorder(root.right, low, high);
    }
```





# 939 Minimum Area Rectangle



```cpp
//这个时间复杂度 相对较低
//因为拿map 做了优化
class Solution {
public:
    int minAreaRect(vector<vector<int>>& points) {
        unordered_map<int, unordered_set<int>> map;
        for(auto& point : points)
            map[point[0]].insert(point[1]);

        int res = INT_MAX;
        int size = points.size();
        for(int i = 0; i < size; i++){
            for(int j = i + 1; j < size; j++){
                int x1 = points[i][0];
                int y1 = points[i][1];
                int x2 = points[j][0];
                int y2 = points[j][1];

                if(x1 == x2 || y1 == y2)
                    continue;

                int x3 = x1;
                int y3 = y2;
                int x4 = x2;
                int y4 = y1;

                if(map.count(x3) == 0 || map[x3].count(y3) == 0)
                    continue;
                if(map.count(x4) == 0 || map[x4].count(y4) == 0)
                    continue;
                
                res = min(res, abs(x2 - x1) * abs(y2 - y1));
            }
        }

        return res == INT_MAX ? 0 : res;
    }
};
```







```cpp
//超时代码，时间复杂度 On^2
struct pairHash{
    size_t operator()(const pair<int, int>& v) const{
        return v.first * 107 + v.second;
    }
};

class Solution {
public:
    int minAreaRect(vector<vector<int>>& points) {
        unordered_set<pair<int, int>, pairHash> set;

        for(auto& point : points){
            set.insert({point[0], point[1]});
        }

        sort(points.begin(), points.end(), [&](auto& v1, auto& v2){
            return v1[0] == v2[0] ? v1[1] < v2[1] : v1[0] < v2[0];
        });

        int size = points.size();
        int res = INT_MAX;
        for(int i = 0; i < size; i++){
            for(int j = i + 1; j < size; j++){
               
                auto p1 = points[i]; // bottom left
                auto p2 = points[j]; // top right

                if(p2[0] <= p1[0] || p2[1] <= p1[1])
                    continue;

                pair<int, int> p3 = {p1[0], p2[1]};
                pair<int, int> p4 = {p2[0], p1[1]};

                if(set.count(p3) != 0 && set.count(p4) != 0){
                    res = min(res, (p2[0] - p1[0]) * (p2[1] - p1[1]));
//                    cout << " ? " << endl;
                }
            }
        }

        return res == INT_MAX ? 0 : res;
    }
};
```









# 941Valid Mountain Array



![image-20210626092850350](901-1000.assets/image-20210626092850350.png)

```cpp
class Solution {
public:
    bool validMountainArray(vector<int>& arr) {
        int len = arr.size();
        if(len < 3)
            return false;

        int index = 1;
        while(index < len - 1 && arr[index] > arr[index - 1])
            index++;
        
        if(index == 1){
            if(arr[index] <= arr[index - 1])
                return false;
        }else if(index == len - 1){
            return arr[index - 1] > arr[index] ;
        }

        while(index < len - 1 && arr[index] > arr[index + 1])
            index++;
        
        return index == len - 1;
    }
};
```







# 945 Minimum Increment to Make Array Unique





```cpp
class Solution {
public:
    int minIncrementForUnique(vector<int>& nums) {
        int len = nums.size();

        sort(nums.begin(), nums.end());
        int count = 0;
        int curNum = -1;
        for(int i = 0; i < len; i++){
            if(curNum >= nums[i]){
                count += curNum + 1 - nums[i];
                curNum += 1;
            }else{
                curNum = nums[i];
            }
        }
        
        return count;
    }
};
```









# 951 Flip Equivalent Binary Trees



<img src="901-1000.assets/image-20210927191121844.png" alt="image-20210927191121844" style="zoom:50%;" />

```cpp

class Solution {
public:
    bool flipEquiv(TreeNode* root1, TreeNode* root2) {
        if(root1 == nullptr || root2 == nullptr){
            if(root1 == nullptr && root2 == nullptr)
                return true;
            return false;
        }
        
        /*
            postorder 
        */
        if(root1->val == root2->val){
            return (
                (flipEquiv(root1->left, root2->left) && flipEquiv(root1->right, root2->right))
                ||
                 (flipEquiv(root1->left, root2->right) && flipEquiv(root1->right, root2->left))
            );
        }else{
            return false;
        }
        
    }
};
```









# 953 Verifyign An Alien Dictionary

![image-20210916074242393](901-1000.assets/image-20210916074242393.png)

```cpp
class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        int size = words.size();
        
        for(int i = 0; i < size - 1; i++){
            string curStr  = words[i];
            string nextStr = words[i + 1];
            
            if(curStr.size() > nextStr.size() && curStr.find(nextStr) == 0)
                return false;
            
            int minSize = min(curStr.size(), nextStr.size());
            char ch1 = '#';
            char ch2 = '#';
            for(int j = 0; j < minSize; j++){
                if(curStr[j] != nextStr[j]){
                    ch1  = curStr[j];
                    ch2 = nextStr[j];
                    break;
                }
            }
            
            if(ch1 != '#' && ch2 != '#'){
                int pos1 = order.find(ch1);
                int pos2 = order.find(ch2);
                if(pos1 > pos2)
                    return false;
            }
        }
        
        return true;
    }
};
```





# 954 Array of Doubleed

![image-20210928201535807](901-1000.assets/image-20210928201535807.png)

```cpp
class Solution {
public:
    bool canReorderDoubled(vector<int>& arr) {
        int size = arr.size();
        sort(arr.begin(), arr.end());
        map<int, int> m;

        for(int num : arr)
            m[num]++;
        

        for(auto it = m.begin(); it != m.end(); it++){
            cout << it->first << endl;
            if(it->first == 0){
                if(it->second % 2 != 0)
                    return false;
                it->second = 0;
                continue;
            }
            
            if(it->second == 0)
                continue;
            
            if(it->first > 0){
                int cur  = it->first;
                int next = 2 * cur;
                
                if(m[cur] > m[next])
                    return false;
                m[next] -= m[cur];
                m[cur] = 0;

            }else{
                int cur = it->first;
                int next = cur / 2;
                if(cur % 2 != 0)
                    return false;
                
                if(m.count(next) == 0 || m[cur] > m[next])
                    return false;
                
                m[next] -= m[cur];

                m[cur] = 0;

            }
        }
        
        for(auto it = m.begin(); it != m.end(); it++){
            if(it->second != 0){
                cout << it->first << endl;
                return false;
            }
        }
        
        return true;
    }
};
```







# 973 K Closest Points to Origin

<img src="901-1000.assets/image-20210914192322972.png" alt="image-20210914192322972" style="zoom:50%;" />

```cpp
class Solution {
public:
    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {
        vector<vector<int>> res;
        unordered_map<int, vector<int>> map;
        priority_queue<int, vector<int>, less<>> pq;
        unordered_set<int> set;
        
        for(int i = 0; i < points.size(); i++){
            auto point = points[i];
            int dis = getDis(point[0], point[1]);
            
            pq.push(dis);
            
            map[dis].push_back(i);
            if(pq.size() > k)
                pq.pop();
        }
        
        while(!pq.empty()){
            set.insert(pq.top()); pq.pop();
        }
        
        for(auto it = set.begin(); it != set.end(); ++it){
            int num = *it;
            
            if(map.count(num) != 0){
                vector<int> indexs = map[num];
                for(int index : indexs){
                    res.push_back({points[index][0], points[index][1]});
                }
            }
        }
        
        return res;
    }
    
    int getDis(int i, int j){
            return i * i + j * j;
    }
};
```













# 977 Squares of a Sorted Array

<img src="901-1000.assets/image-20210520155640938.png" alt="image-20210520155640938" style="zoom:50%;" />

```go
func sortedSquares(nums []int) []int {
    index := 0
    for ; index < len(nums); index++{
        if index > 0 && nums[index] * nums[index - 1] <= 0{
            break
        }
    }

    res := make([]int, 0)

    if index == len(nums){
        if nums[index - 1] > 0{
            for index = 0; index < len(nums); index++{
                res = append(res, nums[index] * nums[index])
            }
        }else{
            for index = len(nums) - 1; index >= 0; index--{
                res = append(res, nums[index] * nums[index])
            }
        }

    }else{
        left := index - 1
        right := index

        for ;left >= 0 || right < len(nums);{
            if left < 0{
                res = append(res, nums[right] * nums[right])
                right++
            }else if right >= len(nums){
                res = append(res, nums[left] * nums[left])
                left--
            }else if nums[left] * nums[left] < nums[right] * nums[right]{
                res = append(res, nums[left] * nums[left])
                left--
            }else{
                res = append(res, nums[right] * nums[right])
                right++
            }
        }

    }

    return res
}

```





# 979 Distribute Coins in Binary Tree



```cpp
class Solution {
public:
    int count = 0;
    int distributeCoins(TreeNode* root) {
        postorder(root);
        return count;
    }

    int postorder(TreeNode* root){
        if(root == nullptr)
            return 0;

        int left = postorder(root->left);
        int right = postorder(root->right);

        int cur = root->val - 1 + left + right;

        count += abs(cur);
        return cur;

    }
};
```







# 981 Time based Key-Value Store



```cpp
//更新了数据结构，采用 二分进行查找
class TimeMap {
public:
    /*
        unordered<key, map<int, strign -> value>> map
    */
    unordered_map<string, vector<pair<int, string>> > map;
    TimeMap() {}
    
    void set(string key, string value, int timestamp) {
        map[key].push_back({timestamp, value});
    }
    
    string get(string key, int timestamp) {
        if(map.count(key) == 0)
            return "";
        
        auto& v = map[key];
        if(v.size() == 0)
            return "";
        
        int size = v.size();
        for(int i = size - 1; i >= 0; i--){
            if(v[i].first <= timestamp)
                return v[i].second;
        }
        
        return "";
    }
};

/**
 * Your TimeMap object will be instantiated and called as such:
 * TimeMap* obj = new TimeMap();
 * obj->set(key,value,timestamp);
 * string param_2 = obj->get(key,timestamp);
 */
```





![image-20210902214123889](901-1000.assets/image-20210902214123889.png)

```cpp
/*
		Author: guoguo
		本质就是 用链表提提速
*/
class Node{
public:
    Node* prev;
    Node* next;
    int timeStamp;
    string val;
    Node(int t, string& v) : prev(nullptr), next(nullptr), timeStamp(t), val(v){}
    Node(int t) : prev(nullptr), next(nullptr), timeStamp(t), val(""){}
};

class DoublyLinkedList{
public:
    Node* head;
    Node* tail;

    DoublyLinkedList() : head(new Node(0)), tail(new Node(INT_MAX)){
        
        head->next = tail;
        tail->prev = head;
    }

    void addLast(Node* node){
        node->next = tail;
        node->prev = tail->prev;

        tail->prev->next = node;
        tail->prev = node;
    }

};
class TimeMap {
public:
    unordered_map<string, unordered_map<int, Node*>> map1;
    unordered_map<string,  DoublyLinkedList*> map2;
    /** Initialize your data structure here. */
    TimeMap() {    }

    void set(string key, string value, int timestamp) {
        if(map1.count(key) == 0) {
            map2[key] = new DoublyLinkedList();
        }

        Node* node = new Node(timestamp, value);
        map2[key]->addLast(node);
        map1[key][timestamp] = node;
    }

    string get(string key, int timestamp) {
        if(map1.count(key) == 0)
            return "";

        Node* curNode = map1[key][timestamp];
        
        if(curNode == nullptr){
            if(map2[key]->tail->prev == map2[key]->head ) {
                return "";
            }else {
                Node* cur = map2[key]->tail->prev;
                while(cur != nullptr){
                    if(cur->timeStamp <= timestamp)
                        return cur->val;
                    cur = cur->prev;
                }
                
                return "";
            }
        } 

        if(curNode->timeStamp == timestamp)
            return curNode->val;
        if(curNode->prev == map2[key]->head)
            return "";
        
        return curNode->prev->val;
    }
};

```







# 983 Minumum Cost For Tickets



```cpp
//dp 思想
/*
		之所以要分为 i == dayIndex 表示这一天我必须得有票
*/
class Solution {
public:
    int mincostTickets(vector<int>& days, vector<int>& costs) {
        int size = days.size();
        
        vector<int> dp(days[size - 1] + 1, 0);
        int dayIndex = 0;
        for(int i = 1; i < dp.size(); i++){
            if(i == days[dayIndex]){
                dp[i] = min(
                        dp[max(0, i - 1)] + costs[0],min(
                        dp[max(0, i - 7)] + costs[1],
                        dp[max(0, i - 30)] + costs[2]));
                
                dayIndex++;
            }else{
                dp[i] = dp[i - 1];
            }
        }
        
        return dp[dp.size() - 1];
    }
};
```





# 984 String Without AAA 



```cpp
/*
		简单的思路，就是当 a和b个数相等的时候，最舒服
		直接 ababababa
		
		剩下的就是往里面插a & b
		当然a > b 和 b > a 是不同的情况，需要多加注意
*/

class Solution {
public:
    string strWithout3a3b(int a, int b) {
        int minFreq = std::min(a, b);
        string res = "";
        for(int i = 0; i < minFreq; i++) {
            if(a > b)
                res += "ab";
            else
                res += "ba";
        }

        int count = 0;
        if(a > b){
            for(int i = 0; count != a - b && i < res.size();i++){
                if(res[i] == 'b') {
                    res.insert(res.begin() + i, 'a');
                    count++;
                    i += 2;
                }
            }
        }else if(a < b){
            for(int i = 0; count != b - a && i < res.size(); i++){
                if(res[i] == 'a') {
                    res.insert(res.begin() + i, 'b');
                    count++;
                    i += 2;
                }
            }
        }

        if(count != abs(a - b)){
            for(int i = 0; i < abs(a - b) - count; i++){
                if(a > b)
                    res += "a";
                else
                    res += "b";
            }
        }
        return res;
    }
};

```





```cpp
/*
		更好的 PQ 解法
		ref https://github.com/wisdompeak/LeetCode
		
		整体思路是 每次从堆中拿两个元素，
		比如 a > b
		那么我就尽量多拿a， 拿2个a 一个b
		res += aab
*/
class Solution {
public:
    string strWithout3a3b(int a, int b) {
        priority_queue<pair<int, int>> pq;
        pq.push({a, 'a'});
        pq.push({b, 'b'});

        string res = "";
        while(!pq.empty()){
            if(pq.size() == 1){
                int freq = pq.top().first;
                if(freq > 2)
                    return "";
                else{
                    for(int i = 0; i < freq; i++)
                        res.push_back(pq.top().second);
                    return res;
                }
            }
            
            auto x = pq.top(); pq.pop();
            auto y = pq.top(); pq.pop();

            int k = std::min(1 + x.first - y.first, 2);
            for(int i = 0; i < k; i++)
                res.push_back(x.second);
            res.push_back(y.second);

            x.first -= k;
            y.first -= 1;
            if(x.first > 0)   pq.push({x.first, x.second});
            if(y.first > 0)   pq.push({y.first, y.second});
            
        }

        return res;
    }
};
```







# 987[987. Vertical Order Traversal of a Binary Tree](https://leetcode-cn.com/problems/vertical-order-traversal-of-a-binary-tree/)

![image-20210922213910195](901-1000.assets/image-20210922213910195.png)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
struct cmp{
    template<class T1, class T2>
    size_t operator()(const pair<T1, T2>&  p) const{
        size_t h1 = hash<T1>(p->first);
        size_t h2 = hash<T2>(p->second);

        return h1 ^ h2;
    }
};

class Solution {
public:
    int minRow = 0;
    int maxRow = 0;
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        //step1: preform preorder
        map<pair<int, int>, vector<int>> map1;
        preorder(root, map1, 0, 0);

        //step2:
        //convert the index into res;
        vector<vector<int>> res;
        unordered_set<int> visited;
        vector<int> cols;
        for(auto it = map1.begin(); it != map1.end(); it++){
            if(visited.count(it->first.second) == 0){
                cols.push_back(it->first.second);
                visited.insert(it->first.second);
            }
        }   

        sort(cols.begin(), cols.end());
        for(int i = 0; i < cols.size(); i++){
            res.push_back(vector<int>());
            for(int j = minRow; j <= maxRow; j++){
                pair<int, int> p = {j, cols[i]};
                if(map1.count(p) != 0){
                    vector<int>& v = map1[p];
                    sort(v.begin(), v.end());
                  
                    for(int num : v){
                        res[res.size() - 1].push_back(num);
                    }
                }
            }
        }

        return res;
    }

    void preorder(TreeNode* root, map<pair<int, int>, vector<int>>& map1, int row, int col){
        if(root == nullptr)
            return ;

        maxRow = max(maxRow, row);
        map1[{row, col}].push_back(root->val);

        preorder(root->left,  map1, row + 1, col - 1);
        preorder(root->right, map1, row + 1, col + 1);
    }


};
```







# 986  Inteval List Intersections

<img src="901-1000.assets/image-20210921161435362.png" alt="image-20210921161435362" style="zoom:50%;" />

```cpp

/*
		Corner cases 挺多的
*/
class Solution {
public:
    vector<vector<int>> intervalIntersection(vector<vector<int>>& firstList, vector<vector<int>>& secondList) {
        vector<vector<int>> res;

        int size1 = firstList.size();
        int size2 = secondList.size();
        int index1 = 0;
        int index2 = 0;

        while(index1 < size1 && index2 < size2){
            if(firstList[index1][1] < secondList[index2][0]
                || secondList[index2][1] < firstList[index1][0]){ // no intersection at this time
                //do nothing
            }else{  // do have at lease one intersection
                int leftInterval = max(firstList[index1][0], secondList[index2][0]);
                int rightInterval = min(firstList[index1][1], secondList[index2][1]);

                res.push_back({leftInterval, rightInterval});
            }

          		//注意我们认为末尾看完才是真的看完了
            if(firstList[index1][1] < secondList[index2][1])
                index1++;
            else
                index2++;
        }

        return res;
    }
};
```



# 993 Cousins In Binary Tree

<img src="901-1000.assets/image-20210911150548683.png" alt="image-20210911150548683" style="zoom:50%;" />

```cpp
//BFS
class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        if(root == nullptr)
            return false;
        
        deque<TreeNode*> myQueue;
        myQueue.push_back(root);

        while(!myQueue.empty()){
            int size = myQueue.size();
//            cout << "---" << endl;
            unordered_set<int> set;
   
            for(int i = 0; i < size; i++){
                int counter = 0;
                TreeNode* cur = myQueue.front(); myQueue.pop_front();
//                cout << cur->val << endl;

                if(cur->left != nullptr){
  //                  cout << cur->left->val << endl;
                    set.insert(cur->left->val);
                    myQueue.push_back(cur->left);
                    if(cur->left->val == x || cur->left->val == y)
                        counter++;
                }

                if(cur->right != nullptr){
                    set.insert(cur->right->val);
//                    cout << cur->right->val << endl;
                    myQueue.push_back(cur->right);
                    if(cur->right->val == x || cur->right->val == y)
                        counter++;
                }

                if(counter == 2)
                    return false;
            }

            if(set.count(x) != 0 && set.count(y) != 0)
                return true;
        }

        return false;
    }
};
```







# 994 Rotting-Orange



<img src="901-1000.assets/image-20210730142155950.png" alt="image-20210730142155950" style="zoom:50%;" />

```cpp
//进行优化
class Solution {
public:
    vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int row;
    int col;
    int orangesRotting(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();

        queue<pair<int, int>> myQueue;
        int fresh = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 2){
                    myQueue.push({i, j});
                    grid[i][j] = -1;
                }else if(grid[i][j] == 1)
                    fresh++;
            }
        }

        if(fresh == 0)
            return 0;
        auto isInRange =  [&](int i, int j){return i >= 0 && j >= 0 && i < row && j < col;};

        int res = 0;
        int round = 0;
        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                pair<int, int> curPos = myQueue.front();
                myQueue.pop();

                for(int k = 0; k < dir.size(); k++){
                    int newX = curPos.first + dir[k][0];
                    int newY = curPos.second + dir[k][1];
                    string symbol = to_string(newX) + "@" + to_string(newY);

                    if(isInRange(newX, newY) && grid[newX][newY] == 1){
                        fresh--;

                        if(fresh == 0)
                            return round + 1;
                        grid[newX][newY] = -1;
                        myQueue.push({newX, newY});
                    }
                }
            }

            round++;
        }

        return fresh == 0 ? round : -1;
    }


};
```





<img src="901-1000.assets/image-20210730141701527.png" alt="image-20210730141701527" style="zoom:50%;" />

```cpp

class Solution {
public:
    vector<vector<int>> dir{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int row;
    int col;
    int orangesRotting(vector<vector<int>>& grid) {
        row = grid.size();
        col = grid[0].size();

        queue<pair<int, int>> myQueue;
        unordered_set<string> set;
        int fresh = 0;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(grid[i][j] == 2){
                    myQueue.push({i, j});
                    set.emplace(to_string(i) + "@" + to_string(j));
                }else if(grid[i][j] == 1)
                    fresh++;
            }
        }

        if(fresh == 0)
            return 0;
            
        int res = 0;
        int round = 0;
        while(!myQueue.empty()){
            int size = myQueue.size();
            for(int i = 0; i < size; i++){
                pair<int, int> curPos = myQueue.front();
                myQueue.pop();

                for(int k = 0; k < dir.size(); k++){
                    int newX = curPos.first + dir[k][0];
                    int newY = curPos.second + dir[k][1];
                    string symbol = to_string(newX) + "@" + to_string(newY);

                    if(isInRange(newX, newY) && set.count(symbol) == 0 && grid[newX][newY] != 0){
                        set.emplace(symbol);

                        if(grid[newX][newY] == 1)
                            fresh--;

                        if(fresh == 0)
                            return round + 1;
                        grid[newX][newY] = 2;
                        myQueue.push({newX, newY});
                        set.emplace(symbol);
                    }
                }
            }

            round++;
        }

        return fresh == 0 ? round : -1;
    }

    bool isInRange(int i, int j){
        return i >= 0 && j >= 0 && i < row && j < col;
    }
};
```





# 996 Number of Squareful Array

<img src="901-1000.assets/image-20210805174344811.png" alt="image-20210805174344811" style="zoom:50%;" />

```cpp
/*
		如果不能枚举， 就自己构造
*/
class Solution {
public:
    int count = 0;
    int numSquarefulPerms(vector<int>& nums) {
        int size = nums.size();
        vector<bool> visited(size, false);
        sort(nums.begin(), nums.end());
        vector<int> path;
        backtrack(nums, visited, path, 0);

        return count;
    }

    void backtrack(vector<int>& nums, vector<bool> visited, vector<int> path,int cur){
        if(cur == nums.size()){
            count++;
            return;
        }

        for(int i = 0; i < visited.size(); i++){
            if(visited[i] || (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]))
                continue;

            if(cur == 0){
                path.push_back(nums[i]);
                visited[i] = true;
                
                backtrack(nums, visited, path, cur + 1);

                path.pop_back();
                visited[i] = false;
            }else{
                int sqr = std::sqrt(nums[i] + path[path.size() - 1]);
                if(sqr * sqr == nums[i] + path[path.size() - 1]){
                    path.push_back(nums[i]);
                    visited[i] = true;                        

                    backtrack(nums, visited, path, cur + 1);

                    path.pop_back();
                    visited[i] = false;
                }
            }

        }
    }
};
```





# 997 Find the Town Judge



<img src="901-1000.assets/image-20210607212221222.png" alt="image-20210607212221222" style="zoom:50%;" />

```java
    public int findJudge(int n, int[][] trust) {
        int[] in  = new int[n + 1];
        int[] out = new int[n + 1];

        for(int i = 0; i < trust.length; i++){
            int A = trust[i][0];
            int B = trust[i][1];

            in[B]++;
            out[A]++;
        }

        for(int i = 1; i <= n; i++){
            if(in[i] == n - 1 && out[i] == 0)
                return i;
        }

        return -1;
    }
```



<img src="901-1000.assets/image-20210607211940204.png" alt="image-20210607211940204" style="zoom:50%;" />

```java
    public int findJudge(int n, int[][] trust) {
        if(n == 1 && trust.length == 0)
            return 1;

        Map<Integer, Integer> map = new HashMap<>();
        Set<Integer> set = new HashSet<>();
        
        for(int i = 0; i < trust.length; i++) {
            map.put(trust[i][1], map.getOrDefault(trust[i][1], 0) + 1);
            set.add(trust[i][0]);
        }
        
        List<Integer> judges = new ArrayList<>();
        for(Integer potentialJudge : map.keySet()){
            if(map.get(potentialJudge) == n - 1 && !set.contains(potentialJudge))
                return potentialJudge;
        }
        
        return -1;
    }
```









